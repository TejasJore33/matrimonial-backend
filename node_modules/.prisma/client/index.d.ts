
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Profile
 * 
 */
export type Profile = $Result.DefaultSelection<Prisma.$ProfilePayload>
/**
 * Model Photo
 * 
 */
export type Photo = $Result.DefaultSelection<Prisma.$PhotoPayload>
/**
 * Model Verification
 * 
 */
export type Verification = $Result.DefaultSelection<Prisma.$VerificationPayload>
/**
 * Model Interest
 * 
 */
export type Interest = $Result.DefaultSelection<Prisma.$InterestPayload>
/**
 * Model Chat
 * 
 */
export type Chat = $Result.DefaultSelection<Prisma.$ChatPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model ProfileView
 * 
 */
export type ProfileView = $Result.DefaultSelection<Prisma.$ProfileViewPayload>
/**
 * Model ContactView
 * 
 */
export type ContactView = $Result.DefaultSelection<Prisma.$ContactViewPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model AddOn
 * 
 */
export type AddOn = $Result.DefaultSelection<Prisma.$AddOnPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model ServiceProvider
 * 
 */
export type ServiceProvider = $Result.DefaultSelection<Prisma.$ServiceProviderPayload>
/**
 * Model ServiceBooking
 * 
 */
export type ServiceBooking = $Result.DefaultSelection<Prisma.$ServiceBookingPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model SavedSearch
 * 
 */
export type SavedSearch = $Result.DefaultSelection<Prisma.$SavedSearchPayload>
/**
 * Model OTP
 * 
 */
export type OTP = $Result.DefaultSelection<Prisma.$OTPPayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model Report
 * 
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>
/**
 * Model Shortlist
 * 
 */
export type Shortlist = $Result.DefaultSelection<Prisma.$ShortlistPayload>
/**
 * Model BlockedUser
 * 
 */
export type BlockedUser = $Result.DefaultSelection<Prisma.$BlockedUserPayload>
/**
 * Model Horoscope
 * 
 */
export type Horoscope = $Result.DefaultSelection<Prisma.$HoroscopePayload>
/**
 * Model HoroscopeMatch
 * 
 */
export type HoroscopeMatch = $Result.DefaultSelection<Prisma.$HoroscopeMatchPayload>
/**
 * Model SuccessStory
 * 
 */
export type SuccessStory = $Result.DefaultSelection<Prisma.$SuccessStoryPayload>
/**
 * Model FamilyMember
 * 
 */
export type FamilyMember = $Result.DefaultSelection<Prisma.$FamilyMemberPayload>
/**
 * Model Referral
 * 
 */
export type Referral = $Result.DefaultSelection<Prisma.$ReferralPayload>
/**
 * Model Achievement
 * 
 */
export type Achievement = $Result.DefaultSelection<Prisma.$AchievementPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model VideoCall
 * 
 */
export type VideoCall = $Result.DefaultSelection<Prisma.$VideoCallPayload>
/**
 * Model ProfileComparison
 * 
 */
export type ProfileComparison = $Result.DefaultSelection<Prisma.$ProfileComparisonPayload>
/**
 * Model ForumPost
 * 
 */
export type ForumPost = $Result.DefaultSelection<Prisma.$ForumPostPayload>
/**
 * Model ForumComment
 * 
 */
export type ForumComment = $Result.DefaultSelection<Prisma.$ForumCommentPayload>
/**
 * Model CommunityGroup
 * 
 */
export type CommunityGroup = $Result.DefaultSelection<Prisma.$CommunityGroupPayload>
/**
 * Model GroupMember
 * 
 */
export type GroupMember = $Result.DefaultSelection<Prisma.$GroupMemberPayload>
/**
 * Model CommunityEvent
 * 
 */
export type CommunityEvent = $Result.DefaultSelection<Prisma.$CommunityEventPayload>
/**
 * Model EventParticipant
 * 
 */
export type EventParticipant = $Result.DefaultSelection<Prisma.$EventParticipantPayload>
/**
 * Model BlogPost
 * 
 */
export type BlogPost = $Result.DefaultSelection<Prisma.$BlogPostPayload>
/**
 * Model MatchScore
 * 
 */
export type MatchScore = $Result.DefaultSelection<Prisma.$MatchScorePayload>
/**
 * Model SearchHistory
 * 
 */
export type SearchHistory = $Result.DefaultSelection<Prisma.$SearchHistoryPayload>
/**
 * Model MessageTemplate
 * 
 */
export type MessageTemplate = $Result.DefaultSelection<Prisma.$MessageTemplatePayload>
/**
 * Model IceBreaker
 * 
 */
export type IceBreaker = $Result.DefaultSelection<Prisma.$IceBreakerPayload>
/**
 * Model Testimonial
 * 
 */
export type Testimonial = $Result.DefaultSelection<Prisma.$TestimonialPayload>
/**
 * Model Activity
 * 
 */
export type Activity = $Result.DefaultSelection<Prisma.$ActivityPayload>
/**
 * Model Leaderboard
 * 
 */
export type Leaderboard = $Result.DefaultSelection<Prisma.$LeaderboardPayload>
/**
 * Model Wishlist
 * 
 */
export type Wishlist = $Result.DefaultSelection<Prisma.$WishlistPayload>
/**
 * Model ProfileExport
 * 
 */
export type ProfileExport = $Result.DefaultSelection<Prisma.$ProfileExportPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  SELF_MEMBER: 'SELF_MEMBER',
  PARENT: 'PARENT',
  ADMIN: 'ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const ProfileStatus: {
  DRAFT: 'DRAFT',
  PENDING_APPROVAL: 'PENDING_APPROVAL',
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED',
  REJECTED: 'REJECTED'
};

export type ProfileStatus = (typeof ProfileStatus)[keyof typeof ProfileStatus]


export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  OTHER: 'OTHER'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const MaritalStatus: {
  NEVER_MARRIED: 'NEVER_MARRIED',
  DIVORCED: 'DIVORCED',
  WIDOWED: 'WIDOWED',
  AWAITING_DIVORCE: 'AWAITING_DIVORCE'
};

export type MaritalStatus = (typeof MaritalStatus)[keyof typeof MaritalStatus]


export const FamilyType: {
  NUCLEAR: 'NUCLEAR',
  JOINT: 'JOINT',
  EXTENDED: 'EXTENDED'
};

export type FamilyType = (typeof FamilyType)[keyof typeof FamilyType]


export const Diet: {
  VEGETARIAN: 'VEGETARIAN',
  NON_VEGETARIAN: 'NON_VEGETARIAN',
  EGGETARIAN: 'EGGETARIAN',
  VEGAN: 'VEGAN',
  JAIN: 'JAIN'
};

export type Diet = (typeof Diet)[keyof typeof Diet]


export const InterestStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED',
  WITHDRAWN: 'WITHDRAWN'
};

export type InterestStatus = (typeof InterestStatus)[keyof typeof InterestStatus]


export const SubscriptionPlan: {
  FREE: 'FREE',
  PREMIUM: 'PREMIUM',
  PARENT: 'PARENT',
  GOLD_3M: 'GOLD_3M',
  GOLD_PLUS_3M: 'GOLD_PLUS_3M',
  DIAMOND_6M: 'DIAMOND_6M',
  DIAMOND_PLUS_6M: 'DIAMOND_PLUS_6M',
  PLATINUM_PLUS_12M: 'PLATINUM_PLUS_12M'
};

export type SubscriptionPlan = (typeof SubscriptionPlan)[keyof typeof SubscriptionPlan]


export const PaymentStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  REFUNDED: 'REFUNDED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const AddOnType: {
  PROFILE_BOOST: 'PROFILE_BOOST',
  VERIFIED_BADGE: 'VERIFIED_BADGE',
  HOROSCOPE_REPORT: 'HOROSCOPE_REPORT'
};

export type AddOnType = (typeof AddOnType)[keyof typeof AddOnType]


export const ServiceType: {
  PREMIUM_PHOTO_EDITING: 'PREMIUM_PHOTO_EDITING',
  VIDEO_PROFILE_CREATION: 'VIDEO_PROFILE_CREATION',
  PROFILE_WRITING_SERVICE: 'PROFILE_WRITING_SERVICE',
  BIODATA_DESIGN: 'BIODATA_DESIGN',
  PERSONAL_MATCHMAKER: 'PERSONAL_MATCHMAKER',
  RELATIONSHIP_COUNSELING: 'RELATIONSHIP_COUNSELING',
  FAMILY_CONSULTATION: 'FAMILY_CONSULTATION',
  COMPATIBILITY_ANALYSIS: 'COMPATIBILITY_ANALYSIS',
  BACKGROUND_VERIFICATION: 'BACKGROUND_VERIFICATION',
  INCOME_VERIFICATION: 'INCOME_VERIFICATION',
  FAMILY_VERIFICATION: 'FAMILY_VERIFICATION',
  PHOTO_VERIFICATION: 'PHOTO_VERIFICATION',
  VOICE_CALL_CREDITS: 'VOICE_CALL_CREDITS',
  VIDEO_CALL_CREDITS: 'VIDEO_CALL_CREDITS',
  MESSAGE_TRANSLATION: 'MESSAGE_TRANSLATION',
  CALL_ASSISTANCE: 'CALL_ASSISTANCE',
  VIRTUAL_SPEED_DATING: 'VIRTUAL_SPEED_DATING',
  COMMUNITY_MEETUP: 'COMMUNITY_MEETUP',
  WEDDING_PLANNING: 'WEDDING_PLANNING',
  VENUE_RECOMMENDATIONS: 'VENUE_RECOMMENDATIONS',
  DETAILED_HOROSCOPE_MATCHING: 'DETAILED_HOROSCOPE_MATCHING',
  KUNDALI_GENERATION: 'KUNDALI_GENERATION',
  MUHURAT_SELECTION: 'MUHURAT_SELECTION',
  ASTROLOGY_CONSULTATION: 'ASTROLOGY_CONSULTATION',
  ADVANCED_SEARCH_FILTERS: 'ADVANCED_SEARCH_FILTERS',
  REVERSE_SEARCH: 'REVERSE_SEARCH',
  PROFILE_ANALYTICS: 'PROFILE_ANALYTICS',
  MATCH_PREDICTIONS: 'MATCH_PREDICTIONS',
  ID_VERIFICATION: 'ID_VERIFICATION',
  SAFE_MEETING_ASSISTANCE: 'SAFE_MEETING_ASSISTANCE',
  EMERGENCY_SUPPORT: 'EMERGENCY_SUPPORT',
  PRIVACY_PROTECTION: 'PRIVACY_PROTECTION',
  GIFT_SUBSCRIPTION: 'GIFT_SUBSCRIPTION',
  PROFILE_HIGHLIGHTING: 'PROFILE_HIGHLIGHTING',
  FEATURED_PROFILE: 'FEATURED_PROFILE',
  PRIORITY_LISTING: 'PRIORITY_LISTING',
  PRE_WEDDING_PHOTOGRAPHY: 'PRE_WEDDING_PHOTOGRAPHY',
  WEDDING_VENDOR_RECOMMENDATIONS: 'WEDDING_VENDOR_RECOMMENDATIONS',
  LEGAL_DOCUMENTATION_HELP: 'LEGAL_DOCUMENTATION_HELP',
  POST_MARRIAGE_SUPPORT: 'POST_MARRIAGE_SUPPORT',
  NRI_MATCHMAKING: 'NRI_MATCHMAKING',
  SECOND_MARRIAGE_SUPPORT: 'SECOND_MARRIAGE_SUPPORT',
  REGIONAL_LANGUAGE_SUPPORT: 'REGIONAL_LANGUAGE_SUPPORT'
};

export type ServiceType = (typeof ServiceType)[keyof typeof ServiceType]


export const ServiceStatus: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  REFUNDED: 'REFUNDED'
};

export type ServiceStatus = (typeof ServiceStatus)[keyof typeof ServiceStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type ProfileStatus = $Enums.ProfileStatus

export const ProfileStatus: typeof $Enums.ProfileStatus

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type MaritalStatus = $Enums.MaritalStatus

export const MaritalStatus: typeof $Enums.MaritalStatus

export type FamilyType = $Enums.FamilyType

export const FamilyType: typeof $Enums.FamilyType

export type Diet = $Enums.Diet

export const Diet: typeof $Enums.Diet

export type InterestStatus = $Enums.InterestStatus

export const InterestStatus: typeof $Enums.InterestStatus

export type SubscriptionPlan = $Enums.SubscriptionPlan

export const SubscriptionPlan: typeof $Enums.SubscriptionPlan

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type AddOnType = $Enums.AddOnType

export const AddOnType: typeof $Enums.AddOnType

export type ServiceType = $Enums.ServiceType

export const ServiceType: typeof $Enums.ServiceType

export type ServiceStatus = $Enums.ServiceStatus

export const ServiceStatus: typeof $Enums.ServiceStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs>;

  /**
   * `prisma.photo`: Exposes CRUD operations for the **Photo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Photos
    * const photos = await prisma.photo.findMany()
    * ```
    */
  get photo(): Prisma.PhotoDelegate<ExtArgs>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **Verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.VerificationDelegate<ExtArgs>;

  /**
   * `prisma.interest`: Exposes CRUD operations for the **Interest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Interests
    * const interests = await prisma.interest.findMany()
    * ```
    */
  get interest(): Prisma.InterestDelegate<ExtArgs>;

  /**
   * `prisma.chat`: Exposes CRUD operations for the **Chat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chats
    * const chats = await prisma.chat.findMany()
    * ```
    */
  get chat(): Prisma.ChatDelegate<ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs>;

  /**
   * `prisma.profileView`: Exposes CRUD operations for the **ProfileView** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProfileViews
    * const profileViews = await prisma.profileView.findMany()
    * ```
    */
  get profileView(): Prisma.ProfileViewDelegate<ExtArgs>;

  /**
   * `prisma.contactView`: Exposes CRUD operations for the **ContactView** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactViews
    * const contactViews = await prisma.contactView.findMany()
    * ```
    */
  get contactView(): Prisma.ContactViewDelegate<ExtArgs>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;

  /**
   * `prisma.addOn`: Exposes CRUD operations for the **AddOn** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AddOns
    * const addOns = await prisma.addOn.findMany()
    * ```
    */
  get addOn(): Prisma.AddOnDelegate<ExtArgs>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs>;

  /**
   * `prisma.serviceProvider`: Exposes CRUD operations for the **ServiceProvider** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceProviders
    * const serviceProviders = await prisma.serviceProvider.findMany()
    * ```
    */
  get serviceProvider(): Prisma.ServiceProviderDelegate<ExtArgs>;

  /**
   * `prisma.serviceBooking`: Exposes CRUD operations for the **ServiceBooking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceBookings
    * const serviceBookings = await prisma.serviceBooking.findMany()
    * ```
    */
  get serviceBooking(): Prisma.ServiceBookingDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.savedSearch`: Exposes CRUD operations for the **SavedSearch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SavedSearches
    * const savedSearches = await prisma.savedSearch.findMany()
    * ```
    */
  get savedSearch(): Prisma.SavedSearchDelegate<ExtArgs>;

  /**
   * `prisma.oTP`: Exposes CRUD operations for the **OTP** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OTPS
    * const oTPS = await prisma.oTP.findMany()
    * ```
    */
  get oTP(): Prisma.OTPDelegate<ExtArgs>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<ExtArgs>;

  /**
   * `prisma.shortlist`: Exposes CRUD operations for the **Shortlist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shortlists
    * const shortlists = await prisma.shortlist.findMany()
    * ```
    */
  get shortlist(): Prisma.ShortlistDelegate<ExtArgs>;

  /**
   * `prisma.blockedUser`: Exposes CRUD operations for the **BlockedUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlockedUsers
    * const blockedUsers = await prisma.blockedUser.findMany()
    * ```
    */
  get blockedUser(): Prisma.BlockedUserDelegate<ExtArgs>;

  /**
   * `prisma.horoscope`: Exposes CRUD operations for the **Horoscope** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Horoscopes
    * const horoscopes = await prisma.horoscope.findMany()
    * ```
    */
  get horoscope(): Prisma.HoroscopeDelegate<ExtArgs>;

  /**
   * `prisma.horoscopeMatch`: Exposes CRUD operations for the **HoroscopeMatch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HoroscopeMatches
    * const horoscopeMatches = await prisma.horoscopeMatch.findMany()
    * ```
    */
  get horoscopeMatch(): Prisma.HoroscopeMatchDelegate<ExtArgs>;

  /**
   * `prisma.successStory`: Exposes CRUD operations for the **SuccessStory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SuccessStories
    * const successStories = await prisma.successStory.findMany()
    * ```
    */
  get successStory(): Prisma.SuccessStoryDelegate<ExtArgs>;

  /**
   * `prisma.familyMember`: Exposes CRUD operations for the **FamilyMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FamilyMembers
    * const familyMembers = await prisma.familyMember.findMany()
    * ```
    */
  get familyMember(): Prisma.FamilyMemberDelegate<ExtArgs>;

  /**
   * `prisma.referral`: Exposes CRUD operations for the **Referral** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Referrals
    * const referrals = await prisma.referral.findMany()
    * ```
    */
  get referral(): Prisma.ReferralDelegate<ExtArgs>;

  /**
   * `prisma.achievement`: Exposes CRUD operations for the **Achievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Achievements
    * const achievements = await prisma.achievement.findMany()
    * ```
    */
  get achievement(): Prisma.AchievementDelegate<ExtArgs>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs>;

  /**
   * `prisma.videoCall`: Exposes CRUD operations for the **VideoCall** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VideoCalls
    * const videoCalls = await prisma.videoCall.findMany()
    * ```
    */
  get videoCall(): Prisma.VideoCallDelegate<ExtArgs>;

  /**
   * `prisma.profileComparison`: Exposes CRUD operations for the **ProfileComparison** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProfileComparisons
    * const profileComparisons = await prisma.profileComparison.findMany()
    * ```
    */
  get profileComparison(): Prisma.ProfileComparisonDelegate<ExtArgs>;

  /**
   * `prisma.forumPost`: Exposes CRUD operations for the **ForumPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ForumPosts
    * const forumPosts = await prisma.forumPost.findMany()
    * ```
    */
  get forumPost(): Prisma.ForumPostDelegate<ExtArgs>;

  /**
   * `prisma.forumComment`: Exposes CRUD operations for the **ForumComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ForumComments
    * const forumComments = await prisma.forumComment.findMany()
    * ```
    */
  get forumComment(): Prisma.ForumCommentDelegate<ExtArgs>;

  /**
   * `prisma.communityGroup`: Exposes CRUD operations for the **CommunityGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunityGroups
    * const communityGroups = await prisma.communityGroup.findMany()
    * ```
    */
  get communityGroup(): Prisma.CommunityGroupDelegate<ExtArgs>;

  /**
   * `prisma.groupMember`: Exposes CRUD operations for the **GroupMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupMembers
    * const groupMembers = await prisma.groupMember.findMany()
    * ```
    */
  get groupMember(): Prisma.GroupMemberDelegate<ExtArgs>;

  /**
   * `prisma.communityEvent`: Exposes CRUD operations for the **CommunityEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunityEvents
    * const communityEvents = await prisma.communityEvent.findMany()
    * ```
    */
  get communityEvent(): Prisma.CommunityEventDelegate<ExtArgs>;

  /**
   * `prisma.eventParticipant`: Exposes CRUD operations for the **EventParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventParticipants
    * const eventParticipants = await prisma.eventParticipant.findMany()
    * ```
    */
  get eventParticipant(): Prisma.EventParticipantDelegate<ExtArgs>;

  /**
   * `prisma.blogPost`: Exposes CRUD operations for the **BlogPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlogPosts
    * const blogPosts = await prisma.blogPost.findMany()
    * ```
    */
  get blogPost(): Prisma.BlogPostDelegate<ExtArgs>;

  /**
   * `prisma.matchScore`: Exposes CRUD operations for the **MatchScore** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MatchScores
    * const matchScores = await prisma.matchScore.findMany()
    * ```
    */
  get matchScore(): Prisma.MatchScoreDelegate<ExtArgs>;

  /**
   * `prisma.searchHistory`: Exposes CRUD operations for the **SearchHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SearchHistories
    * const searchHistories = await prisma.searchHistory.findMany()
    * ```
    */
  get searchHistory(): Prisma.SearchHistoryDelegate<ExtArgs>;

  /**
   * `prisma.messageTemplate`: Exposes CRUD operations for the **MessageTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageTemplates
    * const messageTemplates = await prisma.messageTemplate.findMany()
    * ```
    */
  get messageTemplate(): Prisma.MessageTemplateDelegate<ExtArgs>;

  /**
   * `prisma.iceBreaker`: Exposes CRUD operations for the **IceBreaker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IceBreakers
    * const iceBreakers = await prisma.iceBreaker.findMany()
    * ```
    */
  get iceBreaker(): Prisma.IceBreakerDelegate<ExtArgs>;

  /**
   * `prisma.testimonial`: Exposes CRUD operations for the **Testimonial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Testimonials
    * const testimonials = await prisma.testimonial.findMany()
    * ```
    */
  get testimonial(): Prisma.TestimonialDelegate<ExtArgs>;

  /**
   * `prisma.activity`: Exposes CRUD operations for the **Activity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activities
    * const activities = await prisma.activity.findMany()
    * ```
    */
  get activity(): Prisma.ActivityDelegate<ExtArgs>;

  /**
   * `prisma.leaderboard`: Exposes CRUD operations for the **Leaderboard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leaderboards
    * const leaderboards = await prisma.leaderboard.findMany()
    * ```
    */
  get leaderboard(): Prisma.LeaderboardDelegate<ExtArgs>;

  /**
   * `prisma.wishlist`: Exposes CRUD operations for the **Wishlist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wishlists
    * const wishlists = await prisma.wishlist.findMany()
    * ```
    */
  get wishlist(): Prisma.WishlistDelegate<ExtArgs>;

  /**
   * `prisma.profileExport`: Exposes CRUD operations for the **ProfileExport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProfileExports
    * const profileExports = await prisma.profileExport.findMany()
    * ```
    */
  get profileExport(): Prisma.ProfileExportDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Session: 'Session',
    Profile: 'Profile',
    Photo: 'Photo',
    Verification: 'Verification',
    Interest: 'Interest',
    Chat: 'Chat',
    Message: 'Message',
    ProfileView: 'ProfileView',
    ContactView: 'ContactView',
    Subscription: 'Subscription',
    Payment: 'Payment',
    AddOn: 'AddOn',
    Service: 'Service',
    ServiceProvider: 'ServiceProvider',
    ServiceBooking: 'ServiceBooking',
    Notification: 'Notification',
    SavedSearch: 'SavedSearch',
    OTP: 'OTP',
    Admin: 'Admin',
    Report: 'Report',
    Shortlist: 'Shortlist',
    BlockedUser: 'BlockedUser',
    Horoscope: 'Horoscope',
    HoroscopeMatch: 'HoroscopeMatch',
    SuccessStory: 'SuccessStory',
    FamilyMember: 'FamilyMember',
    Referral: 'Referral',
    Achievement: 'Achievement',
    Document: 'Document',
    VideoCall: 'VideoCall',
    ProfileComparison: 'ProfileComparison',
    ForumPost: 'ForumPost',
    ForumComment: 'ForumComment',
    CommunityGroup: 'CommunityGroup',
    GroupMember: 'GroupMember',
    CommunityEvent: 'CommunityEvent',
    EventParticipant: 'EventParticipant',
    BlogPost: 'BlogPost',
    MatchScore: 'MatchScore',
    SearchHistory: 'SearchHistory',
    MessageTemplate: 'MessageTemplate',
    IceBreaker: 'IceBreaker',
    Testimonial: 'Testimonial',
    Activity: 'Activity',
    Leaderboard: 'Leaderboard',
    Wishlist: 'Wishlist',
    ProfileExport: 'ProfileExport'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "session" | "profile" | "photo" | "verification" | "interest" | "chat" | "message" | "profileView" | "contactView" | "subscription" | "payment" | "addOn" | "service" | "serviceProvider" | "serviceBooking" | "notification" | "savedSearch" | "oTP" | "admin" | "report" | "shortlist" | "blockedUser" | "horoscope" | "horoscopeMatch" | "successStory" | "familyMember" | "referral" | "achievement" | "document" | "videoCall" | "profileComparison" | "forumPost" | "forumComment" | "communityGroup" | "groupMember" | "communityEvent" | "eventParticipant" | "blogPost" | "matchScore" | "searchHistory" | "messageTemplate" | "iceBreaker" | "testimonial" | "activity" | "leaderboard" | "wishlist" | "profileExport"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Profile: {
        payload: Prisma.$ProfilePayload<ExtArgs>
        fields: Prisma.ProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findFirst: {
            args: Prisma.ProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findMany: {
            args: Prisma.ProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          create: {
            args: Prisma.ProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          createMany: {
            args: Prisma.ProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          delete: {
            args: Prisma.ProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          update: {
            args: Prisma.ProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          deleteMany: {
            args: Prisma.ProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.ProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      Photo: {
        payload: Prisma.$PhotoPayload<ExtArgs>
        fields: Prisma.PhotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PhotoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PhotoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>
          }
          findFirst: {
            args: Prisma.PhotoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PhotoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>
          }
          findMany: {
            args: Prisma.PhotoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>[]
          }
          create: {
            args: Prisma.PhotoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>
          }
          createMany: {
            args: Prisma.PhotoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PhotoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>[]
          }
          delete: {
            args: Prisma.PhotoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>
          }
          update: {
            args: Prisma.PhotoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>
          }
          deleteMany: {
            args: Prisma.PhotoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PhotoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PhotoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>
          }
          aggregate: {
            args: Prisma.PhotoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhoto>
          }
          groupBy: {
            args: Prisma.PhotoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PhotoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PhotoCountArgs<ExtArgs>
            result: $Utils.Optional<PhotoCountAggregateOutputType> | number
          }
        }
      }
      Verification: {
        payload: Prisma.$VerificationPayload<ExtArgs>
        fields: Prisma.VerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findFirst: {
            args: Prisma.VerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findMany: {
            args: Prisma.VerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          create: {
            args: Prisma.VerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          createMany: {
            args: Prisma.VerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          delete: {
            args: Prisma.VerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          update: {
            args: Prisma.VerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          deleteMany: {
            args: Prisma.VerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification>
          }
          groupBy: {
            args: Prisma.VerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCountAggregateOutputType> | number
          }
        }
      }
      Interest: {
        payload: Prisma.$InterestPayload<ExtArgs>
        fields: Prisma.InterestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InterestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InterestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>
          }
          findFirst: {
            args: Prisma.InterestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InterestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>
          }
          findMany: {
            args: Prisma.InterestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>[]
          }
          create: {
            args: Prisma.InterestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>
          }
          createMany: {
            args: Prisma.InterestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InterestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>[]
          }
          delete: {
            args: Prisma.InterestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>
          }
          update: {
            args: Prisma.InterestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>
          }
          deleteMany: {
            args: Prisma.InterestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InterestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InterestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>
          }
          aggregate: {
            args: Prisma.InterestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInterest>
          }
          groupBy: {
            args: Prisma.InterestGroupByArgs<ExtArgs>
            result: $Utils.Optional<InterestGroupByOutputType>[]
          }
          count: {
            args: Prisma.InterestCountArgs<ExtArgs>
            result: $Utils.Optional<InterestCountAggregateOutputType> | number
          }
        }
      }
      Chat: {
        payload: Prisma.$ChatPayload<ExtArgs>
        fields: Prisma.ChatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          findFirst: {
            args: Prisma.ChatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          findMany: {
            args: Prisma.ChatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          create: {
            args: Prisma.ChatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          createMany: {
            args: Prisma.ChatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          delete: {
            args: Prisma.ChatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          update: {
            args: Prisma.ChatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          deleteMany: {
            args: Prisma.ChatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          aggregate: {
            args: Prisma.ChatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChat>
          }
          groupBy: {
            args: Prisma.ChatGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatCountArgs<ExtArgs>
            result: $Utils.Optional<ChatCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      ProfileView: {
        payload: Prisma.$ProfileViewPayload<ExtArgs>
        fields: Prisma.ProfileViewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileViewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileViewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileViewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileViewPayload>
          }
          findFirst: {
            args: Prisma.ProfileViewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileViewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileViewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileViewPayload>
          }
          findMany: {
            args: Prisma.ProfileViewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileViewPayload>[]
          }
          create: {
            args: Prisma.ProfileViewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileViewPayload>
          }
          createMany: {
            args: Prisma.ProfileViewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileViewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileViewPayload>[]
          }
          delete: {
            args: Prisma.ProfileViewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileViewPayload>
          }
          update: {
            args: Prisma.ProfileViewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileViewPayload>
          }
          deleteMany: {
            args: Prisma.ProfileViewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileViewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfileViewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileViewPayload>
          }
          aggregate: {
            args: Prisma.ProfileViewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfileView>
          }
          groupBy: {
            args: Prisma.ProfileViewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileViewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileViewCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileViewCountAggregateOutputType> | number
          }
        }
      }
      ContactView: {
        payload: Prisma.$ContactViewPayload<ExtArgs>
        fields: Prisma.ContactViewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactViewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactViewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactViewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactViewPayload>
          }
          findFirst: {
            args: Prisma.ContactViewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactViewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactViewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactViewPayload>
          }
          findMany: {
            args: Prisma.ContactViewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactViewPayload>[]
          }
          create: {
            args: Prisma.ContactViewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactViewPayload>
          }
          createMany: {
            args: Prisma.ContactViewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactViewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactViewPayload>[]
          }
          delete: {
            args: Prisma.ContactViewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactViewPayload>
          }
          update: {
            args: Prisma.ContactViewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactViewPayload>
          }
          deleteMany: {
            args: Prisma.ContactViewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactViewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContactViewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactViewPayload>
          }
          aggregate: {
            args: Prisma.ContactViewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactView>
          }
          groupBy: {
            args: Prisma.ContactViewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactViewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactViewCountArgs<ExtArgs>
            result: $Utils.Optional<ContactViewCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      AddOn: {
        payload: Prisma.$AddOnPayload<ExtArgs>
        fields: Prisma.AddOnFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddOnFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddOnFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnPayload>
          }
          findFirst: {
            args: Prisma.AddOnFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddOnFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnPayload>
          }
          findMany: {
            args: Prisma.AddOnFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnPayload>[]
          }
          create: {
            args: Prisma.AddOnCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnPayload>
          }
          createMany: {
            args: Prisma.AddOnCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AddOnCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnPayload>[]
          }
          delete: {
            args: Prisma.AddOnDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnPayload>
          }
          update: {
            args: Prisma.AddOnUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnPayload>
          }
          deleteMany: {
            args: Prisma.AddOnDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddOnUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AddOnUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnPayload>
          }
          aggregate: {
            args: Prisma.AddOnAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddOn>
          }
          groupBy: {
            args: Prisma.AddOnGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddOnGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddOnCountArgs<ExtArgs>
            result: $Utils.Optional<AddOnCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      ServiceProvider: {
        payload: Prisma.$ServiceProviderPayload<ExtArgs>
        fields: Prisma.ServiceProviderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceProviderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceProviderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderPayload>
          }
          findFirst: {
            args: Prisma.ServiceProviderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceProviderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderPayload>
          }
          findMany: {
            args: Prisma.ServiceProviderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderPayload>[]
          }
          create: {
            args: Prisma.ServiceProviderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderPayload>
          }
          createMany: {
            args: Prisma.ServiceProviderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceProviderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderPayload>[]
          }
          delete: {
            args: Prisma.ServiceProviderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderPayload>
          }
          update: {
            args: Prisma.ServiceProviderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderPayload>
          }
          deleteMany: {
            args: Prisma.ServiceProviderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceProviderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceProviderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderPayload>
          }
          aggregate: {
            args: Prisma.ServiceProviderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceProvider>
          }
          groupBy: {
            args: Prisma.ServiceProviderGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceProviderGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceProviderCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceProviderCountAggregateOutputType> | number
          }
        }
      }
      ServiceBooking: {
        payload: Prisma.$ServiceBookingPayload<ExtArgs>
        fields: Prisma.ServiceBookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceBookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceBookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBookingPayload>
          }
          findFirst: {
            args: Prisma.ServiceBookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceBookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBookingPayload>
          }
          findMany: {
            args: Prisma.ServiceBookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBookingPayload>[]
          }
          create: {
            args: Prisma.ServiceBookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBookingPayload>
          }
          createMany: {
            args: Prisma.ServiceBookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceBookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBookingPayload>[]
          }
          delete: {
            args: Prisma.ServiceBookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBookingPayload>
          }
          update: {
            args: Prisma.ServiceBookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBookingPayload>
          }
          deleteMany: {
            args: Prisma.ServiceBookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceBookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceBookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBookingPayload>
          }
          aggregate: {
            args: Prisma.ServiceBookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceBooking>
          }
          groupBy: {
            args: Prisma.ServiceBookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceBookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceBookingCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceBookingCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      SavedSearch: {
        payload: Prisma.$SavedSearchPayload<ExtArgs>
        fields: Prisma.SavedSearchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SavedSearchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedSearchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SavedSearchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedSearchPayload>
          }
          findFirst: {
            args: Prisma.SavedSearchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedSearchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SavedSearchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedSearchPayload>
          }
          findMany: {
            args: Prisma.SavedSearchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedSearchPayload>[]
          }
          create: {
            args: Prisma.SavedSearchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedSearchPayload>
          }
          createMany: {
            args: Prisma.SavedSearchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SavedSearchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedSearchPayload>[]
          }
          delete: {
            args: Prisma.SavedSearchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedSearchPayload>
          }
          update: {
            args: Prisma.SavedSearchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedSearchPayload>
          }
          deleteMany: {
            args: Prisma.SavedSearchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SavedSearchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SavedSearchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedSearchPayload>
          }
          aggregate: {
            args: Prisma.SavedSearchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSavedSearch>
          }
          groupBy: {
            args: Prisma.SavedSearchGroupByArgs<ExtArgs>
            result: $Utils.Optional<SavedSearchGroupByOutputType>[]
          }
          count: {
            args: Prisma.SavedSearchCountArgs<ExtArgs>
            result: $Utils.Optional<SavedSearchCountAggregateOutputType> | number
          }
        }
      }
      OTP: {
        payload: Prisma.$OTPPayload<ExtArgs>
        fields: Prisma.OTPFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OTPFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OTPFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>
          }
          findFirst: {
            args: Prisma.OTPFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OTPFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>
          }
          findMany: {
            args: Prisma.OTPFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>[]
          }
          create: {
            args: Prisma.OTPCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>
          }
          createMany: {
            args: Prisma.OTPCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OTPCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>[]
          }
          delete: {
            args: Prisma.OTPDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>
          }
          update: {
            args: Prisma.OTPUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>
          }
          deleteMany: {
            args: Prisma.OTPDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OTPUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OTPUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>
          }
          aggregate: {
            args: Prisma.OTPAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOTP>
          }
          groupBy: {
            args: Prisma.OTPGroupByArgs<ExtArgs>
            result: $Utils.Optional<OTPGroupByOutputType>[]
          }
          count: {
            args: Prisma.OTPCountArgs<ExtArgs>
            result: $Utils.Optional<OTPCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>
        fields: Prisma.ReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      Shortlist: {
        payload: Prisma.$ShortlistPayload<ExtArgs>
        fields: Prisma.ShortlistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShortlistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShortlistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShortlistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShortlistPayload>
          }
          findFirst: {
            args: Prisma.ShortlistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShortlistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShortlistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShortlistPayload>
          }
          findMany: {
            args: Prisma.ShortlistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShortlistPayload>[]
          }
          create: {
            args: Prisma.ShortlistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShortlistPayload>
          }
          createMany: {
            args: Prisma.ShortlistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShortlistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShortlistPayload>[]
          }
          delete: {
            args: Prisma.ShortlistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShortlistPayload>
          }
          update: {
            args: Prisma.ShortlistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShortlistPayload>
          }
          deleteMany: {
            args: Prisma.ShortlistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShortlistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShortlistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShortlistPayload>
          }
          aggregate: {
            args: Prisma.ShortlistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShortlist>
          }
          groupBy: {
            args: Prisma.ShortlistGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShortlistGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShortlistCountArgs<ExtArgs>
            result: $Utils.Optional<ShortlistCountAggregateOutputType> | number
          }
        }
      }
      BlockedUser: {
        payload: Prisma.$BlockedUserPayload<ExtArgs>
        fields: Prisma.BlockedUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlockedUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlockedUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>
          }
          findFirst: {
            args: Prisma.BlockedUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlockedUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>
          }
          findMany: {
            args: Prisma.BlockedUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>[]
          }
          create: {
            args: Prisma.BlockedUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>
          }
          createMany: {
            args: Prisma.BlockedUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlockedUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>[]
          }
          delete: {
            args: Prisma.BlockedUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>
          }
          update: {
            args: Prisma.BlockedUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>
          }
          deleteMany: {
            args: Prisma.BlockedUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlockedUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BlockedUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>
          }
          aggregate: {
            args: Prisma.BlockedUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlockedUser>
          }
          groupBy: {
            args: Prisma.BlockedUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlockedUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlockedUserCountArgs<ExtArgs>
            result: $Utils.Optional<BlockedUserCountAggregateOutputType> | number
          }
        }
      }
      Horoscope: {
        payload: Prisma.$HoroscopePayload<ExtArgs>
        fields: Prisma.HoroscopeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HoroscopeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoroscopePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HoroscopeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoroscopePayload>
          }
          findFirst: {
            args: Prisma.HoroscopeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoroscopePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HoroscopeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoroscopePayload>
          }
          findMany: {
            args: Prisma.HoroscopeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoroscopePayload>[]
          }
          create: {
            args: Prisma.HoroscopeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoroscopePayload>
          }
          createMany: {
            args: Prisma.HoroscopeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HoroscopeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoroscopePayload>[]
          }
          delete: {
            args: Prisma.HoroscopeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoroscopePayload>
          }
          update: {
            args: Prisma.HoroscopeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoroscopePayload>
          }
          deleteMany: {
            args: Prisma.HoroscopeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HoroscopeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HoroscopeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoroscopePayload>
          }
          aggregate: {
            args: Prisma.HoroscopeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHoroscope>
          }
          groupBy: {
            args: Prisma.HoroscopeGroupByArgs<ExtArgs>
            result: $Utils.Optional<HoroscopeGroupByOutputType>[]
          }
          count: {
            args: Prisma.HoroscopeCountArgs<ExtArgs>
            result: $Utils.Optional<HoroscopeCountAggregateOutputType> | number
          }
        }
      }
      HoroscopeMatch: {
        payload: Prisma.$HoroscopeMatchPayload<ExtArgs>
        fields: Prisma.HoroscopeMatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HoroscopeMatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoroscopeMatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HoroscopeMatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoroscopeMatchPayload>
          }
          findFirst: {
            args: Prisma.HoroscopeMatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoroscopeMatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HoroscopeMatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoroscopeMatchPayload>
          }
          findMany: {
            args: Prisma.HoroscopeMatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoroscopeMatchPayload>[]
          }
          create: {
            args: Prisma.HoroscopeMatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoroscopeMatchPayload>
          }
          createMany: {
            args: Prisma.HoroscopeMatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HoroscopeMatchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoroscopeMatchPayload>[]
          }
          delete: {
            args: Prisma.HoroscopeMatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoroscopeMatchPayload>
          }
          update: {
            args: Prisma.HoroscopeMatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoroscopeMatchPayload>
          }
          deleteMany: {
            args: Prisma.HoroscopeMatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HoroscopeMatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HoroscopeMatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoroscopeMatchPayload>
          }
          aggregate: {
            args: Prisma.HoroscopeMatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHoroscopeMatch>
          }
          groupBy: {
            args: Prisma.HoroscopeMatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<HoroscopeMatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.HoroscopeMatchCountArgs<ExtArgs>
            result: $Utils.Optional<HoroscopeMatchCountAggregateOutputType> | number
          }
        }
      }
      SuccessStory: {
        payload: Prisma.$SuccessStoryPayload<ExtArgs>
        fields: Prisma.SuccessStoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SuccessStoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuccessStoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SuccessStoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuccessStoryPayload>
          }
          findFirst: {
            args: Prisma.SuccessStoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuccessStoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SuccessStoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuccessStoryPayload>
          }
          findMany: {
            args: Prisma.SuccessStoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuccessStoryPayload>[]
          }
          create: {
            args: Prisma.SuccessStoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuccessStoryPayload>
          }
          createMany: {
            args: Prisma.SuccessStoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SuccessStoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuccessStoryPayload>[]
          }
          delete: {
            args: Prisma.SuccessStoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuccessStoryPayload>
          }
          update: {
            args: Prisma.SuccessStoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuccessStoryPayload>
          }
          deleteMany: {
            args: Prisma.SuccessStoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SuccessStoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SuccessStoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuccessStoryPayload>
          }
          aggregate: {
            args: Prisma.SuccessStoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSuccessStory>
          }
          groupBy: {
            args: Prisma.SuccessStoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SuccessStoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SuccessStoryCountArgs<ExtArgs>
            result: $Utils.Optional<SuccessStoryCountAggregateOutputType> | number
          }
        }
      }
      FamilyMember: {
        payload: Prisma.$FamilyMemberPayload<ExtArgs>
        fields: Prisma.FamilyMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FamilyMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FamilyMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPayload>
          }
          findFirst: {
            args: Prisma.FamilyMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FamilyMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPayload>
          }
          findMany: {
            args: Prisma.FamilyMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPayload>[]
          }
          create: {
            args: Prisma.FamilyMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPayload>
          }
          createMany: {
            args: Prisma.FamilyMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FamilyMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPayload>[]
          }
          delete: {
            args: Prisma.FamilyMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPayload>
          }
          update: {
            args: Prisma.FamilyMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPayload>
          }
          deleteMany: {
            args: Prisma.FamilyMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FamilyMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FamilyMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPayload>
          }
          aggregate: {
            args: Prisma.FamilyMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFamilyMember>
          }
          groupBy: {
            args: Prisma.FamilyMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<FamilyMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.FamilyMemberCountArgs<ExtArgs>
            result: $Utils.Optional<FamilyMemberCountAggregateOutputType> | number
          }
        }
      }
      Referral: {
        payload: Prisma.$ReferralPayload<ExtArgs>
        fields: Prisma.ReferralFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferralFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferralFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          findFirst: {
            args: Prisma.ReferralFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferralFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          findMany: {
            args: Prisma.ReferralFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          create: {
            args: Prisma.ReferralCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          createMany: {
            args: Prisma.ReferralCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReferralCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          delete: {
            args: Prisma.ReferralDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          update: {
            args: Prisma.ReferralUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          deleteMany: {
            args: Prisma.ReferralDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferralUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReferralUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          aggregate: {
            args: Prisma.ReferralAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferral>
          }
          groupBy: {
            args: Prisma.ReferralGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferralGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReferralCountArgs<ExtArgs>
            result: $Utils.Optional<ReferralCountAggregateOutputType> | number
          }
        }
      }
      Achievement: {
        payload: Prisma.$AchievementPayload<ExtArgs>
        fields: Prisma.AchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findFirst: {
            args: Prisma.AchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findMany: {
            args: Prisma.AchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          create: {
            args: Prisma.AchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          createMany: {
            args: Prisma.AchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          delete: {
            args: Prisma.AchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          update: {
            args: Prisma.AchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          deleteMany: {
            args: Prisma.AchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          aggregate: {
            args: Prisma.AchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAchievement>
          }
          groupBy: {
            args: Prisma.AchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AchievementCountArgs<ExtArgs>
            result: $Utils.Optional<AchievementCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      VideoCall: {
        payload: Prisma.$VideoCallPayload<ExtArgs>
        fields: Prisma.VideoCallFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VideoCallFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoCallPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VideoCallFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoCallPayload>
          }
          findFirst: {
            args: Prisma.VideoCallFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoCallPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VideoCallFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoCallPayload>
          }
          findMany: {
            args: Prisma.VideoCallFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoCallPayload>[]
          }
          create: {
            args: Prisma.VideoCallCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoCallPayload>
          }
          createMany: {
            args: Prisma.VideoCallCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VideoCallCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoCallPayload>[]
          }
          delete: {
            args: Prisma.VideoCallDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoCallPayload>
          }
          update: {
            args: Prisma.VideoCallUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoCallPayload>
          }
          deleteMany: {
            args: Prisma.VideoCallDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VideoCallUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VideoCallUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoCallPayload>
          }
          aggregate: {
            args: Prisma.VideoCallAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideoCall>
          }
          groupBy: {
            args: Prisma.VideoCallGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideoCallGroupByOutputType>[]
          }
          count: {
            args: Prisma.VideoCallCountArgs<ExtArgs>
            result: $Utils.Optional<VideoCallCountAggregateOutputType> | number
          }
        }
      }
      ProfileComparison: {
        payload: Prisma.$ProfileComparisonPayload<ExtArgs>
        fields: Prisma.ProfileComparisonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileComparisonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileComparisonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileComparisonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileComparisonPayload>
          }
          findFirst: {
            args: Prisma.ProfileComparisonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileComparisonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileComparisonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileComparisonPayload>
          }
          findMany: {
            args: Prisma.ProfileComparisonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileComparisonPayload>[]
          }
          create: {
            args: Prisma.ProfileComparisonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileComparisonPayload>
          }
          createMany: {
            args: Prisma.ProfileComparisonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileComparisonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileComparisonPayload>[]
          }
          delete: {
            args: Prisma.ProfileComparisonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileComparisonPayload>
          }
          update: {
            args: Prisma.ProfileComparisonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileComparisonPayload>
          }
          deleteMany: {
            args: Prisma.ProfileComparisonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileComparisonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfileComparisonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileComparisonPayload>
          }
          aggregate: {
            args: Prisma.ProfileComparisonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfileComparison>
          }
          groupBy: {
            args: Prisma.ProfileComparisonGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileComparisonGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileComparisonCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileComparisonCountAggregateOutputType> | number
          }
        }
      }
      ForumPost: {
        payload: Prisma.$ForumPostPayload<ExtArgs>
        fields: Prisma.ForumPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ForumPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ForumPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>
          }
          findFirst: {
            args: Prisma.ForumPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ForumPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>
          }
          findMany: {
            args: Prisma.ForumPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>[]
          }
          create: {
            args: Prisma.ForumPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>
          }
          createMany: {
            args: Prisma.ForumPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ForumPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>[]
          }
          delete: {
            args: Prisma.ForumPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>
          }
          update: {
            args: Prisma.ForumPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>
          }
          deleteMany: {
            args: Prisma.ForumPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ForumPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ForumPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>
          }
          aggregate: {
            args: Prisma.ForumPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateForumPost>
          }
          groupBy: {
            args: Prisma.ForumPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<ForumPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.ForumPostCountArgs<ExtArgs>
            result: $Utils.Optional<ForumPostCountAggregateOutputType> | number
          }
        }
      }
      ForumComment: {
        payload: Prisma.$ForumCommentPayload<ExtArgs>
        fields: Prisma.ForumCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ForumCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ForumCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentPayload>
          }
          findFirst: {
            args: Prisma.ForumCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ForumCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentPayload>
          }
          findMany: {
            args: Prisma.ForumCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentPayload>[]
          }
          create: {
            args: Prisma.ForumCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentPayload>
          }
          createMany: {
            args: Prisma.ForumCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ForumCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentPayload>[]
          }
          delete: {
            args: Prisma.ForumCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentPayload>
          }
          update: {
            args: Prisma.ForumCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentPayload>
          }
          deleteMany: {
            args: Prisma.ForumCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ForumCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ForumCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentPayload>
          }
          aggregate: {
            args: Prisma.ForumCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateForumComment>
          }
          groupBy: {
            args: Prisma.ForumCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ForumCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ForumCommentCountArgs<ExtArgs>
            result: $Utils.Optional<ForumCommentCountAggregateOutputType> | number
          }
        }
      }
      CommunityGroup: {
        payload: Prisma.$CommunityGroupPayload<ExtArgs>
        fields: Prisma.CommunityGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommunityGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommunityGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityGroupPayload>
          }
          findFirst: {
            args: Prisma.CommunityGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommunityGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityGroupPayload>
          }
          findMany: {
            args: Prisma.CommunityGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityGroupPayload>[]
          }
          create: {
            args: Prisma.CommunityGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityGroupPayload>
          }
          createMany: {
            args: Prisma.CommunityGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommunityGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityGroupPayload>[]
          }
          delete: {
            args: Prisma.CommunityGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityGroupPayload>
          }
          update: {
            args: Prisma.CommunityGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityGroupPayload>
          }
          deleteMany: {
            args: Prisma.CommunityGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommunityGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommunityGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityGroupPayload>
          }
          aggregate: {
            args: Prisma.CommunityGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommunityGroup>
          }
          groupBy: {
            args: Prisma.CommunityGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommunityGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommunityGroupCountArgs<ExtArgs>
            result: $Utils.Optional<CommunityGroupCountAggregateOutputType> | number
          }
        }
      }
      GroupMember: {
        payload: Prisma.$GroupMemberPayload<ExtArgs>
        fields: Prisma.GroupMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          findFirst: {
            args: Prisma.GroupMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          findMany: {
            args: Prisma.GroupMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>[]
          }
          create: {
            args: Prisma.GroupMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          createMany: {
            args: Prisma.GroupMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>[]
          }
          delete: {
            args: Prisma.GroupMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          update: {
            args: Prisma.GroupMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          deleteMany: {
            args: Prisma.GroupMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GroupMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          aggregate: {
            args: Prisma.GroupMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroupMember>
          }
          groupBy: {
            args: Prisma.GroupMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupMemberCountArgs<ExtArgs>
            result: $Utils.Optional<GroupMemberCountAggregateOutputType> | number
          }
        }
      }
      CommunityEvent: {
        payload: Prisma.$CommunityEventPayload<ExtArgs>
        fields: Prisma.CommunityEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommunityEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommunityEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityEventPayload>
          }
          findFirst: {
            args: Prisma.CommunityEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommunityEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityEventPayload>
          }
          findMany: {
            args: Prisma.CommunityEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityEventPayload>[]
          }
          create: {
            args: Prisma.CommunityEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityEventPayload>
          }
          createMany: {
            args: Prisma.CommunityEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommunityEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityEventPayload>[]
          }
          delete: {
            args: Prisma.CommunityEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityEventPayload>
          }
          update: {
            args: Prisma.CommunityEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityEventPayload>
          }
          deleteMany: {
            args: Prisma.CommunityEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommunityEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommunityEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityEventPayload>
          }
          aggregate: {
            args: Prisma.CommunityEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommunityEvent>
          }
          groupBy: {
            args: Prisma.CommunityEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommunityEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommunityEventCountArgs<ExtArgs>
            result: $Utils.Optional<CommunityEventCountAggregateOutputType> | number
          }
        }
      }
      EventParticipant: {
        payload: Prisma.$EventParticipantPayload<ExtArgs>
        fields: Prisma.EventParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventParticipantPayload>
          }
          findFirst: {
            args: Prisma.EventParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventParticipantPayload>
          }
          findMany: {
            args: Prisma.EventParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventParticipantPayload>[]
          }
          create: {
            args: Prisma.EventParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventParticipantPayload>
          }
          createMany: {
            args: Prisma.EventParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventParticipantPayload>[]
          }
          delete: {
            args: Prisma.EventParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventParticipantPayload>
          }
          update: {
            args: Prisma.EventParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventParticipantPayload>
          }
          deleteMany: {
            args: Prisma.EventParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventParticipantPayload>
          }
          aggregate: {
            args: Prisma.EventParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventParticipant>
          }
          groupBy: {
            args: Prisma.EventParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<EventParticipantCountAggregateOutputType> | number
          }
        }
      }
      BlogPost: {
        payload: Prisma.$BlogPostPayload<ExtArgs>
        fields: Prisma.BlogPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          findFirst: {
            args: Prisma.BlogPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          findMany: {
            args: Prisma.BlogPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
          }
          create: {
            args: Prisma.BlogPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          createMany: {
            args: Prisma.BlogPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlogPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
          }
          delete: {
            args: Prisma.BlogPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          update: {
            args: Prisma.BlogPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          deleteMany: {
            args: Prisma.BlogPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BlogPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          aggregate: {
            args: Prisma.BlogPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlogPost>
          }
          groupBy: {
            args: Prisma.BlogPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogPostCountArgs<ExtArgs>
            result: $Utils.Optional<BlogPostCountAggregateOutputType> | number
          }
        }
      }
      MatchScore: {
        payload: Prisma.$MatchScorePayload<ExtArgs>
        fields: Prisma.MatchScoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatchScoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchScorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatchScoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchScorePayload>
          }
          findFirst: {
            args: Prisma.MatchScoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchScorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatchScoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchScorePayload>
          }
          findMany: {
            args: Prisma.MatchScoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchScorePayload>[]
          }
          create: {
            args: Prisma.MatchScoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchScorePayload>
          }
          createMany: {
            args: Prisma.MatchScoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MatchScoreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchScorePayload>[]
          }
          delete: {
            args: Prisma.MatchScoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchScorePayload>
          }
          update: {
            args: Prisma.MatchScoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchScorePayload>
          }
          deleteMany: {
            args: Prisma.MatchScoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatchScoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MatchScoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchScorePayload>
          }
          aggregate: {
            args: Prisma.MatchScoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatchScore>
          }
          groupBy: {
            args: Prisma.MatchScoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatchScoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatchScoreCountArgs<ExtArgs>
            result: $Utils.Optional<MatchScoreCountAggregateOutputType> | number
          }
        }
      }
      SearchHistory: {
        payload: Prisma.$SearchHistoryPayload<ExtArgs>
        fields: Prisma.SearchHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SearchHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SearchHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          findFirst: {
            args: Prisma.SearchHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SearchHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          findMany: {
            args: Prisma.SearchHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>[]
          }
          create: {
            args: Prisma.SearchHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          createMany: {
            args: Prisma.SearchHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SearchHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>[]
          }
          delete: {
            args: Prisma.SearchHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          update: {
            args: Prisma.SearchHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          deleteMany: {
            args: Prisma.SearchHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SearchHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SearchHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          aggregate: {
            args: Prisma.SearchHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSearchHistory>
          }
          groupBy: {
            args: Prisma.SearchHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SearchHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SearchHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<SearchHistoryCountAggregateOutputType> | number
          }
        }
      }
      MessageTemplate: {
        payload: Prisma.$MessageTemplatePayload<ExtArgs>
        fields: Prisma.MessageTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
          }
          findFirst: {
            args: Prisma.MessageTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
          }
          findMany: {
            args: Prisma.MessageTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>[]
          }
          create: {
            args: Prisma.MessageTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
          }
          createMany: {
            args: Prisma.MessageTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>[]
          }
          delete: {
            args: Prisma.MessageTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
          }
          update: {
            args: Prisma.MessageTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
          }
          deleteMany: {
            args: Prisma.MessageTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
          }
          aggregate: {
            args: Prisma.MessageTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageTemplate>
          }
          groupBy: {
            args: Prisma.MessageTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<MessageTemplateCountAggregateOutputType> | number
          }
        }
      }
      IceBreaker: {
        payload: Prisma.$IceBreakerPayload<ExtArgs>
        fields: Prisma.IceBreakerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IceBreakerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IceBreakerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IceBreakerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IceBreakerPayload>
          }
          findFirst: {
            args: Prisma.IceBreakerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IceBreakerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IceBreakerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IceBreakerPayload>
          }
          findMany: {
            args: Prisma.IceBreakerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IceBreakerPayload>[]
          }
          create: {
            args: Prisma.IceBreakerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IceBreakerPayload>
          }
          createMany: {
            args: Prisma.IceBreakerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IceBreakerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IceBreakerPayload>[]
          }
          delete: {
            args: Prisma.IceBreakerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IceBreakerPayload>
          }
          update: {
            args: Prisma.IceBreakerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IceBreakerPayload>
          }
          deleteMany: {
            args: Prisma.IceBreakerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IceBreakerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IceBreakerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IceBreakerPayload>
          }
          aggregate: {
            args: Prisma.IceBreakerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIceBreaker>
          }
          groupBy: {
            args: Prisma.IceBreakerGroupByArgs<ExtArgs>
            result: $Utils.Optional<IceBreakerGroupByOutputType>[]
          }
          count: {
            args: Prisma.IceBreakerCountArgs<ExtArgs>
            result: $Utils.Optional<IceBreakerCountAggregateOutputType> | number
          }
        }
      }
      Testimonial: {
        payload: Prisma.$TestimonialPayload<ExtArgs>
        fields: Prisma.TestimonialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestimonialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestimonialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          findFirst: {
            args: Prisma.TestimonialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestimonialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          findMany: {
            args: Prisma.TestimonialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>[]
          }
          create: {
            args: Prisma.TestimonialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          createMany: {
            args: Prisma.TestimonialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TestimonialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>[]
          }
          delete: {
            args: Prisma.TestimonialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          update: {
            args: Prisma.TestimonialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          deleteMany: {
            args: Prisma.TestimonialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestimonialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TestimonialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          aggregate: {
            args: Prisma.TestimonialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestimonial>
          }
          groupBy: {
            args: Prisma.TestimonialGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestimonialGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestimonialCountArgs<ExtArgs>
            result: $Utils.Optional<TestimonialCountAggregateOutputType> | number
          }
        }
      }
      Activity: {
        payload: Prisma.$ActivityPayload<ExtArgs>
        fields: Prisma.ActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findFirst: {
            args: Prisma.ActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findMany: {
            args: Prisma.ActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          create: {
            args: Prisma.ActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          createMany: {
            args: Prisma.ActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          delete: {
            args: Prisma.ActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          update: {
            args: Prisma.ActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          deleteMany: {
            args: Prisma.ActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          aggregate: {
            args: Prisma.ActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivity>
          }
          groupBy: {
            args: Prisma.ActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityCountAggregateOutputType> | number
          }
        }
      }
      Leaderboard: {
        payload: Prisma.$LeaderboardPayload<ExtArgs>
        fields: Prisma.LeaderboardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaderboardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaderboardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>
          }
          findFirst: {
            args: Prisma.LeaderboardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaderboardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>
          }
          findMany: {
            args: Prisma.LeaderboardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>[]
          }
          create: {
            args: Prisma.LeaderboardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>
          }
          createMany: {
            args: Prisma.LeaderboardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaderboardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>[]
          }
          delete: {
            args: Prisma.LeaderboardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>
          }
          update: {
            args: Prisma.LeaderboardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>
          }
          deleteMany: {
            args: Prisma.LeaderboardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaderboardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LeaderboardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>
          }
          aggregate: {
            args: Prisma.LeaderboardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeaderboard>
          }
          groupBy: {
            args: Prisma.LeaderboardGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaderboardGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaderboardCountArgs<ExtArgs>
            result: $Utils.Optional<LeaderboardCountAggregateOutputType> | number
          }
        }
      }
      Wishlist: {
        payload: Prisma.$WishlistPayload<ExtArgs>
        fields: Prisma.WishlistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WishlistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WishlistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>
          }
          findFirst: {
            args: Prisma.WishlistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WishlistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>
          }
          findMany: {
            args: Prisma.WishlistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>[]
          }
          create: {
            args: Prisma.WishlistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>
          }
          createMany: {
            args: Prisma.WishlistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WishlistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>[]
          }
          delete: {
            args: Prisma.WishlistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>
          }
          update: {
            args: Prisma.WishlistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>
          }
          deleteMany: {
            args: Prisma.WishlistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WishlistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WishlistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>
          }
          aggregate: {
            args: Prisma.WishlistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWishlist>
          }
          groupBy: {
            args: Prisma.WishlistGroupByArgs<ExtArgs>
            result: $Utils.Optional<WishlistGroupByOutputType>[]
          }
          count: {
            args: Prisma.WishlistCountArgs<ExtArgs>
            result: $Utils.Optional<WishlistCountAggregateOutputType> | number
          }
        }
      }
      ProfileExport: {
        payload: Prisma.$ProfileExportPayload<ExtArgs>
        fields: Prisma.ProfileExportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileExportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileExportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileExportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileExportPayload>
          }
          findFirst: {
            args: Prisma.ProfileExportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileExportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileExportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileExportPayload>
          }
          findMany: {
            args: Prisma.ProfileExportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileExportPayload>[]
          }
          create: {
            args: Prisma.ProfileExportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileExportPayload>
          }
          createMany: {
            args: Prisma.ProfileExportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileExportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileExportPayload>[]
          }
          delete: {
            args: Prisma.ProfileExportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileExportPayload>
          }
          update: {
            args: Prisma.ProfileExportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileExportPayload>
          }
          deleteMany: {
            args: Prisma.ProfileExportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileExportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfileExportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileExportPayload>
          }
          aggregate: {
            args: Prisma.ProfileExportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfileExport>
          }
          groupBy: {
            args: Prisma.ProfileExportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileExportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileExportCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileExportCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    interests: number
    receivedInterests: number
    chats: number
    chats2: number
    messages: number
    subscriptions: number
    payments: number
    profileViews: number
    sessions: number
    notifications: number
    shortlists: number
    blockedUsers: number
    blockedBy: number
    referrals: number
    referredByRef: number
    referredUsers: number
    achievements: number
    horoscopes: number
    familyMembers: number
    successStories: number
    documents: number
    videoCallsAsCaller: number
    videoCallsAsParticipant: number
    forumPosts: number
    forumComments: number
    groupMembers: number
    eventParticipants: number
    blogPosts: number
    matchScores: number
    matchedBy: number
    searchHistory: number
    messageTemplates: number
    iceBreakers: number
    activities: number
    leaderboard: number
    wishlists: number
    profileExports: number
    services: number
    serviceBookings: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interests?: boolean | UserCountOutputTypeCountInterestsArgs
    receivedInterests?: boolean | UserCountOutputTypeCountReceivedInterestsArgs
    chats?: boolean | UserCountOutputTypeCountChatsArgs
    chats2?: boolean | UserCountOutputTypeCountChats2Args
    messages?: boolean | UserCountOutputTypeCountMessagesArgs
    subscriptions?: boolean | UserCountOutputTypeCountSubscriptionsArgs
    payments?: boolean | UserCountOutputTypeCountPaymentsArgs
    profileViews?: boolean | UserCountOutputTypeCountProfileViewsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    shortlists?: boolean | UserCountOutputTypeCountShortlistsArgs
    blockedUsers?: boolean | UserCountOutputTypeCountBlockedUsersArgs
    blockedBy?: boolean | UserCountOutputTypeCountBlockedByArgs
    referrals?: boolean | UserCountOutputTypeCountReferralsArgs
    referredByRef?: boolean | UserCountOutputTypeCountReferredByRefArgs
    referredUsers?: boolean | UserCountOutputTypeCountReferredUsersArgs
    achievements?: boolean | UserCountOutputTypeCountAchievementsArgs
    horoscopes?: boolean | UserCountOutputTypeCountHoroscopesArgs
    familyMembers?: boolean | UserCountOutputTypeCountFamilyMembersArgs
    successStories?: boolean | UserCountOutputTypeCountSuccessStoriesArgs
    documents?: boolean | UserCountOutputTypeCountDocumentsArgs
    videoCallsAsCaller?: boolean | UserCountOutputTypeCountVideoCallsAsCallerArgs
    videoCallsAsParticipant?: boolean | UserCountOutputTypeCountVideoCallsAsParticipantArgs
    forumPosts?: boolean | UserCountOutputTypeCountForumPostsArgs
    forumComments?: boolean | UserCountOutputTypeCountForumCommentsArgs
    groupMembers?: boolean | UserCountOutputTypeCountGroupMembersArgs
    eventParticipants?: boolean | UserCountOutputTypeCountEventParticipantsArgs
    blogPosts?: boolean | UserCountOutputTypeCountBlogPostsArgs
    matchScores?: boolean | UserCountOutputTypeCountMatchScoresArgs
    matchedBy?: boolean | UserCountOutputTypeCountMatchedByArgs
    searchHistory?: boolean | UserCountOutputTypeCountSearchHistoryArgs
    messageTemplates?: boolean | UserCountOutputTypeCountMessageTemplatesArgs
    iceBreakers?: boolean | UserCountOutputTypeCountIceBreakersArgs
    activities?: boolean | UserCountOutputTypeCountActivitiesArgs
    leaderboard?: boolean | UserCountOutputTypeCountLeaderboardArgs
    wishlists?: boolean | UserCountOutputTypeCountWishlistsArgs
    profileExports?: boolean | UserCountOutputTypeCountProfileExportsArgs
    services?: boolean | UserCountOutputTypeCountServicesArgs
    serviceBookings?: boolean | UserCountOutputTypeCountServiceBookingsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInterestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedInterestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChats2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProfileViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileViewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountShortlistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShortlistWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlockedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockedUserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlockedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockedUserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReferralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReferredByRefArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReferredUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHoroscopesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HoroscopeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFamilyMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FamilyMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSuccessStoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SuccessStoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVideoCallsAsCallerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoCallWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVideoCallsAsParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoCallWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountForumPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumPostWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountForumCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumCommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGroupMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEventParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventParticipantWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlogPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMatchScoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchScoreWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMatchedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchScoreWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSearchHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessageTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageTemplateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountIceBreakersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IceBreakerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLeaderboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaderboardWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWishlistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WishlistWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProfileExportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileExportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountServiceBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceBookingWhereInput
  }


  /**
   * Count Type ProfileCountOutputType
   */

  export type ProfileCountOutputType = {
    photos: number
    profileViews: number
    shortlistedBy: number
    comparisons: number
    testimonials: number
  }

  export type ProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos?: boolean | ProfileCountOutputTypeCountPhotosArgs
    profileViews?: boolean | ProfileCountOutputTypeCountProfileViewsArgs
    shortlistedBy?: boolean | ProfileCountOutputTypeCountShortlistedByArgs
    comparisons?: boolean | ProfileCountOutputTypeCountComparisonsArgs
    testimonials?: boolean | ProfileCountOutputTypeCountTestimonialsArgs
  }

  // Custom InputTypes
  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileCountOutputType
     */
    select?: ProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhotoWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountProfileViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileViewWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountShortlistedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShortlistWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountComparisonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileComparisonWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountTestimonialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestimonialWhereInput
  }


  /**
   * Count Type ChatCountOutputType
   */

  export type ChatCountOutputType = {
    messages: number
  }

  export type ChatCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ChatCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ChatCountOutputType without action
   */
  export type ChatCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatCountOutputType
     */
    select?: ChatCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatCountOutputType without action
   */
  export type ChatCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type SubscriptionCountOutputType
   */

  export type SubscriptionCountOutputType = {
    contactViews: number
  }

  export type SubscriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contactViews?: boolean | SubscriptionCountOutputTypeCountContactViewsArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionCountOutputType
     */
    select?: SubscriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountContactViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactViewWhereInput
  }


  /**
   * Count Type PaymentCountOutputType
   */

  export type PaymentCountOutputType = {
    addOns: number
    services: number
  }

  export type PaymentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addOns?: boolean | PaymentCountOutputTypeCountAddOnsArgs
    services?: boolean | PaymentCountOutputTypeCountServicesArgs
  }

  // Custom InputTypes
  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentCountOutputType
     */
    select?: PaymentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeCountAddOnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddOnWhereInput
  }

  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    bookings: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | ServiceCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceBookingWhereInput
  }


  /**
   * Count Type ServiceProviderCountOutputType
   */

  export type ServiceProviderCountOutputType = {
    bookings: number
  }

  export type ServiceProviderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | ServiceProviderCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * ServiceProviderCountOutputType without action
   */
  export type ServiceProviderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProviderCountOutputType
     */
    select?: ServiceProviderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceProviderCountOutputType without action
   */
  export type ServiceProviderCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceBookingWhereInput
  }


  /**
   * Count Type HoroscopeCountOutputType
   */

  export type HoroscopeCountOutputType = {
    matches1: number
    matches2: number
  }

  export type HoroscopeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    matches1?: boolean | HoroscopeCountOutputTypeCountMatches1Args
    matches2?: boolean | HoroscopeCountOutputTypeCountMatches2Args
  }

  // Custom InputTypes
  /**
   * HoroscopeCountOutputType without action
   */
  export type HoroscopeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HoroscopeCountOutputType
     */
    select?: HoroscopeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HoroscopeCountOutputType without action
   */
  export type HoroscopeCountOutputTypeCountMatches1Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HoroscopeMatchWhereInput
  }

  /**
   * HoroscopeCountOutputType without action
   */
  export type HoroscopeCountOutputTypeCountMatches2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HoroscopeMatchWhereInput
  }


  /**
   * Count Type ForumPostCountOutputType
   */

  export type ForumPostCountOutputType = {
    comments: number
  }

  export type ForumPostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | ForumPostCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * ForumPostCountOutputType without action
   */
  export type ForumPostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPostCountOutputType
     */
    select?: ForumPostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ForumPostCountOutputType without action
   */
  export type ForumPostCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumCommentWhereInput
  }


  /**
   * Count Type CommunityGroupCountOutputType
   */

  export type CommunityGroupCountOutputType = {
    members: number
  }

  export type CommunityGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | CommunityGroupCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * CommunityGroupCountOutputType without action
   */
  export type CommunityGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityGroupCountOutputType
     */
    select?: CommunityGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommunityGroupCountOutputType without action
   */
  export type CommunityGroupCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMemberWhereInput
  }


  /**
   * Count Type CommunityEventCountOutputType
   */

  export type CommunityEventCountOutputType = {
    participants: number
  }

  export type CommunityEventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | CommunityEventCountOutputTypeCountParticipantsArgs
  }

  // Custom InputTypes
  /**
   * CommunityEventCountOutputType without action
   */
  export type CommunityEventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityEventCountOutputType
     */
    select?: CommunityEventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommunityEventCountOutputType without action
   */
  export type CommunityEventCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventParticipantWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    points: number | null
    loginStreak: number | null
  }

  export type UserSumAggregateOutputType = {
    points: number | null
    loginStreak: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    mobile: string | null
    password: string | null
    role: $Enums.UserRole | null
    isEmailVerified: boolean | null
    isMobileVerified: boolean | null
    googleId: string | null
    appleId: string | null
    fcmToken: string | null
    referralCode: string | null
    referredBy: string | null
    points: number | null
    lastActiveAt: Date | null
    isOnline: boolean | null
    lastLoginDate: Date | null
    loginStreak: number | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
    gdprConsent: boolean | null
    gdprConsentAt: Date | null
    deletedAt: Date | null
    preferredLanguage: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    mobile: string | null
    password: string | null
    role: $Enums.UserRole | null
    isEmailVerified: boolean | null
    isMobileVerified: boolean | null
    googleId: string | null
    appleId: string | null
    fcmToken: string | null
    referralCode: string | null
    referredBy: string | null
    points: number | null
    lastActiveAt: Date | null
    isOnline: boolean | null
    lastLoginDate: Date | null
    loginStreak: number | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
    gdprConsent: boolean | null
    gdprConsentAt: Date | null
    deletedAt: Date | null
    preferredLanguage: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    mobile: number
    password: number
    role: number
    isEmailVerified: number
    isMobileVerified: number
    googleId: number
    appleId: number
    fcmToken: number
    referralCode: number
    referredBy: number
    points: number
    lastActiveAt: number
    isOnline: number
    lastLoginDate: number
    loginStreak: number
    createdAt: number
    updatedAt: number
    lastLoginAt: number
    gdprConsent: number
    gdprConsentAt: number
    deletedAt: number
    preferredLanguage: number
    notificationPreferences: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    points?: true
    loginStreak?: true
  }

  export type UserSumAggregateInputType = {
    points?: true
    loginStreak?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    mobile?: true
    password?: true
    role?: true
    isEmailVerified?: true
    isMobileVerified?: true
    googleId?: true
    appleId?: true
    fcmToken?: true
    referralCode?: true
    referredBy?: true
    points?: true
    lastActiveAt?: true
    isOnline?: true
    lastLoginDate?: true
    loginStreak?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
    gdprConsent?: true
    gdprConsentAt?: true
    deletedAt?: true
    preferredLanguage?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    mobile?: true
    password?: true
    role?: true
    isEmailVerified?: true
    isMobileVerified?: true
    googleId?: true
    appleId?: true
    fcmToken?: true
    referralCode?: true
    referredBy?: true
    points?: true
    lastActiveAt?: true
    isOnline?: true
    lastLoginDate?: true
    loginStreak?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
    gdprConsent?: true
    gdprConsentAt?: true
    deletedAt?: true
    preferredLanguage?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    mobile?: true
    password?: true
    role?: true
    isEmailVerified?: true
    isMobileVerified?: true
    googleId?: true
    appleId?: true
    fcmToken?: true
    referralCode?: true
    referredBy?: true
    points?: true
    lastActiveAt?: true
    isOnline?: true
    lastLoginDate?: true
    loginStreak?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
    gdprConsent?: true
    gdprConsentAt?: true
    deletedAt?: true
    preferredLanguage?: true
    notificationPreferences?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string | null
    mobile: string | null
    password: string | null
    role: $Enums.UserRole
    isEmailVerified: boolean
    isMobileVerified: boolean
    googleId: string | null
    appleId: string | null
    fcmToken: string | null
    referralCode: string | null
    referredBy: string | null
    points: number
    lastActiveAt: Date | null
    isOnline: boolean
    lastLoginDate: Date | null
    loginStreak: number
    createdAt: Date
    updatedAt: Date
    lastLoginAt: Date | null
    gdprConsent: boolean
    gdprConsentAt: Date | null
    deletedAt: Date | null
    preferredLanguage: string | null
    notificationPreferences: JsonValue | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    mobile?: boolean
    password?: boolean
    role?: boolean
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: boolean
    appleId?: boolean
    fcmToken?: boolean
    referralCode?: boolean
    referredBy?: boolean
    points?: boolean
    lastActiveAt?: boolean
    isOnline?: boolean
    lastLoginDate?: boolean
    loginStreak?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
    gdprConsent?: boolean
    gdprConsentAt?: boolean
    deletedAt?: boolean
    preferredLanguage?: boolean
    notificationPreferences?: boolean
    profile?: boolean | User$profileArgs<ExtArgs>
    interests?: boolean | User$interestsArgs<ExtArgs>
    receivedInterests?: boolean | User$receivedInterestsArgs<ExtArgs>
    chats?: boolean | User$chatsArgs<ExtArgs>
    chats2?: boolean | User$chats2Args<ExtArgs>
    messages?: boolean | User$messagesArgs<ExtArgs>
    subscriptions?: boolean | User$subscriptionsArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    profileViews?: boolean | User$profileViewsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    shortlists?: boolean | User$shortlistsArgs<ExtArgs>
    blockedUsers?: boolean | User$blockedUsersArgs<ExtArgs>
    blockedBy?: boolean | User$blockedByArgs<ExtArgs>
    referrals?: boolean | User$referralsArgs<ExtArgs>
    referredByRef?: boolean | User$referredByRefArgs<ExtArgs>
    referrer?: boolean | User$referrerArgs<ExtArgs>
    referredUsers?: boolean | User$referredUsersArgs<ExtArgs>
    achievements?: boolean | User$achievementsArgs<ExtArgs>
    horoscopes?: boolean | User$horoscopesArgs<ExtArgs>
    familyMembers?: boolean | User$familyMembersArgs<ExtArgs>
    successStories?: boolean | User$successStoriesArgs<ExtArgs>
    documents?: boolean | User$documentsArgs<ExtArgs>
    videoCallsAsCaller?: boolean | User$videoCallsAsCallerArgs<ExtArgs>
    videoCallsAsParticipant?: boolean | User$videoCallsAsParticipantArgs<ExtArgs>
    forumPosts?: boolean | User$forumPostsArgs<ExtArgs>
    forumComments?: boolean | User$forumCommentsArgs<ExtArgs>
    groupMembers?: boolean | User$groupMembersArgs<ExtArgs>
    eventParticipants?: boolean | User$eventParticipantsArgs<ExtArgs>
    blogPosts?: boolean | User$blogPostsArgs<ExtArgs>
    matchScores?: boolean | User$matchScoresArgs<ExtArgs>
    matchedBy?: boolean | User$matchedByArgs<ExtArgs>
    searchHistory?: boolean | User$searchHistoryArgs<ExtArgs>
    messageTemplates?: boolean | User$messageTemplatesArgs<ExtArgs>
    iceBreakers?: boolean | User$iceBreakersArgs<ExtArgs>
    activities?: boolean | User$activitiesArgs<ExtArgs>
    leaderboard?: boolean | User$leaderboardArgs<ExtArgs>
    wishlists?: boolean | User$wishlistsArgs<ExtArgs>
    profileExports?: boolean | User$profileExportsArgs<ExtArgs>
    services?: boolean | User$servicesArgs<ExtArgs>
    serviceBookings?: boolean | User$serviceBookingsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    mobile?: boolean
    password?: boolean
    role?: boolean
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: boolean
    appleId?: boolean
    fcmToken?: boolean
    referralCode?: boolean
    referredBy?: boolean
    points?: boolean
    lastActiveAt?: boolean
    isOnline?: boolean
    lastLoginDate?: boolean
    loginStreak?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
    gdprConsent?: boolean
    gdprConsentAt?: boolean
    deletedAt?: boolean
    preferredLanguage?: boolean
    notificationPreferences?: boolean
    referrer?: boolean | User$referrerArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    mobile?: boolean
    password?: boolean
    role?: boolean
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: boolean
    appleId?: boolean
    fcmToken?: boolean
    referralCode?: boolean
    referredBy?: boolean
    points?: boolean
    lastActiveAt?: boolean
    isOnline?: boolean
    lastLoginDate?: boolean
    loginStreak?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
    gdprConsent?: boolean
    gdprConsentAt?: boolean
    deletedAt?: boolean
    preferredLanguage?: boolean
    notificationPreferences?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | User$profileArgs<ExtArgs>
    interests?: boolean | User$interestsArgs<ExtArgs>
    receivedInterests?: boolean | User$receivedInterestsArgs<ExtArgs>
    chats?: boolean | User$chatsArgs<ExtArgs>
    chats2?: boolean | User$chats2Args<ExtArgs>
    messages?: boolean | User$messagesArgs<ExtArgs>
    subscriptions?: boolean | User$subscriptionsArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    profileViews?: boolean | User$profileViewsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    shortlists?: boolean | User$shortlistsArgs<ExtArgs>
    blockedUsers?: boolean | User$blockedUsersArgs<ExtArgs>
    blockedBy?: boolean | User$blockedByArgs<ExtArgs>
    referrals?: boolean | User$referralsArgs<ExtArgs>
    referredByRef?: boolean | User$referredByRefArgs<ExtArgs>
    referrer?: boolean | User$referrerArgs<ExtArgs>
    referredUsers?: boolean | User$referredUsersArgs<ExtArgs>
    achievements?: boolean | User$achievementsArgs<ExtArgs>
    horoscopes?: boolean | User$horoscopesArgs<ExtArgs>
    familyMembers?: boolean | User$familyMembersArgs<ExtArgs>
    successStories?: boolean | User$successStoriesArgs<ExtArgs>
    documents?: boolean | User$documentsArgs<ExtArgs>
    videoCallsAsCaller?: boolean | User$videoCallsAsCallerArgs<ExtArgs>
    videoCallsAsParticipant?: boolean | User$videoCallsAsParticipantArgs<ExtArgs>
    forumPosts?: boolean | User$forumPostsArgs<ExtArgs>
    forumComments?: boolean | User$forumCommentsArgs<ExtArgs>
    groupMembers?: boolean | User$groupMembersArgs<ExtArgs>
    eventParticipants?: boolean | User$eventParticipantsArgs<ExtArgs>
    blogPosts?: boolean | User$blogPostsArgs<ExtArgs>
    matchScores?: boolean | User$matchScoresArgs<ExtArgs>
    matchedBy?: boolean | User$matchedByArgs<ExtArgs>
    searchHistory?: boolean | User$searchHistoryArgs<ExtArgs>
    messageTemplates?: boolean | User$messageTemplatesArgs<ExtArgs>
    iceBreakers?: boolean | User$iceBreakersArgs<ExtArgs>
    activities?: boolean | User$activitiesArgs<ExtArgs>
    leaderboard?: boolean | User$leaderboardArgs<ExtArgs>
    wishlists?: boolean | User$wishlistsArgs<ExtArgs>
    profileExports?: boolean | User$profileExportsArgs<ExtArgs>
    services?: boolean | User$servicesArgs<ExtArgs>
    serviceBookings?: boolean | User$serviceBookingsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrer?: boolean | User$referrerArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs> | null
      interests: Prisma.$InterestPayload<ExtArgs>[]
      receivedInterests: Prisma.$InterestPayload<ExtArgs>[]
      chats: Prisma.$ChatPayload<ExtArgs>[]
      chats2: Prisma.$ChatPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      profileViews: Prisma.$ProfileViewPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      shortlists: Prisma.$ShortlistPayload<ExtArgs>[]
      blockedUsers: Prisma.$BlockedUserPayload<ExtArgs>[]
      blockedBy: Prisma.$BlockedUserPayload<ExtArgs>[]
      referrals: Prisma.$ReferralPayload<ExtArgs>[]
      referredByRef: Prisma.$ReferralPayload<ExtArgs>[]
      referrer: Prisma.$UserPayload<ExtArgs> | null
      referredUsers: Prisma.$UserPayload<ExtArgs>[]
      achievements: Prisma.$AchievementPayload<ExtArgs>[]
      horoscopes: Prisma.$HoroscopePayload<ExtArgs>[]
      familyMembers: Prisma.$FamilyMemberPayload<ExtArgs>[]
      successStories: Prisma.$SuccessStoryPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      videoCallsAsCaller: Prisma.$VideoCallPayload<ExtArgs>[]
      videoCallsAsParticipant: Prisma.$VideoCallPayload<ExtArgs>[]
      forumPosts: Prisma.$ForumPostPayload<ExtArgs>[]
      forumComments: Prisma.$ForumCommentPayload<ExtArgs>[]
      groupMembers: Prisma.$GroupMemberPayload<ExtArgs>[]
      eventParticipants: Prisma.$EventParticipantPayload<ExtArgs>[]
      blogPosts: Prisma.$BlogPostPayload<ExtArgs>[]
      matchScores: Prisma.$MatchScorePayload<ExtArgs>[]
      matchedBy: Prisma.$MatchScorePayload<ExtArgs>[]
      searchHistory: Prisma.$SearchHistoryPayload<ExtArgs>[]
      messageTemplates: Prisma.$MessageTemplatePayload<ExtArgs>[]
      iceBreakers: Prisma.$IceBreakerPayload<ExtArgs>[]
      activities: Prisma.$ActivityPayload<ExtArgs>[]
      leaderboard: Prisma.$LeaderboardPayload<ExtArgs>[]
      wishlists: Prisma.$WishlistPayload<ExtArgs>[]
      profileExports: Prisma.$ProfileExportPayload<ExtArgs>[]
      services: Prisma.$ServicePayload<ExtArgs>[]
      serviceBookings: Prisma.$ServiceBookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string | null
      mobile: string | null
      password: string | null
      role: $Enums.UserRole
      isEmailVerified: boolean
      isMobileVerified: boolean
      googleId: string | null
      appleId: string | null
      fcmToken: string | null
      referralCode: string | null
      referredBy: string | null
      points: number
      lastActiveAt: Date | null
      isOnline: boolean
      lastLoginDate: Date | null
      loginStreak: number
      createdAt: Date
      updatedAt: Date
      lastLoginAt: Date | null
      gdprConsent: boolean
      gdprConsentAt: Date | null
      deletedAt: Date | null
      preferredLanguage: string | null
      notificationPreferences: Prisma.JsonValue | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends User$profileArgs<ExtArgs> = {}>(args?: Subset<T, User$profileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    interests<T extends User$interestsArgs<ExtArgs> = {}>(args?: Subset<T, User$interestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "findMany"> | Null>
    receivedInterests<T extends User$receivedInterestsArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedInterestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "findMany"> | Null>
    chats<T extends User$chatsArgs<ExtArgs> = {}>(args?: Subset<T, User$chatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany"> | Null>
    chats2<T extends User$chats2Args<ExtArgs> = {}>(args?: Subset<T, User$chats2Args<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany"> | Null>
    messages<T extends User$messagesArgs<ExtArgs> = {}>(args?: Subset<T, User$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    subscriptions<T extends User$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, User$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany"> | Null>
    payments<T extends User$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    profileViews<T extends User$profileViewsArgs<ExtArgs> = {}>(args?: Subset<T, User$profileViewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileViewPayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    shortlists<T extends User$shortlistsArgs<ExtArgs> = {}>(args?: Subset<T, User$shortlistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShortlistPayload<ExtArgs>, T, "findMany"> | Null>
    blockedUsers<T extends User$blockedUsersArgs<ExtArgs> = {}>(args?: Subset<T, User$blockedUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "findMany"> | Null>
    blockedBy<T extends User$blockedByArgs<ExtArgs> = {}>(args?: Subset<T, User$blockedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "findMany"> | Null>
    referrals<T extends User$referralsArgs<ExtArgs> = {}>(args?: Subset<T, User$referralsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany"> | Null>
    referredByRef<T extends User$referredByRefArgs<ExtArgs> = {}>(args?: Subset<T, User$referredByRefArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany"> | Null>
    referrer<T extends User$referrerArgs<ExtArgs> = {}>(args?: Subset<T, User$referrerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    referredUsers<T extends User$referredUsersArgs<ExtArgs> = {}>(args?: Subset<T, User$referredUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    achievements<T extends User$achievementsArgs<ExtArgs> = {}>(args?: Subset<T, User$achievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findMany"> | Null>
    horoscopes<T extends User$horoscopesArgs<ExtArgs> = {}>(args?: Subset<T, User$horoscopesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HoroscopePayload<ExtArgs>, T, "findMany"> | Null>
    familyMembers<T extends User$familyMembersArgs<ExtArgs> = {}>(args?: Subset<T, User$familyMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "findMany"> | Null>
    successStories<T extends User$successStoriesArgs<ExtArgs> = {}>(args?: Subset<T, User$successStoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuccessStoryPayload<ExtArgs>, T, "findMany"> | Null>
    documents<T extends User$documentsArgs<ExtArgs> = {}>(args?: Subset<T, User$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany"> | Null>
    videoCallsAsCaller<T extends User$videoCallsAsCallerArgs<ExtArgs> = {}>(args?: Subset<T, User$videoCallsAsCallerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoCallPayload<ExtArgs>, T, "findMany"> | Null>
    videoCallsAsParticipant<T extends User$videoCallsAsParticipantArgs<ExtArgs> = {}>(args?: Subset<T, User$videoCallsAsParticipantArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoCallPayload<ExtArgs>, T, "findMany"> | Null>
    forumPosts<T extends User$forumPostsArgs<ExtArgs> = {}>(args?: Subset<T, User$forumPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "findMany"> | Null>
    forumComments<T extends User$forumCommentsArgs<ExtArgs> = {}>(args?: Subset<T, User$forumCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumCommentPayload<ExtArgs>, T, "findMany"> | Null>
    groupMembers<T extends User$groupMembersArgs<ExtArgs> = {}>(args?: Subset<T, User$groupMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findMany"> | Null>
    eventParticipants<T extends User$eventParticipantsArgs<ExtArgs> = {}>(args?: Subset<T, User$eventParticipantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventParticipantPayload<ExtArgs>, T, "findMany"> | Null>
    blogPosts<T extends User$blogPostsArgs<ExtArgs> = {}>(args?: Subset<T, User$blogPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findMany"> | Null>
    matchScores<T extends User$matchScoresArgs<ExtArgs> = {}>(args?: Subset<T, User$matchScoresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchScorePayload<ExtArgs>, T, "findMany"> | Null>
    matchedBy<T extends User$matchedByArgs<ExtArgs> = {}>(args?: Subset<T, User$matchedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchScorePayload<ExtArgs>, T, "findMany"> | Null>
    searchHistory<T extends User$searchHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$searchHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    messageTemplates<T extends User$messageTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, User$messageTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "findMany"> | Null>
    iceBreakers<T extends User$iceBreakersArgs<ExtArgs> = {}>(args?: Subset<T, User$iceBreakersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IceBreakerPayload<ExtArgs>, T, "findMany"> | Null>
    activities<T extends User$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany"> | Null>
    leaderboard<T extends User$leaderboardArgs<ExtArgs> = {}>(args?: Subset<T, User$leaderboardArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "findMany"> | Null>
    wishlists<T extends User$wishlistsArgs<ExtArgs> = {}>(args?: Subset<T, User$wishlistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "findMany"> | Null>
    profileExports<T extends User$profileExportsArgs<ExtArgs> = {}>(args?: Subset<T, User$profileExportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileExportPayload<ExtArgs>, T, "findMany"> | Null>
    services<T extends User$servicesArgs<ExtArgs> = {}>(args?: Subset<T, User$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany"> | Null>
    serviceBookings<T extends User$serviceBookingsArgs<ExtArgs> = {}>(args?: Subset<T, User$serviceBookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceBookingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly mobile: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isEmailVerified: FieldRef<"User", 'Boolean'>
    readonly isMobileVerified: FieldRef<"User", 'Boolean'>
    readonly googleId: FieldRef<"User", 'String'>
    readonly appleId: FieldRef<"User", 'String'>
    readonly fcmToken: FieldRef<"User", 'String'>
    readonly referralCode: FieldRef<"User", 'String'>
    readonly referredBy: FieldRef<"User", 'String'>
    readonly points: FieldRef<"User", 'Int'>
    readonly lastActiveAt: FieldRef<"User", 'DateTime'>
    readonly isOnline: FieldRef<"User", 'Boolean'>
    readonly lastLoginDate: FieldRef<"User", 'DateTime'>
    readonly loginStreak: FieldRef<"User", 'Int'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly gdprConsent: FieldRef<"User", 'Boolean'>
    readonly gdprConsentAt: FieldRef<"User", 'DateTime'>
    readonly deletedAt: FieldRef<"User", 'DateTime'>
    readonly preferredLanguage: FieldRef<"User", 'String'>
    readonly notificationPreferences: FieldRef<"User", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.profile
   */
  export type User$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * User.interests
   */
  export type User$interestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    where?: InterestWhereInput
    orderBy?: InterestOrderByWithRelationInput | InterestOrderByWithRelationInput[]
    cursor?: InterestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InterestScalarFieldEnum | InterestScalarFieldEnum[]
  }

  /**
   * User.receivedInterests
   */
  export type User$receivedInterestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    where?: InterestWhereInput
    orderBy?: InterestOrderByWithRelationInput | InterestOrderByWithRelationInput[]
    cursor?: InterestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InterestScalarFieldEnum | InterestScalarFieldEnum[]
  }

  /**
   * User.chats
   */
  export type User$chatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    cursor?: ChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * User.chats2
   */
  export type User$chats2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    cursor?: ChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * User.messages
   */
  export type User$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.subscriptions
   */
  export type User$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * User.payments
   */
  export type User$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * User.profileViews
   */
  export type User$profileViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileView
     */
    select?: ProfileViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileViewInclude<ExtArgs> | null
    where?: ProfileViewWhereInput
    orderBy?: ProfileViewOrderByWithRelationInput | ProfileViewOrderByWithRelationInput[]
    cursor?: ProfileViewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileViewScalarFieldEnum | ProfileViewScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.shortlists
   */
  export type User$shortlistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shortlist
     */
    select?: ShortlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShortlistInclude<ExtArgs> | null
    where?: ShortlistWhereInput
    orderBy?: ShortlistOrderByWithRelationInput | ShortlistOrderByWithRelationInput[]
    cursor?: ShortlistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShortlistScalarFieldEnum | ShortlistScalarFieldEnum[]
  }

  /**
   * User.blockedUsers
   */
  export type User$blockedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    where?: BlockedUserWhereInput
    orderBy?: BlockedUserOrderByWithRelationInput | BlockedUserOrderByWithRelationInput[]
    cursor?: BlockedUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockedUserScalarFieldEnum | BlockedUserScalarFieldEnum[]
  }

  /**
   * User.blockedBy
   */
  export type User$blockedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    where?: BlockedUserWhereInput
    orderBy?: BlockedUserOrderByWithRelationInput | BlockedUserOrderByWithRelationInput[]
    cursor?: BlockedUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockedUserScalarFieldEnum | BlockedUserScalarFieldEnum[]
  }

  /**
   * User.referrals
   */
  export type User$referralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    cursor?: ReferralWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * User.referredByRef
   */
  export type User$referredByRefArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    cursor?: ReferralWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * User.referrer
   */
  export type User$referrerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.referredUsers
   */
  export type User$referredUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User.achievements
   */
  export type User$achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    where?: AchievementWhereInput
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    cursor?: AchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * User.horoscopes
   */
  export type User$horoscopesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Horoscope
     */
    select?: HoroscopeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoroscopeInclude<ExtArgs> | null
    where?: HoroscopeWhereInput
    orderBy?: HoroscopeOrderByWithRelationInput | HoroscopeOrderByWithRelationInput[]
    cursor?: HoroscopeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HoroscopeScalarFieldEnum | HoroscopeScalarFieldEnum[]
  }

  /**
   * User.familyMembers
   */
  export type User$familyMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    where?: FamilyMemberWhereInput
    orderBy?: FamilyMemberOrderByWithRelationInput | FamilyMemberOrderByWithRelationInput[]
    cursor?: FamilyMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FamilyMemberScalarFieldEnum | FamilyMemberScalarFieldEnum[]
  }

  /**
   * User.successStories
   */
  export type User$successStoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuccessStory
     */
    select?: SuccessStorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuccessStoryInclude<ExtArgs> | null
    where?: SuccessStoryWhereInput
    orderBy?: SuccessStoryOrderByWithRelationInput | SuccessStoryOrderByWithRelationInput[]
    cursor?: SuccessStoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SuccessStoryScalarFieldEnum | SuccessStoryScalarFieldEnum[]
  }

  /**
   * User.documents
   */
  export type User$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * User.videoCallsAsCaller
   */
  export type User$videoCallsAsCallerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCall
     */
    select?: VideoCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoCallInclude<ExtArgs> | null
    where?: VideoCallWhereInput
    orderBy?: VideoCallOrderByWithRelationInput | VideoCallOrderByWithRelationInput[]
    cursor?: VideoCallWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideoCallScalarFieldEnum | VideoCallScalarFieldEnum[]
  }

  /**
   * User.videoCallsAsParticipant
   */
  export type User$videoCallsAsParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCall
     */
    select?: VideoCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoCallInclude<ExtArgs> | null
    where?: VideoCallWhereInput
    orderBy?: VideoCallOrderByWithRelationInput | VideoCallOrderByWithRelationInput[]
    cursor?: VideoCallWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideoCallScalarFieldEnum | VideoCallScalarFieldEnum[]
  }

  /**
   * User.forumPosts
   */
  export type User$forumPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    where?: ForumPostWhereInput
    orderBy?: ForumPostOrderByWithRelationInput | ForumPostOrderByWithRelationInput[]
    cursor?: ForumPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForumPostScalarFieldEnum | ForumPostScalarFieldEnum[]
  }

  /**
   * User.forumComments
   */
  export type User$forumCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentInclude<ExtArgs> | null
    where?: ForumCommentWhereInput
    orderBy?: ForumCommentOrderByWithRelationInput | ForumCommentOrderByWithRelationInput[]
    cursor?: ForumCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForumCommentScalarFieldEnum | ForumCommentScalarFieldEnum[]
  }

  /**
   * User.groupMembers
   */
  export type User$groupMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    where?: GroupMemberWhereInput
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    cursor?: GroupMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * User.eventParticipants
   */
  export type User$eventParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipant
     */
    select?: EventParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipantInclude<ExtArgs> | null
    where?: EventParticipantWhereInput
    orderBy?: EventParticipantOrderByWithRelationInput | EventParticipantOrderByWithRelationInput[]
    cursor?: EventParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventParticipantScalarFieldEnum | EventParticipantScalarFieldEnum[]
  }

  /**
   * User.blogPosts
   */
  export type User$blogPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    where?: BlogPostWhereInput
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    cursor?: BlogPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * User.matchScores
   */
  export type User$matchScoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchScore
     */
    select?: MatchScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchScoreInclude<ExtArgs> | null
    where?: MatchScoreWhereInput
    orderBy?: MatchScoreOrderByWithRelationInput | MatchScoreOrderByWithRelationInput[]
    cursor?: MatchScoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchScoreScalarFieldEnum | MatchScoreScalarFieldEnum[]
  }

  /**
   * User.matchedBy
   */
  export type User$matchedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchScore
     */
    select?: MatchScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchScoreInclude<ExtArgs> | null
    where?: MatchScoreWhereInput
    orderBy?: MatchScoreOrderByWithRelationInput | MatchScoreOrderByWithRelationInput[]
    cursor?: MatchScoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchScoreScalarFieldEnum | MatchScoreScalarFieldEnum[]
  }

  /**
   * User.searchHistory
   */
  export type User$searchHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    where?: SearchHistoryWhereInput
    orderBy?: SearchHistoryOrderByWithRelationInput | SearchHistoryOrderByWithRelationInput[]
    cursor?: SearchHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SearchHistoryScalarFieldEnum | SearchHistoryScalarFieldEnum[]
  }

  /**
   * User.messageTemplates
   */
  export type User$messageTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    where?: MessageTemplateWhereInput
    orderBy?: MessageTemplateOrderByWithRelationInput | MessageTemplateOrderByWithRelationInput[]
    cursor?: MessageTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageTemplateScalarFieldEnum | MessageTemplateScalarFieldEnum[]
  }

  /**
   * User.iceBreakers
   */
  export type User$iceBreakersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IceBreaker
     */
    select?: IceBreakerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IceBreakerInclude<ExtArgs> | null
    where?: IceBreakerWhereInput
    orderBy?: IceBreakerOrderByWithRelationInput | IceBreakerOrderByWithRelationInput[]
    cursor?: IceBreakerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IceBreakerScalarFieldEnum | IceBreakerScalarFieldEnum[]
  }

  /**
   * User.activities
   */
  export type User$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * User.leaderboard
   */
  export type User$leaderboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    where?: LeaderboardWhereInput
    orderBy?: LeaderboardOrderByWithRelationInput | LeaderboardOrderByWithRelationInput[]
    cursor?: LeaderboardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaderboardScalarFieldEnum | LeaderboardScalarFieldEnum[]
  }

  /**
   * User.wishlists
   */
  export type User$wishlistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    where?: WishlistWhereInput
    orderBy?: WishlistOrderByWithRelationInput | WishlistOrderByWithRelationInput[]
    cursor?: WishlistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WishlistScalarFieldEnum | WishlistScalarFieldEnum[]
  }

  /**
   * User.profileExports
   */
  export type User$profileExportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileExport
     */
    select?: ProfileExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileExportInclude<ExtArgs> | null
    where?: ProfileExportWhereInput
    orderBy?: ProfileExportOrderByWithRelationInput | ProfileExportOrderByWithRelationInput[]
    cursor?: ProfileExportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileExportScalarFieldEnum | ProfileExportScalarFieldEnum[]
  }

  /**
   * User.services
   */
  export type User$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * User.serviceBookings
   */
  export type User$serviceBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBooking
     */
    select?: ServiceBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingInclude<ExtArgs> | null
    where?: ServiceBookingWhereInput
    orderBy?: ServiceBookingOrderByWithRelationInput | ServiceBookingOrderByWithRelationInput[]
    cursor?: ServiceBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceBookingScalarFieldEnum | ServiceBookingScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    ipAddress: number
    userAgent: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    createdAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    createdAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    token: string
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date
    createdAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      ipAddress: string | null
      userAgent: string | null
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly token: FieldRef<"Session", 'String'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileAvgAggregateOutputType = {
    height: number | null
    income: number | null
    siblings: number | null
    latitude: number | null
    longitude: number | null
    trustScore: number | null
    completenessScore: number | null
  }

  export type ProfileSumAggregateOutputType = {
    height: number | null
    income: number | null
    siblings: number | null
    latitude: number | null
    longitude: number | null
    trustScore: number | null
    completenessScore: number | null
  }

  export type ProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    status: $Enums.ProfileStatus | null
    firstName: string | null
    lastName: string | null
    gender: $Enums.Gender | null
    dateOfBirth: Date | null
    height: number | null
    maritalStatus: $Enums.MaritalStatus | null
    religion: string | null
    caste: string | null
    motherTongue: string | null
    manglik: boolean | null
    gothra: string | null
    country: string | null
    state: string | null
    city: string | null
    citizenship: string | null
    education: string | null
    college: string | null
    occupation: string | null
    income: number | null
    incomeCurrency: string | null
    fatherOccupation: string | null
    motherOccupation: string | null
    siblings: number | null
    familyType: $Enums.FamilyType | null
    diet: $Enums.Diet | null
    smoking: boolean | null
    drinking: boolean | null
    hobbies: string | null
    videoIntroUrl: string | null
    biodataUrl: string | null
    aboutMe: string | null
    latitude: number | null
    longitude: number | null
    isHiddenFromSearch: boolean | null
    isAnonymousViewing: boolean | null
    contactPrivacyLevel: string | null
    photoPrivacyLevel: string | null
    isVerified: boolean | null
    verifiedAt: Date | null
    trustScore: number | null
    completenessScore: number | null
    isHighlighted: boolean | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    status: $Enums.ProfileStatus | null
    firstName: string | null
    lastName: string | null
    gender: $Enums.Gender | null
    dateOfBirth: Date | null
    height: number | null
    maritalStatus: $Enums.MaritalStatus | null
    religion: string | null
    caste: string | null
    motherTongue: string | null
    manglik: boolean | null
    gothra: string | null
    country: string | null
    state: string | null
    city: string | null
    citizenship: string | null
    education: string | null
    college: string | null
    occupation: string | null
    income: number | null
    incomeCurrency: string | null
    fatherOccupation: string | null
    motherOccupation: string | null
    siblings: number | null
    familyType: $Enums.FamilyType | null
    diet: $Enums.Diet | null
    smoking: boolean | null
    drinking: boolean | null
    hobbies: string | null
    videoIntroUrl: string | null
    biodataUrl: string | null
    aboutMe: string | null
    latitude: number | null
    longitude: number | null
    isHiddenFromSearch: boolean | null
    isAnonymousViewing: boolean | null
    contactPrivacyLevel: string | null
    photoPrivacyLevel: string | null
    isVerified: boolean | null
    verifiedAt: Date | null
    trustScore: number | null
    completenessScore: number | null
    isHighlighted: boolean | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    userId: number
    status: number
    firstName: number
    lastName: number
    gender: number
    dateOfBirth: number
    height: number
    maritalStatus: number
    religion: number
    caste: number
    motherTongue: number
    manglik: number
    gothra: number
    country: number
    state: number
    city: number
    citizenship: number
    education: number
    college: number
    occupation: number
    income: number
    incomeCurrency: number
    fatherOccupation: number
    motherOccupation: number
    siblings: number
    familyType: number
    diet: number
    smoking: number
    drinking: number
    hobbies: number
    partnerPreferences: number
    videoIntroUrl: number
    biodataUrl: number
    aboutMe: number
    highlights: number
    latitude: number
    longitude: number
    privacySettings: number
    isHiddenFromSearch: number
    isAnonymousViewing: number
    contactPrivacyLevel: number
    photoPrivacyLevel: number
    isVerified: number
    verifiedAt: number
    trustScore: number
    completenessScore: number
    isHighlighted: number
    slug: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProfileAvgAggregateInputType = {
    height?: true
    income?: true
    siblings?: true
    latitude?: true
    longitude?: true
    trustScore?: true
    completenessScore?: true
  }

  export type ProfileSumAggregateInputType = {
    height?: true
    income?: true
    siblings?: true
    latitude?: true
    longitude?: true
    trustScore?: true
    completenessScore?: true
  }

  export type ProfileMinAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    firstName?: true
    lastName?: true
    gender?: true
    dateOfBirth?: true
    height?: true
    maritalStatus?: true
    religion?: true
    caste?: true
    motherTongue?: true
    manglik?: true
    gothra?: true
    country?: true
    state?: true
    city?: true
    citizenship?: true
    education?: true
    college?: true
    occupation?: true
    income?: true
    incomeCurrency?: true
    fatherOccupation?: true
    motherOccupation?: true
    siblings?: true
    familyType?: true
    diet?: true
    smoking?: true
    drinking?: true
    hobbies?: true
    videoIntroUrl?: true
    biodataUrl?: true
    aboutMe?: true
    latitude?: true
    longitude?: true
    isHiddenFromSearch?: true
    isAnonymousViewing?: true
    contactPrivacyLevel?: true
    photoPrivacyLevel?: true
    isVerified?: true
    verifiedAt?: true
    trustScore?: true
    completenessScore?: true
    isHighlighted?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    firstName?: true
    lastName?: true
    gender?: true
    dateOfBirth?: true
    height?: true
    maritalStatus?: true
    religion?: true
    caste?: true
    motherTongue?: true
    manglik?: true
    gothra?: true
    country?: true
    state?: true
    city?: true
    citizenship?: true
    education?: true
    college?: true
    occupation?: true
    income?: true
    incomeCurrency?: true
    fatherOccupation?: true
    motherOccupation?: true
    siblings?: true
    familyType?: true
    diet?: true
    smoking?: true
    drinking?: true
    hobbies?: true
    videoIntroUrl?: true
    biodataUrl?: true
    aboutMe?: true
    latitude?: true
    longitude?: true
    isHiddenFromSearch?: true
    isAnonymousViewing?: true
    contactPrivacyLevel?: true
    photoPrivacyLevel?: true
    isVerified?: true
    verifiedAt?: true
    trustScore?: true
    completenessScore?: true
    isHighlighted?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    firstName?: true
    lastName?: true
    gender?: true
    dateOfBirth?: true
    height?: true
    maritalStatus?: true
    religion?: true
    caste?: true
    motherTongue?: true
    manglik?: true
    gothra?: true
    country?: true
    state?: true
    city?: true
    citizenship?: true
    education?: true
    college?: true
    occupation?: true
    income?: true
    incomeCurrency?: true
    fatherOccupation?: true
    motherOccupation?: true
    siblings?: true
    familyType?: true
    diet?: true
    smoking?: true
    drinking?: true
    hobbies?: true
    partnerPreferences?: true
    videoIntroUrl?: true
    biodataUrl?: true
    aboutMe?: true
    highlights?: true
    latitude?: true
    longitude?: true
    privacySettings?: true
    isHiddenFromSearch?: true
    isAnonymousViewing?: true
    contactPrivacyLevel?: true
    photoPrivacyLevel?: true
    isVerified?: true
    verifiedAt?: true
    trustScore?: true
    completenessScore?: true
    isHighlighted?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithAggregationInput | ProfileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _avg?: ProfileAvgAggregateInputType
    _sum?: ProfileSumAggregateInputType
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: string
    userId: string
    status: $Enums.ProfileStatus
    firstName: string | null
    lastName: string | null
    gender: $Enums.Gender | null
    dateOfBirth: Date | null
    height: number | null
    maritalStatus: $Enums.MaritalStatus | null
    religion: string | null
    caste: string | null
    motherTongue: string | null
    manglik: boolean | null
    gothra: string | null
    country: string | null
    state: string | null
    city: string | null
    citizenship: string | null
    education: string | null
    college: string | null
    occupation: string | null
    income: number | null
    incomeCurrency: string | null
    fatherOccupation: string | null
    motherOccupation: string | null
    siblings: number | null
    familyType: $Enums.FamilyType | null
    diet: $Enums.Diet | null
    smoking: boolean | null
    drinking: boolean | null
    hobbies: string | null
    partnerPreferences: JsonValue | null
    videoIntroUrl: string | null
    biodataUrl: string | null
    aboutMe: string | null
    highlights: JsonValue | null
    latitude: number | null
    longitude: number | null
    privacySettings: JsonValue | null
    isHiddenFromSearch: boolean
    isAnonymousViewing: boolean
    contactPrivacyLevel: string | null
    photoPrivacyLevel: string | null
    isVerified: boolean
    verifiedAt: Date | null
    trustScore: number
    completenessScore: number
    isHighlighted: boolean
    slug: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    firstName?: boolean
    lastName?: boolean
    gender?: boolean
    dateOfBirth?: boolean
    height?: boolean
    maritalStatus?: boolean
    religion?: boolean
    caste?: boolean
    motherTongue?: boolean
    manglik?: boolean
    gothra?: boolean
    country?: boolean
    state?: boolean
    city?: boolean
    citizenship?: boolean
    education?: boolean
    college?: boolean
    occupation?: boolean
    income?: boolean
    incomeCurrency?: boolean
    fatherOccupation?: boolean
    motherOccupation?: boolean
    siblings?: boolean
    familyType?: boolean
    diet?: boolean
    smoking?: boolean
    drinking?: boolean
    hobbies?: boolean
    partnerPreferences?: boolean
    videoIntroUrl?: boolean
    biodataUrl?: boolean
    aboutMe?: boolean
    highlights?: boolean
    latitude?: boolean
    longitude?: boolean
    privacySettings?: boolean
    isHiddenFromSearch?: boolean
    isAnonymousViewing?: boolean
    contactPrivacyLevel?: boolean
    photoPrivacyLevel?: boolean
    isVerified?: boolean
    verifiedAt?: boolean
    trustScore?: boolean
    completenessScore?: boolean
    isHighlighted?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    photos?: boolean | Profile$photosArgs<ExtArgs>
    profileViews?: boolean | Profile$profileViewsArgs<ExtArgs>
    shortlistedBy?: boolean | Profile$shortlistedByArgs<ExtArgs>
    horoscope?: boolean | Profile$horoscopeArgs<ExtArgs>
    comparisons?: boolean | Profile$comparisonsArgs<ExtArgs>
    testimonials?: boolean | Profile$testimonialsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    firstName?: boolean
    lastName?: boolean
    gender?: boolean
    dateOfBirth?: boolean
    height?: boolean
    maritalStatus?: boolean
    religion?: boolean
    caste?: boolean
    motherTongue?: boolean
    manglik?: boolean
    gothra?: boolean
    country?: boolean
    state?: boolean
    city?: boolean
    citizenship?: boolean
    education?: boolean
    college?: boolean
    occupation?: boolean
    income?: boolean
    incomeCurrency?: boolean
    fatherOccupation?: boolean
    motherOccupation?: boolean
    siblings?: boolean
    familyType?: boolean
    diet?: boolean
    smoking?: boolean
    drinking?: boolean
    hobbies?: boolean
    partnerPreferences?: boolean
    videoIntroUrl?: boolean
    biodataUrl?: boolean
    aboutMe?: boolean
    highlights?: boolean
    latitude?: boolean
    longitude?: boolean
    privacySettings?: boolean
    isHiddenFromSearch?: boolean
    isAnonymousViewing?: boolean
    contactPrivacyLevel?: boolean
    photoPrivacyLevel?: boolean
    isVerified?: boolean
    verifiedAt?: boolean
    trustScore?: boolean
    completenessScore?: boolean
    isHighlighted?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    status?: boolean
    firstName?: boolean
    lastName?: boolean
    gender?: boolean
    dateOfBirth?: boolean
    height?: boolean
    maritalStatus?: boolean
    religion?: boolean
    caste?: boolean
    motherTongue?: boolean
    manglik?: boolean
    gothra?: boolean
    country?: boolean
    state?: boolean
    city?: boolean
    citizenship?: boolean
    education?: boolean
    college?: boolean
    occupation?: boolean
    income?: boolean
    incomeCurrency?: boolean
    fatherOccupation?: boolean
    motherOccupation?: boolean
    siblings?: boolean
    familyType?: boolean
    diet?: boolean
    smoking?: boolean
    drinking?: boolean
    hobbies?: boolean
    partnerPreferences?: boolean
    videoIntroUrl?: boolean
    biodataUrl?: boolean
    aboutMe?: boolean
    highlights?: boolean
    latitude?: boolean
    longitude?: boolean
    privacySettings?: boolean
    isHiddenFromSearch?: boolean
    isAnonymousViewing?: boolean
    contactPrivacyLevel?: boolean
    photoPrivacyLevel?: boolean
    isVerified?: boolean
    verifiedAt?: boolean
    trustScore?: boolean
    completenessScore?: boolean
    isHighlighted?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos?: boolean | Profile$photosArgs<ExtArgs>
    profileViews?: boolean | Profile$profileViewsArgs<ExtArgs>
    shortlistedBy?: boolean | Profile$shortlistedByArgs<ExtArgs>
    horoscope?: boolean | Profile$horoscopeArgs<ExtArgs>
    comparisons?: boolean | Profile$comparisonsArgs<ExtArgs>
    testimonials?: boolean | Profile$testimonialsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profile"
    objects: {
      photos: Prisma.$PhotoPayload<ExtArgs>[]
      profileViews: Prisma.$ProfileViewPayload<ExtArgs>[]
      shortlistedBy: Prisma.$ShortlistPayload<ExtArgs>[]
      horoscope: Prisma.$HoroscopePayload<ExtArgs> | null
      comparisons: Prisma.$ProfileComparisonPayload<ExtArgs>[]
      testimonials: Prisma.$TestimonialPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      status: $Enums.ProfileStatus
      firstName: string | null
      lastName: string | null
      gender: $Enums.Gender | null
      dateOfBirth: Date | null
      height: number | null
      maritalStatus: $Enums.MaritalStatus | null
      religion: string | null
      caste: string | null
      motherTongue: string | null
      manglik: boolean | null
      gothra: string | null
      country: string | null
      state: string | null
      city: string | null
      citizenship: string | null
      education: string | null
      college: string | null
      occupation: string | null
      income: number | null
      incomeCurrency: string | null
      fatherOccupation: string | null
      motherOccupation: string | null
      siblings: number | null
      familyType: $Enums.FamilyType | null
      diet: $Enums.Diet | null
      smoking: boolean | null
      drinking: boolean | null
      hobbies: string | null
      partnerPreferences: Prisma.JsonValue | null
      videoIntroUrl: string | null
      biodataUrl: string | null
      aboutMe: string | null
      highlights: Prisma.JsonValue | null
      latitude: number | null
      longitude: number | null
      privacySettings: Prisma.JsonValue | null
      isHiddenFromSearch: boolean
      isAnonymousViewing: boolean
      contactPrivacyLevel: string | null
      photoPrivacyLevel: string | null
      isVerified: boolean
      verifiedAt: Date | null
      trustScore: number
      completenessScore: number
      isHighlighted: boolean
      slug: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }

  type ProfileGetPayload<S extends boolean | null | undefined | ProfileDefaultArgs> = $Result.GetResult<Prisma.$ProfilePayload, S>

  type ProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profile'], meta: { name: 'Profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileFindUniqueArgs>(args: SelectSubset<T, ProfileFindUniqueArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileFindFirstArgs>(args?: SelectSubset<T, ProfileFindFirstArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileFindManyArgs>(args?: SelectSubset<T, ProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
     */
    create<T extends ProfileCreateArgs>(args: SelectSubset<T, ProfileCreateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Profiles.
     * @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileCreateManyArgs>(args?: SelectSubset<T, ProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profiles and returns the data saved in the database.
     * @param {ProfileCreateManyAndReturnArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
     */
    delete<T extends ProfileDeleteArgs>(args: SelectSubset<T, ProfileDeleteArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileUpdateArgs>(args: SelectSubset<T, ProfileUpdateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileDeleteManyArgs>(args?: SelectSubset<T, ProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileUpdateManyArgs>(args: SelectSubset<T, ProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
     */
    upsert<T extends ProfileUpsertArgs>(args: SelectSubset<T, ProfileUpsertArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profile model
   */
  readonly fields: ProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    photos<T extends Profile$photosArgs<ExtArgs> = {}>(args?: Subset<T, Profile$photosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "findMany"> | Null>
    profileViews<T extends Profile$profileViewsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$profileViewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileViewPayload<ExtArgs>, T, "findMany"> | Null>
    shortlistedBy<T extends Profile$shortlistedByArgs<ExtArgs> = {}>(args?: Subset<T, Profile$shortlistedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShortlistPayload<ExtArgs>, T, "findMany"> | Null>
    horoscope<T extends Profile$horoscopeArgs<ExtArgs> = {}>(args?: Subset<T, Profile$horoscopeArgs<ExtArgs>>): Prisma__HoroscopeClient<$Result.GetResult<Prisma.$HoroscopePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    comparisons<T extends Profile$comparisonsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$comparisonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileComparisonPayload<ExtArgs>, T, "findMany"> | Null>
    testimonials<T extends Profile$testimonialsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$testimonialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findMany"> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profile model
   */ 
  interface ProfileFieldRefs {
    readonly id: FieldRef<"Profile", 'String'>
    readonly userId: FieldRef<"Profile", 'String'>
    readonly status: FieldRef<"Profile", 'ProfileStatus'>
    readonly firstName: FieldRef<"Profile", 'String'>
    readonly lastName: FieldRef<"Profile", 'String'>
    readonly gender: FieldRef<"Profile", 'Gender'>
    readonly dateOfBirth: FieldRef<"Profile", 'DateTime'>
    readonly height: FieldRef<"Profile", 'Int'>
    readonly maritalStatus: FieldRef<"Profile", 'MaritalStatus'>
    readonly religion: FieldRef<"Profile", 'String'>
    readonly caste: FieldRef<"Profile", 'String'>
    readonly motherTongue: FieldRef<"Profile", 'String'>
    readonly manglik: FieldRef<"Profile", 'Boolean'>
    readonly gothra: FieldRef<"Profile", 'String'>
    readonly country: FieldRef<"Profile", 'String'>
    readonly state: FieldRef<"Profile", 'String'>
    readonly city: FieldRef<"Profile", 'String'>
    readonly citizenship: FieldRef<"Profile", 'String'>
    readonly education: FieldRef<"Profile", 'String'>
    readonly college: FieldRef<"Profile", 'String'>
    readonly occupation: FieldRef<"Profile", 'String'>
    readonly income: FieldRef<"Profile", 'Int'>
    readonly incomeCurrency: FieldRef<"Profile", 'String'>
    readonly fatherOccupation: FieldRef<"Profile", 'String'>
    readonly motherOccupation: FieldRef<"Profile", 'String'>
    readonly siblings: FieldRef<"Profile", 'Int'>
    readonly familyType: FieldRef<"Profile", 'FamilyType'>
    readonly diet: FieldRef<"Profile", 'Diet'>
    readonly smoking: FieldRef<"Profile", 'Boolean'>
    readonly drinking: FieldRef<"Profile", 'Boolean'>
    readonly hobbies: FieldRef<"Profile", 'String'>
    readonly partnerPreferences: FieldRef<"Profile", 'Json'>
    readonly videoIntroUrl: FieldRef<"Profile", 'String'>
    readonly biodataUrl: FieldRef<"Profile", 'String'>
    readonly aboutMe: FieldRef<"Profile", 'String'>
    readonly highlights: FieldRef<"Profile", 'Json'>
    readonly latitude: FieldRef<"Profile", 'Float'>
    readonly longitude: FieldRef<"Profile", 'Float'>
    readonly privacySettings: FieldRef<"Profile", 'Json'>
    readonly isHiddenFromSearch: FieldRef<"Profile", 'Boolean'>
    readonly isAnonymousViewing: FieldRef<"Profile", 'Boolean'>
    readonly contactPrivacyLevel: FieldRef<"Profile", 'String'>
    readonly photoPrivacyLevel: FieldRef<"Profile", 'String'>
    readonly isVerified: FieldRef<"Profile", 'Boolean'>
    readonly verifiedAt: FieldRef<"Profile", 'DateTime'>
    readonly trustScore: FieldRef<"Profile", 'Int'>
    readonly completenessScore: FieldRef<"Profile", 'Int'>
    readonly isHighlighted: FieldRef<"Profile", 'Boolean'>
    readonly slug: FieldRef<"Profile", 'String'>
    readonly createdAt: FieldRef<"Profile", 'DateTime'>
    readonly updatedAt: FieldRef<"Profile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile create
   */
  export type ProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a Profile.
     */
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }

  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profile createManyAndReturn
   */
  export type ProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profile update
   */
  export type ProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
  }

  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }

  /**
   * Profile delete
   */
  export type ProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
  }

  /**
   * Profile.photos
   */
  export type Profile$photosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
    where?: PhotoWhereInput
    orderBy?: PhotoOrderByWithRelationInput | PhotoOrderByWithRelationInput[]
    cursor?: PhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PhotoScalarFieldEnum | PhotoScalarFieldEnum[]
  }

  /**
   * Profile.profileViews
   */
  export type Profile$profileViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileView
     */
    select?: ProfileViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileViewInclude<ExtArgs> | null
    where?: ProfileViewWhereInput
    orderBy?: ProfileViewOrderByWithRelationInput | ProfileViewOrderByWithRelationInput[]
    cursor?: ProfileViewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileViewScalarFieldEnum | ProfileViewScalarFieldEnum[]
  }

  /**
   * Profile.shortlistedBy
   */
  export type Profile$shortlistedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shortlist
     */
    select?: ShortlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShortlistInclude<ExtArgs> | null
    where?: ShortlistWhereInput
    orderBy?: ShortlistOrderByWithRelationInput | ShortlistOrderByWithRelationInput[]
    cursor?: ShortlistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShortlistScalarFieldEnum | ShortlistScalarFieldEnum[]
  }

  /**
   * Profile.horoscope
   */
  export type Profile$horoscopeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Horoscope
     */
    select?: HoroscopeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoroscopeInclude<ExtArgs> | null
    where?: HoroscopeWhereInput
  }

  /**
   * Profile.comparisons
   */
  export type Profile$comparisonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileComparison
     */
    select?: ProfileComparisonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileComparisonInclude<ExtArgs> | null
    where?: ProfileComparisonWhereInput
    orderBy?: ProfileComparisonOrderByWithRelationInput | ProfileComparisonOrderByWithRelationInput[]
    cursor?: ProfileComparisonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileComparisonScalarFieldEnum | ProfileComparisonScalarFieldEnum[]
  }

  /**
   * Profile.testimonials
   */
  export type Profile$testimonialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    where?: TestimonialWhereInput
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    cursor?: TestimonialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * Profile without action
   */
  export type ProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
  }


  /**
   * Model Photo
   */

  export type AggregatePhoto = {
    _count: PhotoCountAggregateOutputType | null
    _avg: PhotoAvgAggregateOutputType | null
    _sum: PhotoSumAggregateOutputType | null
    _min: PhotoMinAggregateOutputType | null
    _max: PhotoMaxAggregateOutputType | null
  }

  export type PhotoAvgAggregateOutputType = {
    order: number | null
  }

  export type PhotoSumAggregateOutputType = {
    order: number | null
  }

  export type PhotoMinAggregateOutputType = {
    id: string | null
    profileId: string | null
    url: string | null
    cloudinaryId: string | null
    isPrimary: boolean | null
    isBlurred: boolean | null
    isApproved: boolean | null
    order: number | null
    albumName: string | null
    caption: string | null
    createdAt: Date | null
  }

  export type PhotoMaxAggregateOutputType = {
    id: string | null
    profileId: string | null
    url: string | null
    cloudinaryId: string | null
    isPrimary: boolean | null
    isBlurred: boolean | null
    isApproved: boolean | null
    order: number | null
    albumName: string | null
    caption: string | null
    createdAt: Date | null
  }

  export type PhotoCountAggregateOutputType = {
    id: number
    profileId: number
    url: number
    cloudinaryId: number
    isPrimary: number
    isBlurred: number
    isApproved: number
    order: number
    albumName: number
    caption: number
    createdAt: number
    _all: number
  }


  export type PhotoAvgAggregateInputType = {
    order?: true
  }

  export type PhotoSumAggregateInputType = {
    order?: true
  }

  export type PhotoMinAggregateInputType = {
    id?: true
    profileId?: true
    url?: true
    cloudinaryId?: true
    isPrimary?: true
    isBlurred?: true
    isApproved?: true
    order?: true
    albumName?: true
    caption?: true
    createdAt?: true
  }

  export type PhotoMaxAggregateInputType = {
    id?: true
    profileId?: true
    url?: true
    cloudinaryId?: true
    isPrimary?: true
    isBlurred?: true
    isApproved?: true
    order?: true
    albumName?: true
    caption?: true
    createdAt?: true
  }

  export type PhotoCountAggregateInputType = {
    id?: true
    profileId?: true
    url?: true
    cloudinaryId?: true
    isPrimary?: true
    isBlurred?: true
    isApproved?: true
    order?: true
    albumName?: true
    caption?: true
    createdAt?: true
    _all?: true
  }

  export type PhotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Photo to aggregate.
     */
    where?: PhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Photos to fetch.
     */
    orderBy?: PhotoOrderByWithRelationInput | PhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Photos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Photos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Photos
    **/
    _count?: true | PhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PhotoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PhotoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhotoMaxAggregateInputType
  }

  export type GetPhotoAggregateType<T extends PhotoAggregateArgs> = {
        [P in keyof T & keyof AggregatePhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhoto[P]>
      : GetScalarType<T[P], AggregatePhoto[P]>
  }




  export type PhotoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhotoWhereInput
    orderBy?: PhotoOrderByWithAggregationInput | PhotoOrderByWithAggregationInput[]
    by: PhotoScalarFieldEnum[] | PhotoScalarFieldEnum
    having?: PhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhotoCountAggregateInputType | true
    _avg?: PhotoAvgAggregateInputType
    _sum?: PhotoSumAggregateInputType
    _min?: PhotoMinAggregateInputType
    _max?: PhotoMaxAggregateInputType
  }

  export type PhotoGroupByOutputType = {
    id: string
    profileId: string
    url: string
    cloudinaryId: string | null
    isPrimary: boolean
    isBlurred: boolean
    isApproved: boolean
    order: number
    albumName: string | null
    caption: string | null
    createdAt: Date
    _count: PhotoCountAggregateOutputType | null
    _avg: PhotoAvgAggregateOutputType | null
    _sum: PhotoSumAggregateOutputType | null
    _min: PhotoMinAggregateOutputType | null
    _max: PhotoMaxAggregateOutputType | null
  }

  type GetPhotoGroupByPayload<T extends PhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhotoGroupByOutputType[P]>
            : GetScalarType<T[P], PhotoGroupByOutputType[P]>
        }
      >
    >


  export type PhotoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    url?: boolean
    cloudinaryId?: boolean
    isPrimary?: boolean
    isBlurred?: boolean
    isApproved?: boolean
    order?: boolean
    albumName?: boolean
    caption?: boolean
    createdAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["photo"]>

  export type PhotoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    url?: boolean
    cloudinaryId?: boolean
    isPrimary?: boolean
    isBlurred?: boolean
    isApproved?: boolean
    order?: boolean
    albumName?: boolean
    caption?: boolean
    createdAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["photo"]>

  export type PhotoSelectScalar = {
    id?: boolean
    profileId?: boolean
    url?: boolean
    cloudinaryId?: boolean
    isPrimary?: boolean
    isBlurred?: boolean
    isApproved?: boolean
    order?: boolean
    albumName?: boolean
    caption?: boolean
    createdAt?: boolean
  }

  export type PhotoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type PhotoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $PhotoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Photo"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profileId: string
      url: string
      cloudinaryId: string | null
      isPrimary: boolean
      isBlurred: boolean
      isApproved: boolean
      order: number
      albumName: string | null
      caption: string | null
      createdAt: Date
    }, ExtArgs["result"]["photo"]>
    composites: {}
  }

  type PhotoGetPayload<S extends boolean | null | undefined | PhotoDefaultArgs> = $Result.GetResult<Prisma.$PhotoPayload, S>

  type PhotoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PhotoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PhotoCountAggregateInputType | true
    }

  export interface PhotoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Photo'], meta: { name: 'Photo' } }
    /**
     * Find zero or one Photo that matches the filter.
     * @param {PhotoFindUniqueArgs} args - Arguments to find a Photo
     * @example
     * // Get one Photo
     * const photo = await prisma.photo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PhotoFindUniqueArgs>(args: SelectSubset<T, PhotoFindUniqueArgs<ExtArgs>>): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Photo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PhotoFindUniqueOrThrowArgs} args - Arguments to find a Photo
     * @example
     * // Get one Photo
     * const photo = await prisma.photo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PhotoFindUniqueOrThrowArgs>(args: SelectSubset<T, PhotoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Photo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoFindFirstArgs} args - Arguments to find a Photo
     * @example
     * // Get one Photo
     * const photo = await prisma.photo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PhotoFindFirstArgs>(args?: SelectSubset<T, PhotoFindFirstArgs<ExtArgs>>): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Photo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoFindFirstOrThrowArgs} args - Arguments to find a Photo
     * @example
     * // Get one Photo
     * const photo = await prisma.photo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PhotoFindFirstOrThrowArgs>(args?: SelectSubset<T, PhotoFindFirstOrThrowArgs<ExtArgs>>): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Photos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Photos
     * const photos = await prisma.photo.findMany()
     * 
     * // Get first 10 Photos
     * const photos = await prisma.photo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const photoWithIdOnly = await prisma.photo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PhotoFindManyArgs>(args?: SelectSubset<T, PhotoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Photo.
     * @param {PhotoCreateArgs} args - Arguments to create a Photo.
     * @example
     * // Create one Photo
     * const Photo = await prisma.photo.create({
     *   data: {
     *     // ... data to create a Photo
     *   }
     * })
     * 
     */
    create<T extends PhotoCreateArgs>(args: SelectSubset<T, PhotoCreateArgs<ExtArgs>>): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Photos.
     * @param {PhotoCreateManyArgs} args - Arguments to create many Photos.
     * @example
     * // Create many Photos
     * const photo = await prisma.photo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PhotoCreateManyArgs>(args?: SelectSubset<T, PhotoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Photos and returns the data saved in the database.
     * @param {PhotoCreateManyAndReturnArgs} args - Arguments to create many Photos.
     * @example
     * // Create many Photos
     * const photo = await prisma.photo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Photos and only return the `id`
     * const photoWithIdOnly = await prisma.photo.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PhotoCreateManyAndReturnArgs>(args?: SelectSubset<T, PhotoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Photo.
     * @param {PhotoDeleteArgs} args - Arguments to delete one Photo.
     * @example
     * // Delete one Photo
     * const Photo = await prisma.photo.delete({
     *   where: {
     *     // ... filter to delete one Photo
     *   }
     * })
     * 
     */
    delete<T extends PhotoDeleteArgs>(args: SelectSubset<T, PhotoDeleteArgs<ExtArgs>>): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Photo.
     * @param {PhotoUpdateArgs} args - Arguments to update one Photo.
     * @example
     * // Update one Photo
     * const photo = await prisma.photo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PhotoUpdateArgs>(args: SelectSubset<T, PhotoUpdateArgs<ExtArgs>>): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Photos.
     * @param {PhotoDeleteManyArgs} args - Arguments to filter Photos to delete.
     * @example
     * // Delete a few Photos
     * const { count } = await prisma.photo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PhotoDeleteManyArgs>(args?: SelectSubset<T, PhotoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Photos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Photos
     * const photo = await prisma.photo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PhotoUpdateManyArgs>(args: SelectSubset<T, PhotoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Photo.
     * @param {PhotoUpsertArgs} args - Arguments to update or create a Photo.
     * @example
     * // Update or create a Photo
     * const photo = await prisma.photo.upsert({
     *   create: {
     *     // ... data to create a Photo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Photo we want to update
     *   }
     * })
     */
    upsert<T extends PhotoUpsertArgs>(args: SelectSubset<T, PhotoUpsertArgs<ExtArgs>>): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Photos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoCountArgs} args - Arguments to filter Photos to count.
     * @example
     * // Count the number of Photos
     * const count = await prisma.photo.count({
     *   where: {
     *     // ... the filter for the Photos we want to count
     *   }
     * })
    **/
    count<T extends PhotoCountArgs>(
      args?: Subset<T, PhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Photo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhotoAggregateArgs>(args: Subset<T, PhotoAggregateArgs>): Prisma.PrismaPromise<GetPhotoAggregateType<T>>

    /**
     * Group by Photo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhotoGroupByArgs['orderBy'] }
        : { orderBy?: PhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Photo model
   */
  readonly fields: PhotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Photo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PhotoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Photo model
   */ 
  interface PhotoFieldRefs {
    readonly id: FieldRef<"Photo", 'String'>
    readonly profileId: FieldRef<"Photo", 'String'>
    readonly url: FieldRef<"Photo", 'String'>
    readonly cloudinaryId: FieldRef<"Photo", 'String'>
    readonly isPrimary: FieldRef<"Photo", 'Boolean'>
    readonly isBlurred: FieldRef<"Photo", 'Boolean'>
    readonly isApproved: FieldRef<"Photo", 'Boolean'>
    readonly order: FieldRef<"Photo", 'Int'>
    readonly albumName: FieldRef<"Photo", 'String'>
    readonly caption: FieldRef<"Photo", 'String'>
    readonly createdAt: FieldRef<"Photo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Photo findUnique
   */
  export type PhotoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * Filter, which Photo to fetch.
     */
    where: PhotoWhereUniqueInput
  }

  /**
   * Photo findUniqueOrThrow
   */
  export type PhotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * Filter, which Photo to fetch.
     */
    where: PhotoWhereUniqueInput
  }

  /**
   * Photo findFirst
   */
  export type PhotoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * Filter, which Photo to fetch.
     */
    where?: PhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Photos to fetch.
     */
    orderBy?: PhotoOrderByWithRelationInput | PhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Photos.
     */
    cursor?: PhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Photos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Photos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Photos.
     */
    distinct?: PhotoScalarFieldEnum | PhotoScalarFieldEnum[]
  }

  /**
   * Photo findFirstOrThrow
   */
  export type PhotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * Filter, which Photo to fetch.
     */
    where?: PhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Photos to fetch.
     */
    orderBy?: PhotoOrderByWithRelationInput | PhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Photos.
     */
    cursor?: PhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Photos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Photos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Photos.
     */
    distinct?: PhotoScalarFieldEnum | PhotoScalarFieldEnum[]
  }

  /**
   * Photo findMany
   */
  export type PhotoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * Filter, which Photos to fetch.
     */
    where?: PhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Photos to fetch.
     */
    orderBy?: PhotoOrderByWithRelationInput | PhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Photos.
     */
    cursor?: PhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Photos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Photos.
     */
    skip?: number
    distinct?: PhotoScalarFieldEnum | PhotoScalarFieldEnum[]
  }

  /**
   * Photo create
   */
  export type PhotoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * The data needed to create a Photo.
     */
    data: XOR<PhotoCreateInput, PhotoUncheckedCreateInput>
  }

  /**
   * Photo createMany
   */
  export type PhotoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Photos.
     */
    data: PhotoCreateManyInput | PhotoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Photo createManyAndReturn
   */
  export type PhotoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Photos.
     */
    data: PhotoCreateManyInput | PhotoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Photo update
   */
  export type PhotoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * The data needed to update a Photo.
     */
    data: XOR<PhotoUpdateInput, PhotoUncheckedUpdateInput>
    /**
     * Choose, which Photo to update.
     */
    where: PhotoWhereUniqueInput
  }

  /**
   * Photo updateMany
   */
  export type PhotoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Photos.
     */
    data: XOR<PhotoUpdateManyMutationInput, PhotoUncheckedUpdateManyInput>
    /**
     * Filter which Photos to update
     */
    where?: PhotoWhereInput
  }

  /**
   * Photo upsert
   */
  export type PhotoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * The filter to search for the Photo to update in case it exists.
     */
    where: PhotoWhereUniqueInput
    /**
     * In case the Photo found by the `where` argument doesn't exist, create a new Photo with this data.
     */
    create: XOR<PhotoCreateInput, PhotoUncheckedCreateInput>
    /**
     * In case the Photo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PhotoUpdateInput, PhotoUncheckedUpdateInput>
  }

  /**
   * Photo delete
   */
  export type PhotoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * Filter which Photo to delete.
     */
    where: PhotoWhereUniqueInput
  }

  /**
   * Photo deleteMany
   */
  export type PhotoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Photos to delete
     */
    where?: PhotoWhereInput
  }

  /**
   * Photo without action
   */
  export type PhotoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
  }


  /**
   * Model Verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    idType: string | null
    idNumber: string | null
    idPhotoUrl: string | null
    selfieUrl: string | null
    status: string | null
    reviewedBy: string | null
    reviewedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    idType: string | null
    idNumber: string | null
    idPhotoUrl: string | null
    selfieUrl: string | null
    status: string | null
    reviewedBy: string | null
    reviewedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    userId: number
    idType: number
    idNumber: number
    idPhotoUrl: number
    selfieUrl: number
    status: number
    reviewedBy: number
    reviewedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerificationMinAggregateInputType = {
    id?: true
    userId?: true
    idType?: true
    idNumber?: true
    idPhotoUrl?: true
    selfieUrl?: true
    status?: true
    reviewedBy?: true
    reviewedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    userId?: true
    idType?: true
    idNumber?: true
    idPhotoUrl?: true
    selfieUrl?: true
    status?: true
    reviewedBy?: true
    reviewedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    userId?: true
    idType?: true
    idNumber?: true
    idPhotoUrl?: true
    selfieUrl?: true
    status?: true
    reviewedBy?: true
    reviewedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verification to aggregate.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type VerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationWhereInput
    orderBy?: VerificationOrderByWithAggregationInput | VerificationOrderByWithAggregationInput[]
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum
    having?: VerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }

  export type VerificationGroupByOutputType = {
    id: string
    userId: string
    idType: string
    idNumber: string | null
    idPhotoUrl: string | null
    selfieUrl: string | null
    status: string
    reviewedBy: string | null
    reviewedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends VerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type VerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    idType?: boolean
    idNumber?: boolean
    idPhotoUrl?: boolean
    selfieUrl?: boolean
    status?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    idType?: boolean
    idNumber?: boolean
    idPhotoUrl?: boolean
    selfieUrl?: boolean
    status?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectScalar = {
    id?: boolean
    userId?: boolean
    idType?: boolean
    idNumber?: boolean
    idPhotoUrl?: boolean
    selfieUrl?: boolean
    status?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $VerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      idType: string
      idNumber: string | null
      idPhotoUrl: string | null
      selfieUrl: string | null
      status: string
      reviewedBy: string | null
      reviewedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["verification"]>
    composites: {}
  }

  type VerificationGetPayload<S extends boolean | null | undefined | VerificationDefaultArgs> = $Result.GetResult<Prisma.$VerificationPayload, S>

  type VerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VerificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VerificationCountAggregateInputType | true
    }

  export interface VerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verification'], meta: { name: 'Verification' } }
    /**
     * Find zero or one Verification that matches the filter.
     * @param {VerificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationFindUniqueArgs>(args: SelectSubset<T, VerificationFindUniqueArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VerificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationFindFirstArgs>(args?: SelectSubset<T, VerificationFindFirstArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationFindManyArgs>(args?: SelectSubset<T, VerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Verification.
     * @param {VerificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
     */
    create<T extends VerificationCreateArgs>(args: SelectSubset<T, VerificationCreateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Verifications.
     * @param {VerificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCreateManyArgs>(args?: SelectSubset<T, VerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verifications and returns the data saved in the database.
     * @param {VerificationCreateManyAndReturnArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Verification.
     * @param {VerificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
     */
    delete<T extends VerificationDeleteArgs>(args: SelectSubset<T, VerificationDeleteArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Verification.
     * @param {VerificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationUpdateArgs>(args: SelectSubset<T, VerificationUpdateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Verifications.
     * @param {VerificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationDeleteManyArgs>(args?: SelectSubset<T, VerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationUpdateManyArgs>(args: SelectSubset<T, VerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Verification.
     * @param {VerificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends VerificationUpsertArgs>(args: SelectSubset<T, VerificationUpsertArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends VerificationCountArgs>(
      args?: Subset<T, VerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): Prisma.PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGroupByArgs['orderBy'] }
        : { orderBy?: VerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verification model
   */
  readonly fields: VerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verification model
   */ 
  interface VerificationFieldRefs {
    readonly id: FieldRef<"Verification", 'String'>
    readonly userId: FieldRef<"Verification", 'String'>
    readonly idType: FieldRef<"Verification", 'String'>
    readonly idNumber: FieldRef<"Verification", 'String'>
    readonly idPhotoUrl: FieldRef<"Verification", 'String'>
    readonly selfieUrl: FieldRef<"Verification", 'String'>
    readonly status: FieldRef<"Verification", 'String'>
    readonly reviewedBy: FieldRef<"Verification", 'String'>
    readonly reviewedAt: FieldRef<"Verification", 'DateTime'>
    readonly createdAt: FieldRef<"Verification", 'DateTime'>
    readonly updatedAt: FieldRef<"Verification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Verification findUnique
   */
  export type VerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findUniqueOrThrow
   */
  export type VerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findFirst
   */
  export type VerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findFirstOrThrow
   */
  export type VerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findMany
   */
  export type VerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Filter, which Verifications to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification create
   */
  export type VerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * The data needed to create a Verification.
     */
    data: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
  }

  /**
   * Verification createMany
   */
  export type VerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification createManyAndReturn
   */
  export type VerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification update
   */
  export type VerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * The data needed to update a Verification.
     */
    data: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
    /**
     * Choose, which Verification to update.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification updateMany
   */
  export type VerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
  }

  /**
   * Verification upsert
   */
  export type VerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * The filter to search for the Verification to update in case it exists.
     */
    where: VerificationWhereUniqueInput
    /**
     * In case the Verification found by the `where` argument doesn't exist, create a new Verification with this data.
     */
    create: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
    /**
     * In case the Verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
  }

  /**
   * Verification delete
   */
  export type VerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Filter which Verification to delete.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification deleteMany
   */
  export type VerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verifications to delete
     */
    where?: VerificationWhereInput
  }

  /**
   * Verification without action
   */
  export type VerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
  }


  /**
   * Model Interest
   */

  export type AggregateInterest = {
    _count: InterestCountAggregateOutputType | null
    _min: InterestMinAggregateOutputType | null
    _max: InterestMaxAggregateOutputType | null
  }

  export type InterestMinAggregateOutputType = {
    id: string | null
    fromUserId: string | null
    toUserId: string | null
    status: $Enums.InterestStatus | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InterestMaxAggregateOutputType = {
    id: string | null
    fromUserId: string | null
    toUserId: string | null
    status: $Enums.InterestStatus | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InterestCountAggregateOutputType = {
    id: number
    fromUserId: number
    toUserId: number
    status: number
    message: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InterestMinAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
    status?: true
    message?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InterestMaxAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
    status?: true
    message?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InterestCountAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
    status?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InterestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Interest to aggregate.
     */
    where?: InterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interests to fetch.
     */
    orderBy?: InterestOrderByWithRelationInput | InterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Interests
    **/
    _count?: true | InterestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterestMaxAggregateInputType
  }

  export type GetInterestAggregateType<T extends InterestAggregateArgs> = {
        [P in keyof T & keyof AggregateInterest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInterest[P]>
      : GetScalarType<T[P], AggregateInterest[P]>
  }




  export type InterestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterestWhereInput
    orderBy?: InterestOrderByWithAggregationInput | InterestOrderByWithAggregationInput[]
    by: InterestScalarFieldEnum[] | InterestScalarFieldEnum
    having?: InterestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterestCountAggregateInputType | true
    _min?: InterestMinAggregateInputType
    _max?: InterestMaxAggregateInputType
  }

  export type InterestGroupByOutputType = {
    id: string
    fromUserId: string
    toUserId: string
    status: $Enums.InterestStatus
    message: string | null
    createdAt: Date
    updatedAt: Date
    _count: InterestCountAggregateOutputType | null
    _min: InterestMinAggregateOutputType | null
    _max: InterestMaxAggregateOutputType | null
  }

  type GetInterestGroupByPayload<T extends InterestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InterestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterestGroupByOutputType[P]>
            : GetScalarType<T[P], InterestGroupByOutputType[P]>
        }
      >
    >


  export type InterestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromUserId?: boolean
    toUserId?: boolean
    status?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fromUser?: boolean | UserDefaultArgs<ExtArgs>
    toUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interest"]>

  export type InterestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromUserId?: boolean
    toUserId?: boolean
    status?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fromUser?: boolean | UserDefaultArgs<ExtArgs>
    toUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interest"]>

  export type InterestSelectScalar = {
    id?: boolean
    fromUserId?: boolean
    toUserId?: boolean
    status?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InterestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromUser?: boolean | UserDefaultArgs<ExtArgs>
    toUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InterestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromUser?: boolean | UserDefaultArgs<ExtArgs>
    toUser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InterestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Interest"
    objects: {
      fromUser: Prisma.$UserPayload<ExtArgs>
      toUser: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fromUserId: string
      toUserId: string
      status: $Enums.InterestStatus
      message: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["interest"]>
    composites: {}
  }

  type InterestGetPayload<S extends boolean | null | undefined | InterestDefaultArgs> = $Result.GetResult<Prisma.$InterestPayload, S>

  type InterestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InterestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InterestCountAggregateInputType | true
    }

  export interface InterestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Interest'], meta: { name: 'Interest' } }
    /**
     * Find zero or one Interest that matches the filter.
     * @param {InterestFindUniqueArgs} args - Arguments to find a Interest
     * @example
     * // Get one Interest
     * const interest = await prisma.interest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InterestFindUniqueArgs>(args: SelectSubset<T, InterestFindUniqueArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Interest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InterestFindUniqueOrThrowArgs} args - Arguments to find a Interest
     * @example
     * // Get one Interest
     * const interest = await prisma.interest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InterestFindUniqueOrThrowArgs>(args: SelectSubset<T, InterestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Interest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestFindFirstArgs} args - Arguments to find a Interest
     * @example
     * // Get one Interest
     * const interest = await prisma.interest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InterestFindFirstArgs>(args?: SelectSubset<T, InterestFindFirstArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Interest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestFindFirstOrThrowArgs} args - Arguments to find a Interest
     * @example
     * // Get one Interest
     * const interest = await prisma.interest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InterestFindFirstOrThrowArgs>(args?: SelectSubset<T, InterestFindFirstOrThrowArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Interests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Interests
     * const interests = await prisma.interest.findMany()
     * 
     * // Get first 10 Interests
     * const interests = await prisma.interest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interestWithIdOnly = await prisma.interest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InterestFindManyArgs>(args?: SelectSubset<T, InterestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Interest.
     * @param {InterestCreateArgs} args - Arguments to create a Interest.
     * @example
     * // Create one Interest
     * const Interest = await prisma.interest.create({
     *   data: {
     *     // ... data to create a Interest
     *   }
     * })
     * 
     */
    create<T extends InterestCreateArgs>(args: SelectSubset<T, InterestCreateArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Interests.
     * @param {InterestCreateManyArgs} args - Arguments to create many Interests.
     * @example
     * // Create many Interests
     * const interest = await prisma.interest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InterestCreateManyArgs>(args?: SelectSubset<T, InterestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Interests and returns the data saved in the database.
     * @param {InterestCreateManyAndReturnArgs} args - Arguments to create many Interests.
     * @example
     * // Create many Interests
     * const interest = await prisma.interest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Interests and only return the `id`
     * const interestWithIdOnly = await prisma.interest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InterestCreateManyAndReturnArgs>(args?: SelectSubset<T, InterestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Interest.
     * @param {InterestDeleteArgs} args - Arguments to delete one Interest.
     * @example
     * // Delete one Interest
     * const Interest = await prisma.interest.delete({
     *   where: {
     *     // ... filter to delete one Interest
     *   }
     * })
     * 
     */
    delete<T extends InterestDeleteArgs>(args: SelectSubset<T, InterestDeleteArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Interest.
     * @param {InterestUpdateArgs} args - Arguments to update one Interest.
     * @example
     * // Update one Interest
     * const interest = await prisma.interest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InterestUpdateArgs>(args: SelectSubset<T, InterestUpdateArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Interests.
     * @param {InterestDeleteManyArgs} args - Arguments to filter Interests to delete.
     * @example
     * // Delete a few Interests
     * const { count } = await prisma.interest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InterestDeleteManyArgs>(args?: SelectSubset<T, InterestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Interests
     * const interest = await prisma.interest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InterestUpdateManyArgs>(args: SelectSubset<T, InterestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Interest.
     * @param {InterestUpsertArgs} args - Arguments to update or create a Interest.
     * @example
     * // Update or create a Interest
     * const interest = await prisma.interest.upsert({
     *   create: {
     *     // ... data to create a Interest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Interest we want to update
     *   }
     * })
     */
    upsert<T extends InterestUpsertArgs>(args: SelectSubset<T, InterestUpsertArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Interests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestCountArgs} args - Arguments to filter Interests to count.
     * @example
     * // Count the number of Interests
     * const count = await prisma.interest.count({
     *   where: {
     *     // ... the filter for the Interests we want to count
     *   }
     * })
    **/
    count<T extends InterestCountArgs>(
      args?: Subset<T, InterestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Interest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterestAggregateArgs>(args: Subset<T, InterestAggregateArgs>): Prisma.PrismaPromise<GetInterestAggregateType<T>>

    /**
     * Group by Interest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterestGroupByArgs['orderBy'] }
        : { orderBy?: InterestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Interest model
   */
  readonly fields: InterestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Interest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InterestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fromUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    toUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Interest model
   */ 
  interface InterestFieldRefs {
    readonly id: FieldRef<"Interest", 'String'>
    readonly fromUserId: FieldRef<"Interest", 'String'>
    readonly toUserId: FieldRef<"Interest", 'String'>
    readonly status: FieldRef<"Interest", 'InterestStatus'>
    readonly message: FieldRef<"Interest", 'String'>
    readonly createdAt: FieldRef<"Interest", 'DateTime'>
    readonly updatedAt: FieldRef<"Interest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Interest findUnique
   */
  export type InterestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * Filter, which Interest to fetch.
     */
    where: InterestWhereUniqueInput
  }

  /**
   * Interest findUniqueOrThrow
   */
  export type InterestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * Filter, which Interest to fetch.
     */
    where: InterestWhereUniqueInput
  }

  /**
   * Interest findFirst
   */
  export type InterestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * Filter, which Interest to fetch.
     */
    where?: InterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interests to fetch.
     */
    orderBy?: InterestOrderByWithRelationInput | InterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interests.
     */
    cursor?: InterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interests.
     */
    distinct?: InterestScalarFieldEnum | InterestScalarFieldEnum[]
  }

  /**
   * Interest findFirstOrThrow
   */
  export type InterestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * Filter, which Interest to fetch.
     */
    where?: InterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interests to fetch.
     */
    orderBy?: InterestOrderByWithRelationInput | InterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interests.
     */
    cursor?: InterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interests.
     */
    distinct?: InterestScalarFieldEnum | InterestScalarFieldEnum[]
  }

  /**
   * Interest findMany
   */
  export type InterestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * Filter, which Interests to fetch.
     */
    where?: InterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interests to fetch.
     */
    orderBy?: InterestOrderByWithRelationInput | InterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Interests.
     */
    cursor?: InterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interests.
     */
    skip?: number
    distinct?: InterestScalarFieldEnum | InterestScalarFieldEnum[]
  }

  /**
   * Interest create
   */
  export type InterestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * The data needed to create a Interest.
     */
    data: XOR<InterestCreateInput, InterestUncheckedCreateInput>
  }

  /**
   * Interest createMany
   */
  export type InterestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Interests.
     */
    data: InterestCreateManyInput | InterestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Interest createManyAndReturn
   */
  export type InterestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Interests.
     */
    data: InterestCreateManyInput | InterestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Interest update
   */
  export type InterestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * The data needed to update a Interest.
     */
    data: XOR<InterestUpdateInput, InterestUncheckedUpdateInput>
    /**
     * Choose, which Interest to update.
     */
    where: InterestWhereUniqueInput
  }

  /**
   * Interest updateMany
   */
  export type InterestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Interests.
     */
    data: XOR<InterestUpdateManyMutationInput, InterestUncheckedUpdateManyInput>
    /**
     * Filter which Interests to update
     */
    where?: InterestWhereInput
  }

  /**
   * Interest upsert
   */
  export type InterestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * The filter to search for the Interest to update in case it exists.
     */
    where: InterestWhereUniqueInput
    /**
     * In case the Interest found by the `where` argument doesn't exist, create a new Interest with this data.
     */
    create: XOR<InterestCreateInput, InterestUncheckedCreateInput>
    /**
     * In case the Interest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterestUpdateInput, InterestUncheckedUpdateInput>
  }

  /**
   * Interest delete
   */
  export type InterestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * Filter which Interest to delete.
     */
    where: InterestWhereUniqueInput
  }

  /**
   * Interest deleteMany
   */
  export type InterestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Interests to delete
     */
    where?: InterestWhereInput
  }

  /**
   * Interest without action
   */
  export type InterestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
  }


  /**
   * Model Chat
   */

  export type AggregateChat = {
    _count: ChatCountAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  export type ChatMinAggregateOutputType = {
    id: string | null
    user1Id: string | null
    user2Id: string | null
    lastMessageAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChatMaxAggregateOutputType = {
    id: string | null
    user1Id: string | null
    user2Id: string | null
    lastMessageAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChatCountAggregateOutputType = {
    id: number
    user1Id: number
    user2Id: number
    lastMessageAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChatMinAggregateInputType = {
    id?: true
    user1Id?: true
    user2Id?: true
    lastMessageAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChatMaxAggregateInputType = {
    id?: true
    user1Id?: true
    user2Id?: true
    lastMessageAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChatCountAggregateInputType = {
    id?: true
    user1Id?: true
    user2Id?: true
    lastMessageAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chat to aggregate.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chats
    **/
    _count?: true | ChatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMaxAggregateInputType
  }

  export type GetChatAggregateType<T extends ChatAggregateArgs> = {
        [P in keyof T & keyof AggregateChat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChat[P]>
      : GetScalarType<T[P], AggregateChat[P]>
  }




  export type ChatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithAggregationInput | ChatOrderByWithAggregationInput[]
    by: ChatScalarFieldEnum[] | ChatScalarFieldEnum
    having?: ChatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatCountAggregateInputType | true
    _min?: ChatMinAggregateInputType
    _max?: ChatMaxAggregateInputType
  }

  export type ChatGroupByOutputType = {
    id: string
    user1Id: string
    user2Id: string
    lastMessageAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ChatCountAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  type GetChatGroupByPayload<T extends ChatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatGroupByOutputType[P]>
            : GetScalarType<T[P], ChatGroupByOutputType[P]>
        }
      >
    >


  export type ChatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user1Id?: boolean
    user2Id?: boolean
    lastMessageAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user1?: boolean | UserDefaultArgs<ExtArgs>
    user2?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | Chat$messagesArgs<ExtArgs>
    _count?: boolean | ChatCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chat"]>

  export type ChatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user1Id?: boolean
    user2Id?: boolean
    lastMessageAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user1?: boolean | UserDefaultArgs<ExtArgs>
    user2?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chat"]>

  export type ChatSelectScalar = {
    id?: boolean
    user1Id?: boolean
    user2Id?: boolean
    lastMessageAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user1?: boolean | UserDefaultArgs<ExtArgs>
    user2?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | Chat$messagesArgs<ExtArgs>
    _count?: boolean | ChatCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user1?: boolean | UserDefaultArgs<ExtArgs>
    user2?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chat"
    objects: {
      user1: Prisma.$UserPayload<ExtArgs>
      user2: Prisma.$UserPayload<ExtArgs>
      messages: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user1Id: string
      user2Id: string
      lastMessageAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["chat"]>
    composites: {}
  }

  type ChatGetPayload<S extends boolean | null | undefined | ChatDefaultArgs> = $Result.GetResult<Prisma.$ChatPayload, S>

  type ChatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChatFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChatCountAggregateInputType | true
    }

  export interface ChatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chat'], meta: { name: 'Chat' } }
    /**
     * Find zero or one Chat that matches the filter.
     * @param {ChatFindUniqueArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatFindUniqueArgs>(args: SelectSubset<T, ChatFindUniqueArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Chat that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChatFindUniqueOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Chat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatFindFirstArgs>(args?: SelectSubset<T, ChatFindFirstArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Chat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Chats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chats
     * const chats = await prisma.chat.findMany()
     * 
     * // Get first 10 Chats
     * const chats = await prisma.chat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatWithIdOnly = await prisma.chat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatFindManyArgs>(args?: SelectSubset<T, ChatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Chat.
     * @param {ChatCreateArgs} args - Arguments to create a Chat.
     * @example
     * // Create one Chat
     * const Chat = await prisma.chat.create({
     *   data: {
     *     // ... data to create a Chat
     *   }
     * })
     * 
     */
    create<T extends ChatCreateArgs>(args: SelectSubset<T, ChatCreateArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Chats.
     * @param {ChatCreateManyArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chat = await prisma.chat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatCreateManyArgs>(args?: SelectSubset<T, ChatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chats and returns the data saved in the database.
     * @param {ChatCreateManyAndReturnArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chat = await prisma.chat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chats and only return the `id`
     * const chatWithIdOnly = await prisma.chat.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Chat.
     * @param {ChatDeleteArgs} args - Arguments to delete one Chat.
     * @example
     * // Delete one Chat
     * const Chat = await prisma.chat.delete({
     *   where: {
     *     // ... filter to delete one Chat
     *   }
     * })
     * 
     */
    delete<T extends ChatDeleteArgs>(args: SelectSubset<T, ChatDeleteArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Chat.
     * @param {ChatUpdateArgs} args - Arguments to update one Chat.
     * @example
     * // Update one Chat
     * const chat = await prisma.chat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatUpdateArgs>(args: SelectSubset<T, ChatUpdateArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Chats.
     * @param {ChatDeleteManyArgs} args - Arguments to filter Chats to delete.
     * @example
     * // Delete a few Chats
     * const { count } = await prisma.chat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatDeleteManyArgs>(args?: SelectSubset<T, ChatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chats
     * const chat = await prisma.chat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatUpdateManyArgs>(args: SelectSubset<T, ChatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chat.
     * @param {ChatUpsertArgs} args - Arguments to update or create a Chat.
     * @example
     * // Update or create a Chat
     * const chat = await prisma.chat.upsert({
     *   create: {
     *     // ... data to create a Chat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chat we want to update
     *   }
     * })
     */
    upsert<T extends ChatUpsertArgs>(args: SelectSubset<T, ChatUpsertArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatCountArgs} args - Arguments to filter Chats to count.
     * @example
     * // Count the number of Chats
     * const count = await prisma.chat.count({
     *   where: {
     *     // ... the filter for the Chats we want to count
     *   }
     * })
    **/
    count<T extends ChatCountArgs>(
      args?: Subset<T, ChatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatAggregateArgs>(args: Subset<T, ChatAggregateArgs>): Prisma.PrismaPromise<GetChatAggregateType<T>>

    /**
     * Group by Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatGroupByArgs['orderBy'] }
        : { orderBy?: ChatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chat model
   */
  readonly fields: ChatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user1<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user2<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    messages<T extends Chat$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Chat$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chat model
   */ 
  interface ChatFieldRefs {
    readonly id: FieldRef<"Chat", 'String'>
    readonly user1Id: FieldRef<"Chat", 'String'>
    readonly user2Id: FieldRef<"Chat", 'String'>
    readonly lastMessageAt: FieldRef<"Chat", 'DateTime'>
    readonly createdAt: FieldRef<"Chat", 'DateTime'>
    readonly updatedAt: FieldRef<"Chat", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Chat findUnique
   */
  export type ChatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat findUniqueOrThrow
   */
  export type ChatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat findFirst
   */
  export type ChatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat findFirstOrThrow
   */
  export type ChatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat findMany
   */
  export type ChatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chats to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat create
   */
  export type ChatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The data needed to create a Chat.
     */
    data: XOR<ChatCreateInput, ChatUncheckedCreateInput>
  }

  /**
   * Chat createMany
   */
  export type ChatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chats.
     */
    data: ChatCreateManyInput | ChatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chat createManyAndReturn
   */
  export type ChatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Chats.
     */
    data: ChatCreateManyInput | ChatCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chat update
   */
  export type ChatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The data needed to update a Chat.
     */
    data: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
    /**
     * Choose, which Chat to update.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat updateMany
   */
  export type ChatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chats.
     */
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyInput>
    /**
     * Filter which Chats to update
     */
    where?: ChatWhereInput
  }

  /**
   * Chat upsert
   */
  export type ChatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The filter to search for the Chat to update in case it exists.
     */
    where: ChatWhereUniqueInput
    /**
     * In case the Chat found by the `where` argument doesn't exist, create a new Chat with this data.
     */
    create: XOR<ChatCreateInput, ChatUncheckedCreateInput>
    /**
     * In case the Chat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
  }

  /**
   * Chat delete
   */
  export type ChatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter which Chat to delete.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat deleteMany
   */
  export type ChatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chats to delete
     */
    where?: ChatWhereInput
  }

  /**
   * Chat.messages
   */
  export type Chat$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Chat without action
   */
  export type ChatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    chatId: string | null
    senderId: string | null
    content: string | null
    imageUrl: string | null
    videoUrl: string | null
    audioUrl: string | null
    fileUrl: string | null
    fileName: string | null
    messageType: string | null
    isRead: boolean | null
    isDeleted: boolean | null
    isReported: boolean | null
    createdAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    chatId: string | null
    senderId: string | null
    content: string | null
    imageUrl: string | null
    videoUrl: string | null
    audioUrl: string | null
    fileUrl: string | null
    fileName: string | null
    messageType: string | null
    isRead: boolean | null
    isDeleted: boolean | null
    isReported: boolean | null
    createdAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    chatId: number
    senderId: number
    content: number
    imageUrl: number
    videoUrl: number
    audioUrl: number
    fileUrl: number
    fileName: number
    messageType: number
    isRead: number
    isDeleted: number
    deletedBy: number
    isReported: number
    createdAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    chatId?: true
    senderId?: true
    content?: true
    imageUrl?: true
    videoUrl?: true
    audioUrl?: true
    fileUrl?: true
    fileName?: true
    messageType?: true
    isRead?: true
    isDeleted?: true
    isReported?: true
    createdAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    chatId?: true
    senderId?: true
    content?: true
    imageUrl?: true
    videoUrl?: true
    audioUrl?: true
    fileUrl?: true
    fileName?: true
    messageType?: true
    isRead?: true
    isDeleted?: true
    isReported?: true
    createdAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    chatId?: true
    senderId?: true
    content?: true
    imageUrl?: true
    videoUrl?: true
    audioUrl?: true
    fileUrl?: true
    fileName?: true
    messageType?: true
    isRead?: true
    isDeleted?: true
    deletedBy?: true
    isReported?: true
    createdAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    chatId: string
    senderId: string
    content: string | null
    imageUrl: string | null
    videoUrl: string | null
    audioUrl: string | null
    fileUrl: string | null
    fileName: string | null
    messageType: string
    isRead: boolean
    isDeleted: boolean
    deletedBy: string[]
    isReported: boolean
    createdAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatId?: boolean
    senderId?: boolean
    content?: boolean
    imageUrl?: boolean
    videoUrl?: boolean
    audioUrl?: boolean
    fileUrl?: boolean
    fileName?: boolean
    messageType?: boolean
    isRead?: boolean
    isDeleted?: boolean
    deletedBy?: boolean
    isReported?: boolean
    createdAt?: boolean
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatId?: boolean
    senderId?: boolean
    content?: boolean
    imageUrl?: boolean
    videoUrl?: boolean
    audioUrl?: boolean
    fileUrl?: boolean
    fileName?: boolean
    messageType?: boolean
    isRead?: boolean
    isDeleted?: boolean
    deletedBy?: boolean
    isReported?: boolean
    createdAt?: boolean
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    chatId?: boolean
    senderId?: boolean
    content?: boolean
    imageUrl?: boolean
    videoUrl?: boolean
    audioUrl?: boolean
    fileUrl?: boolean
    fileName?: boolean
    messageType?: boolean
    isRead?: boolean
    isDeleted?: boolean
    deletedBy?: boolean
    isReported?: boolean
    createdAt?: boolean
  }

  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      chat: Prisma.$ChatPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      chatId: string
      senderId: string
      content: string | null
      imageUrl: string | null
      videoUrl: string | null
      audioUrl: string | null
      fileUrl: string | null
      fileName: string | null
      messageType: string
      isRead: boolean
      isDeleted: boolean
      deletedBy: string[]
      isReported: boolean
      createdAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chat<T extends ChatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatDefaultArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly chatId: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly imageUrl: FieldRef<"Message", 'String'>
    readonly videoUrl: FieldRef<"Message", 'String'>
    readonly audioUrl: FieldRef<"Message", 'String'>
    readonly fileUrl: FieldRef<"Message", 'String'>
    readonly fileName: FieldRef<"Message", 'String'>
    readonly messageType: FieldRef<"Message", 'String'>
    readonly isRead: FieldRef<"Message", 'Boolean'>
    readonly isDeleted: FieldRef<"Message", 'Boolean'>
    readonly deletedBy: FieldRef<"Message", 'String[]'>
    readonly isReported: FieldRef<"Message", 'Boolean'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model ProfileView
   */

  export type AggregateProfileView = {
    _count: ProfileViewCountAggregateOutputType | null
    _min: ProfileViewMinAggregateOutputType | null
    _max: ProfileViewMaxAggregateOutputType | null
  }

  export type ProfileViewMinAggregateOutputType = {
    id: string | null
    profileId: string | null
    viewedById: string | null
    createdAt: Date | null
  }

  export type ProfileViewMaxAggregateOutputType = {
    id: string | null
    profileId: string | null
    viewedById: string | null
    createdAt: Date | null
  }

  export type ProfileViewCountAggregateOutputType = {
    id: number
    profileId: number
    viewedById: number
    createdAt: number
    _all: number
  }


  export type ProfileViewMinAggregateInputType = {
    id?: true
    profileId?: true
    viewedById?: true
    createdAt?: true
  }

  export type ProfileViewMaxAggregateInputType = {
    id?: true
    profileId?: true
    viewedById?: true
    createdAt?: true
  }

  export type ProfileViewCountAggregateInputType = {
    id?: true
    profileId?: true
    viewedById?: true
    createdAt?: true
    _all?: true
  }

  export type ProfileViewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileView to aggregate.
     */
    where?: ProfileViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileViews to fetch.
     */
    orderBy?: ProfileViewOrderByWithRelationInput | ProfileViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProfileViews
    **/
    _count?: true | ProfileViewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileViewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileViewMaxAggregateInputType
  }

  export type GetProfileViewAggregateType<T extends ProfileViewAggregateArgs> = {
        [P in keyof T & keyof AggregateProfileView]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfileView[P]>
      : GetScalarType<T[P], AggregateProfileView[P]>
  }




  export type ProfileViewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileViewWhereInput
    orderBy?: ProfileViewOrderByWithAggregationInput | ProfileViewOrderByWithAggregationInput[]
    by: ProfileViewScalarFieldEnum[] | ProfileViewScalarFieldEnum
    having?: ProfileViewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileViewCountAggregateInputType | true
    _min?: ProfileViewMinAggregateInputType
    _max?: ProfileViewMaxAggregateInputType
  }

  export type ProfileViewGroupByOutputType = {
    id: string
    profileId: string
    viewedById: string
    createdAt: Date
    _count: ProfileViewCountAggregateOutputType | null
    _min: ProfileViewMinAggregateOutputType | null
    _max: ProfileViewMaxAggregateOutputType | null
  }

  type GetProfileViewGroupByPayload<T extends ProfileViewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileViewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileViewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileViewGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileViewGroupByOutputType[P]>
        }
      >
    >


  export type ProfileViewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    viewedById?: boolean
    createdAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    viewedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileView"]>

  export type ProfileViewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    viewedById?: boolean
    createdAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    viewedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileView"]>

  export type ProfileViewSelectScalar = {
    id?: boolean
    profileId?: boolean
    viewedById?: boolean
    createdAt?: boolean
  }

  export type ProfileViewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    viewedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProfileViewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    viewedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProfileViewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProfileView"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
      viewedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profileId: string
      viewedById: string
      createdAt: Date
    }, ExtArgs["result"]["profileView"]>
    composites: {}
  }

  type ProfileViewGetPayload<S extends boolean | null | undefined | ProfileViewDefaultArgs> = $Result.GetResult<Prisma.$ProfileViewPayload, S>

  type ProfileViewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfileViewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfileViewCountAggregateInputType | true
    }

  export interface ProfileViewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProfileView'], meta: { name: 'ProfileView' } }
    /**
     * Find zero or one ProfileView that matches the filter.
     * @param {ProfileViewFindUniqueArgs} args - Arguments to find a ProfileView
     * @example
     * // Get one ProfileView
     * const profileView = await prisma.profileView.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileViewFindUniqueArgs>(args: SelectSubset<T, ProfileViewFindUniqueArgs<ExtArgs>>): Prisma__ProfileViewClient<$Result.GetResult<Prisma.$ProfileViewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProfileView that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProfileViewFindUniqueOrThrowArgs} args - Arguments to find a ProfileView
     * @example
     * // Get one ProfileView
     * const profileView = await prisma.profileView.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileViewFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileViewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileViewClient<$Result.GetResult<Prisma.$ProfileViewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProfileView that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileViewFindFirstArgs} args - Arguments to find a ProfileView
     * @example
     * // Get one ProfileView
     * const profileView = await prisma.profileView.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileViewFindFirstArgs>(args?: SelectSubset<T, ProfileViewFindFirstArgs<ExtArgs>>): Prisma__ProfileViewClient<$Result.GetResult<Prisma.$ProfileViewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProfileView that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileViewFindFirstOrThrowArgs} args - Arguments to find a ProfileView
     * @example
     * // Get one ProfileView
     * const profileView = await prisma.profileView.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileViewFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileViewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileViewClient<$Result.GetResult<Prisma.$ProfileViewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProfileViews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileViewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProfileViews
     * const profileViews = await prisma.profileView.findMany()
     * 
     * // Get first 10 ProfileViews
     * const profileViews = await prisma.profileView.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileViewWithIdOnly = await prisma.profileView.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileViewFindManyArgs>(args?: SelectSubset<T, ProfileViewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileViewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProfileView.
     * @param {ProfileViewCreateArgs} args - Arguments to create a ProfileView.
     * @example
     * // Create one ProfileView
     * const ProfileView = await prisma.profileView.create({
     *   data: {
     *     // ... data to create a ProfileView
     *   }
     * })
     * 
     */
    create<T extends ProfileViewCreateArgs>(args: SelectSubset<T, ProfileViewCreateArgs<ExtArgs>>): Prisma__ProfileViewClient<$Result.GetResult<Prisma.$ProfileViewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProfileViews.
     * @param {ProfileViewCreateManyArgs} args - Arguments to create many ProfileViews.
     * @example
     * // Create many ProfileViews
     * const profileView = await prisma.profileView.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileViewCreateManyArgs>(args?: SelectSubset<T, ProfileViewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProfileViews and returns the data saved in the database.
     * @param {ProfileViewCreateManyAndReturnArgs} args - Arguments to create many ProfileViews.
     * @example
     * // Create many ProfileViews
     * const profileView = await prisma.profileView.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProfileViews and only return the `id`
     * const profileViewWithIdOnly = await prisma.profileView.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileViewCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileViewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileViewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProfileView.
     * @param {ProfileViewDeleteArgs} args - Arguments to delete one ProfileView.
     * @example
     * // Delete one ProfileView
     * const ProfileView = await prisma.profileView.delete({
     *   where: {
     *     // ... filter to delete one ProfileView
     *   }
     * })
     * 
     */
    delete<T extends ProfileViewDeleteArgs>(args: SelectSubset<T, ProfileViewDeleteArgs<ExtArgs>>): Prisma__ProfileViewClient<$Result.GetResult<Prisma.$ProfileViewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProfileView.
     * @param {ProfileViewUpdateArgs} args - Arguments to update one ProfileView.
     * @example
     * // Update one ProfileView
     * const profileView = await prisma.profileView.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileViewUpdateArgs>(args: SelectSubset<T, ProfileViewUpdateArgs<ExtArgs>>): Prisma__ProfileViewClient<$Result.GetResult<Prisma.$ProfileViewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProfileViews.
     * @param {ProfileViewDeleteManyArgs} args - Arguments to filter ProfileViews to delete.
     * @example
     * // Delete a few ProfileViews
     * const { count } = await prisma.profileView.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileViewDeleteManyArgs>(args?: SelectSubset<T, ProfileViewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfileViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileViewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProfileViews
     * const profileView = await prisma.profileView.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileViewUpdateManyArgs>(args: SelectSubset<T, ProfileViewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProfileView.
     * @param {ProfileViewUpsertArgs} args - Arguments to update or create a ProfileView.
     * @example
     * // Update or create a ProfileView
     * const profileView = await prisma.profileView.upsert({
     *   create: {
     *     // ... data to create a ProfileView
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProfileView we want to update
     *   }
     * })
     */
    upsert<T extends ProfileViewUpsertArgs>(args: SelectSubset<T, ProfileViewUpsertArgs<ExtArgs>>): Prisma__ProfileViewClient<$Result.GetResult<Prisma.$ProfileViewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProfileViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileViewCountArgs} args - Arguments to filter ProfileViews to count.
     * @example
     * // Count the number of ProfileViews
     * const count = await prisma.profileView.count({
     *   where: {
     *     // ... the filter for the ProfileViews we want to count
     *   }
     * })
    **/
    count<T extends ProfileViewCountArgs>(
      args?: Subset<T, ProfileViewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileViewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProfileView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileViewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileViewAggregateArgs>(args: Subset<T, ProfileViewAggregateArgs>): Prisma.PrismaPromise<GetProfileViewAggregateType<T>>

    /**
     * Group by ProfileView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileViewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileViewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileViewGroupByArgs['orderBy'] }
        : { orderBy?: ProfileViewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileViewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileViewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProfileView model
   */
  readonly fields: ProfileViewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProfileView.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileViewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    viewedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProfileView model
   */ 
  interface ProfileViewFieldRefs {
    readonly id: FieldRef<"ProfileView", 'String'>
    readonly profileId: FieldRef<"ProfileView", 'String'>
    readonly viewedById: FieldRef<"ProfileView", 'String'>
    readonly createdAt: FieldRef<"ProfileView", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProfileView findUnique
   */
  export type ProfileViewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileView
     */
    select?: ProfileViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileViewInclude<ExtArgs> | null
    /**
     * Filter, which ProfileView to fetch.
     */
    where: ProfileViewWhereUniqueInput
  }

  /**
   * ProfileView findUniqueOrThrow
   */
  export type ProfileViewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileView
     */
    select?: ProfileViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileViewInclude<ExtArgs> | null
    /**
     * Filter, which ProfileView to fetch.
     */
    where: ProfileViewWhereUniqueInput
  }

  /**
   * ProfileView findFirst
   */
  export type ProfileViewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileView
     */
    select?: ProfileViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileViewInclude<ExtArgs> | null
    /**
     * Filter, which ProfileView to fetch.
     */
    where?: ProfileViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileViews to fetch.
     */
    orderBy?: ProfileViewOrderByWithRelationInput | ProfileViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileViews.
     */
    cursor?: ProfileViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileViews.
     */
    distinct?: ProfileViewScalarFieldEnum | ProfileViewScalarFieldEnum[]
  }

  /**
   * ProfileView findFirstOrThrow
   */
  export type ProfileViewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileView
     */
    select?: ProfileViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileViewInclude<ExtArgs> | null
    /**
     * Filter, which ProfileView to fetch.
     */
    where?: ProfileViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileViews to fetch.
     */
    orderBy?: ProfileViewOrderByWithRelationInput | ProfileViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileViews.
     */
    cursor?: ProfileViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileViews.
     */
    distinct?: ProfileViewScalarFieldEnum | ProfileViewScalarFieldEnum[]
  }

  /**
   * ProfileView findMany
   */
  export type ProfileViewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileView
     */
    select?: ProfileViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileViewInclude<ExtArgs> | null
    /**
     * Filter, which ProfileViews to fetch.
     */
    where?: ProfileViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileViews to fetch.
     */
    orderBy?: ProfileViewOrderByWithRelationInput | ProfileViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProfileViews.
     */
    cursor?: ProfileViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileViews.
     */
    skip?: number
    distinct?: ProfileViewScalarFieldEnum | ProfileViewScalarFieldEnum[]
  }

  /**
   * ProfileView create
   */
  export type ProfileViewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileView
     */
    select?: ProfileViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileViewInclude<ExtArgs> | null
    /**
     * The data needed to create a ProfileView.
     */
    data: XOR<ProfileViewCreateInput, ProfileViewUncheckedCreateInput>
  }

  /**
   * ProfileView createMany
   */
  export type ProfileViewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProfileViews.
     */
    data: ProfileViewCreateManyInput | ProfileViewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProfileView createManyAndReturn
   */
  export type ProfileViewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileView
     */
    select?: ProfileViewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProfileViews.
     */
    data: ProfileViewCreateManyInput | ProfileViewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileViewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProfileView update
   */
  export type ProfileViewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileView
     */
    select?: ProfileViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileViewInclude<ExtArgs> | null
    /**
     * The data needed to update a ProfileView.
     */
    data: XOR<ProfileViewUpdateInput, ProfileViewUncheckedUpdateInput>
    /**
     * Choose, which ProfileView to update.
     */
    where: ProfileViewWhereUniqueInput
  }

  /**
   * ProfileView updateMany
   */
  export type ProfileViewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProfileViews.
     */
    data: XOR<ProfileViewUpdateManyMutationInput, ProfileViewUncheckedUpdateManyInput>
    /**
     * Filter which ProfileViews to update
     */
    where?: ProfileViewWhereInput
  }

  /**
   * ProfileView upsert
   */
  export type ProfileViewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileView
     */
    select?: ProfileViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileViewInclude<ExtArgs> | null
    /**
     * The filter to search for the ProfileView to update in case it exists.
     */
    where: ProfileViewWhereUniqueInput
    /**
     * In case the ProfileView found by the `where` argument doesn't exist, create a new ProfileView with this data.
     */
    create: XOR<ProfileViewCreateInput, ProfileViewUncheckedCreateInput>
    /**
     * In case the ProfileView was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileViewUpdateInput, ProfileViewUncheckedUpdateInput>
  }

  /**
   * ProfileView delete
   */
  export type ProfileViewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileView
     */
    select?: ProfileViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileViewInclude<ExtArgs> | null
    /**
     * Filter which ProfileView to delete.
     */
    where: ProfileViewWhereUniqueInput
  }

  /**
   * ProfileView deleteMany
   */
  export type ProfileViewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileViews to delete
     */
    where?: ProfileViewWhereInput
  }

  /**
   * ProfileView without action
   */
  export type ProfileViewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileView
     */
    select?: ProfileViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileViewInclude<ExtArgs> | null
  }


  /**
   * Model ContactView
   */

  export type AggregateContactView = {
    _count: ContactViewCountAggregateOutputType | null
    _min: ContactViewMinAggregateOutputType | null
    _max: ContactViewMaxAggregateOutputType | null
  }

  export type ContactViewMinAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    profileId: string | null
    viewedById: string | null
    createdAt: Date | null
  }

  export type ContactViewMaxAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    profileId: string | null
    viewedById: string | null
    createdAt: Date | null
  }

  export type ContactViewCountAggregateOutputType = {
    id: number
    subscriptionId: number
    profileId: number
    viewedById: number
    createdAt: number
    _all: number
  }


  export type ContactViewMinAggregateInputType = {
    id?: true
    subscriptionId?: true
    profileId?: true
    viewedById?: true
    createdAt?: true
  }

  export type ContactViewMaxAggregateInputType = {
    id?: true
    subscriptionId?: true
    profileId?: true
    viewedById?: true
    createdAt?: true
  }

  export type ContactViewCountAggregateInputType = {
    id?: true
    subscriptionId?: true
    profileId?: true
    viewedById?: true
    createdAt?: true
    _all?: true
  }

  export type ContactViewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactView to aggregate.
     */
    where?: ContactViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactViews to fetch.
     */
    orderBy?: ContactViewOrderByWithRelationInput | ContactViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactViews
    **/
    _count?: true | ContactViewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactViewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactViewMaxAggregateInputType
  }

  export type GetContactViewAggregateType<T extends ContactViewAggregateArgs> = {
        [P in keyof T & keyof AggregateContactView]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactView[P]>
      : GetScalarType<T[P], AggregateContactView[P]>
  }




  export type ContactViewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactViewWhereInput
    orderBy?: ContactViewOrderByWithAggregationInput | ContactViewOrderByWithAggregationInput[]
    by: ContactViewScalarFieldEnum[] | ContactViewScalarFieldEnum
    having?: ContactViewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactViewCountAggregateInputType | true
    _min?: ContactViewMinAggregateInputType
    _max?: ContactViewMaxAggregateInputType
  }

  export type ContactViewGroupByOutputType = {
    id: string
    subscriptionId: string
    profileId: string
    viewedById: string
    createdAt: Date
    _count: ContactViewCountAggregateOutputType | null
    _min: ContactViewMinAggregateOutputType | null
    _max: ContactViewMaxAggregateOutputType | null
  }

  type GetContactViewGroupByPayload<T extends ContactViewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactViewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactViewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactViewGroupByOutputType[P]>
            : GetScalarType<T[P], ContactViewGroupByOutputType[P]>
        }
      >
    >


  export type ContactViewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    profileId?: boolean
    viewedById?: boolean
    createdAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactView"]>

  export type ContactViewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    profileId?: boolean
    viewedById?: boolean
    createdAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactView"]>

  export type ContactViewSelectScalar = {
    id?: boolean
    subscriptionId?: boolean
    profileId?: boolean
    viewedById?: boolean
    createdAt?: boolean
  }

  export type ContactViewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type ContactViewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }

  export type $ContactViewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactView"
    objects: {
      subscription: Prisma.$SubscriptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subscriptionId: string
      profileId: string
      viewedById: string
      createdAt: Date
    }, ExtArgs["result"]["contactView"]>
    composites: {}
  }

  type ContactViewGetPayload<S extends boolean | null | undefined | ContactViewDefaultArgs> = $Result.GetResult<Prisma.$ContactViewPayload, S>

  type ContactViewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContactViewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContactViewCountAggregateInputType | true
    }

  export interface ContactViewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactView'], meta: { name: 'ContactView' } }
    /**
     * Find zero or one ContactView that matches the filter.
     * @param {ContactViewFindUniqueArgs} args - Arguments to find a ContactView
     * @example
     * // Get one ContactView
     * const contactView = await prisma.contactView.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactViewFindUniqueArgs>(args: SelectSubset<T, ContactViewFindUniqueArgs<ExtArgs>>): Prisma__ContactViewClient<$Result.GetResult<Prisma.$ContactViewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ContactView that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContactViewFindUniqueOrThrowArgs} args - Arguments to find a ContactView
     * @example
     * // Get one ContactView
     * const contactView = await prisma.contactView.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactViewFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactViewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactViewClient<$Result.GetResult<Prisma.$ContactViewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ContactView that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactViewFindFirstArgs} args - Arguments to find a ContactView
     * @example
     * // Get one ContactView
     * const contactView = await prisma.contactView.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactViewFindFirstArgs>(args?: SelectSubset<T, ContactViewFindFirstArgs<ExtArgs>>): Prisma__ContactViewClient<$Result.GetResult<Prisma.$ContactViewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ContactView that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactViewFindFirstOrThrowArgs} args - Arguments to find a ContactView
     * @example
     * // Get one ContactView
     * const contactView = await prisma.contactView.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactViewFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactViewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactViewClient<$Result.GetResult<Prisma.$ContactViewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ContactViews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactViewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactViews
     * const contactViews = await prisma.contactView.findMany()
     * 
     * // Get first 10 ContactViews
     * const contactViews = await prisma.contactView.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactViewWithIdOnly = await prisma.contactView.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactViewFindManyArgs>(args?: SelectSubset<T, ContactViewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactViewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ContactView.
     * @param {ContactViewCreateArgs} args - Arguments to create a ContactView.
     * @example
     * // Create one ContactView
     * const ContactView = await prisma.contactView.create({
     *   data: {
     *     // ... data to create a ContactView
     *   }
     * })
     * 
     */
    create<T extends ContactViewCreateArgs>(args: SelectSubset<T, ContactViewCreateArgs<ExtArgs>>): Prisma__ContactViewClient<$Result.GetResult<Prisma.$ContactViewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ContactViews.
     * @param {ContactViewCreateManyArgs} args - Arguments to create many ContactViews.
     * @example
     * // Create many ContactViews
     * const contactView = await prisma.contactView.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactViewCreateManyArgs>(args?: SelectSubset<T, ContactViewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContactViews and returns the data saved in the database.
     * @param {ContactViewCreateManyAndReturnArgs} args - Arguments to create many ContactViews.
     * @example
     * // Create many ContactViews
     * const contactView = await prisma.contactView.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContactViews and only return the `id`
     * const contactViewWithIdOnly = await prisma.contactView.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactViewCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactViewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactViewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ContactView.
     * @param {ContactViewDeleteArgs} args - Arguments to delete one ContactView.
     * @example
     * // Delete one ContactView
     * const ContactView = await prisma.contactView.delete({
     *   where: {
     *     // ... filter to delete one ContactView
     *   }
     * })
     * 
     */
    delete<T extends ContactViewDeleteArgs>(args: SelectSubset<T, ContactViewDeleteArgs<ExtArgs>>): Prisma__ContactViewClient<$Result.GetResult<Prisma.$ContactViewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ContactView.
     * @param {ContactViewUpdateArgs} args - Arguments to update one ContactView.
     * @example
     * // Update one ContactView
     * const contactView = await prisma.contactView.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactViewUpdateArgs>(args: SelectSubset<T, ContactViewUpdateArgs<ExtArgs>>): Prisma__ContactViewClient<$Result.GetResult<Prisma.$ContactViewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ContactViews.
     * @param {ContactViewDeleteManyArgs} args - Arguments to filter ContactViews to delete.
     * @example
     * // Delete a few ContactViews
     * const { count } = await prisma.contactView.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactViewDeleteManyArgs>(args?: SelectSubset<T, ContactViewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactViewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactViews
     * const contactView = await prisma.contactView.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactViewUpdateManyArgs>(args: SelectSubset<T, ContactViewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContactView.
     * @param {ContactViewUpsertArgs} args - Arguments to update or create a ContactView.
     * @example
     * // Update or create a ContactView
     * const contactView = await prisma.contactView.upsert({
     *   create: {
     *     // ... data to create a ContactView
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactView we want to update
     *   }
     * })
     */
    upsert<T extends ContactViewUpsertArgs>(args: SelectSubset<T, ContactViewUpsertArgs<ExtArgs>>): Prisma__ContactViewClient<$Result.GetResult<Prisma.$ContactViewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ContactViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactViewCountArgs} args - Arguments to filter ContactViews to count.
     * @example
     * // Count the number of ContactViews
     * const count = await prisma.contactView.count({
     *   where: {
     *     // ... the filter for the ContactViews we want to count
     *   }
     * })
    **/
    count<T extends ContactViewCountArgs>(
      args?: Subset<T, ContactViewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactViewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactViewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactViewAggregateArgs>(args: Subset<T, ContactViewAggregateArgs>): Prisma.PrismaPromise<GetContactViewAggregateType<T>>

    /**
     * Group by ContactView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactViewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactViewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactViewGroupByArgs['orderBy'] }
        : { orderBy?: ContactViewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactViewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactViewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactView model
   */
  readonly fields: ContactViewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactView.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactViewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscription<T extends SubscriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionDefaultArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactView model
   */ 
  interface ContactViewFieldRefs {
    readonly id: FieldRef<"ContactView", 'String'>
    readonly subscriptionId: FieldRef<"ContactView", 'String'>
    readonly profileId: FieldRef<"ContactView", 'String'>
    readonly viewedById: FieldRef<"ContactView", 'String'>
    readonly createdAt: FieldRef<"ContactView", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContactView findUnique
   */
  export type ContactViewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactView
     */
    select?: ContactViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactViewInclude<ExtArgs> | null
    /**
     * Filter, which ContactView to fetch.
     */
    where: ContactViewWhereUniqueInput
  }

  /**
   * ContactView findUniqueOrThrow
   */
  export type ContactViewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactView
     */
    select?: ContactViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactViewInclude<ExtArgs> | null
    /**
     * Filter, which ContactView to fetch.
     */
    where: ContactViewWhereUniqueInput
  }

  /**
   * ContactView findFirst
   */
  export type ContactViewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactView
     */
    select?: ContactViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactViewInclude<ExtArgs> | null
    /**
     * Filter, which ContactView to fetch.
     */
    where?: ContactViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactViews to fetch.
     */
    orderBy?: ContactViewOrderByWithRelationInput | ContactViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactViews.
     */
    cursor?: ContactViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactViews.
     */
    distinct?: ContactViewScalarFieldEnum | ContactViewScalarFieldEnum[]
  }

  /**
   * ContactView findFirstOrThrow
   */
  export type ContactViewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactView
     */
    select?: ContactViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactViewInclude<ExtArgs> | null
    /**
     * Filter, which ContactView to fetch.
     */
    where?: ContactViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactViews to fetch.
     */
    orderBy?: ContactViewOrderByWithRelationInput | ContactViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactViews.
     */
    cursor?: ContactViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactViews.
     */
    distinct?: ContactViewScalarFieldEnum | ContactViewScalarFieldEnum[]
  }

  /**
   * ContactView findMany
   */
  export type ContactViewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactView
     */
    select?: ContactViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactViewInclude<ExtArgs> | null
    /**
     * Filter, which ContactViews to fetch.
     */
    where?: ContactViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactViews to fetch.
     */
    orderBy?: ContactViewOrderByWithRelationInput | ContactViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactViews.
     */
    cursor?: ContactViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactViews.
     */
    skip?: number
    distinct?: ContactViewScalarFieldEnum | ContactViewScalarFieldEnum[]
  }

  /**
   * ContactView create
   */
  export type ContactViewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactView
     */
    select?: ContactViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactViewInclude<ExtArgs> | null
    /**
     * The data needed to create a ContactView.
     */
    data: XOR<ContactViewCreateInput, ContactViewUncheckedCreateInput>
  }

  /**
   * ContactView createMany
   */
  export type ContactViewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactViews.
     */
    data: ContactViewCreateManyInput | ContactViewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactView createManyAndReturn
   */
  export type ContactViewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactView
     */
    select?: ContactViewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ContactViews.
     */
    data: ContactViewCreateManyInput | ContactViewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactViewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContactView update
   */
  export type ContactViewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactView
     */
    select?: ContactViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactViewInclude<ExtArgs> | null
    /**
     * The data needed to update a ContactView.
     */
    data: XOR<ContactViewUpdateInput, ContactViewUncheckedUpdateInput>
    /**
     * Choose, which ContactView to update.
     */
    where: ContactViewWhereUniqueInput
  }

  /**
   * ContactView updateMany
   */
  export type ContactViewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactViews.
     */
    data: XOR<ContactViewUpdateManyMutationInput, ContactViewUncheckedUpdateManyInput>
    /**
     * Filter which ContactViews to update
     */
    where?: ContactViewWhereInput
  }

  /**
   * ContactView upsert
   */
  export type ContactViewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactView
     */
    select?: ContactViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactViewInclude<ExtArgs> | null
    /**
     * The filter to search for the ContactView to update in case it exists.
     */
    where: ContactViewWhereUniqueInput
    /**
     * In case the ContactView found by the `where` argument doesn't exist, create a new ContactView with this data.
     */
    create: XOR<ContactViewCreateInput, ContactViewUncheckedCreateInput>
    /**
     * In case the ContactView was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactViewUpdateInput, ContactViewUncheckedUpdateInput>
  }

  /**
   * ContactView delete
   */
  export type ContactViewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactView
     */
    select?: ContactViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactViewInclude<ExtArgs> | null
    /**
     * Filter which ContactView to delete.
     */
    where: ContactViewWhereUniqueInput
  }

  /**
   * ContactView deleteMany
   */
  export type ContactViewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactViews to delete
     */
    where?: ContactViewWhereInput
  }

  /**
   * ContactView without action
   */
  export type ContactViewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactView
     */
    select?: ContactViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactViewInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionAvgAggregateOutputType = {
    contactViewsUsed: number | null
    contactViewsLimit: number | null
    profileBoostCredits: number | null
    horoscopeReportsIncluded: number | null
  }

  export type SubscriptionSumAggregateOutputType = {
    contactViewsUsed: number | null
    contactViewsLimit: number | null
    profileBoostCredits: number | null
    horoscopeReportsIncluded: number | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    plan: $Enums.SubscriptionPlan | null
    razorpaySubscriptionId: string | null
    razorpayPlanId: string | null
    status: string | null
    startDate: Date | null
    endDate: Date | null
    contactViewsUsed: number | null
    contactViewsLimit: number | null
    profileBoostCredits: number | null
    verifiedBadgeIncluded: boolean | null
    horoscopeReportsIncluded: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    plan: $Enums.SubscriptionPlan | null
    razorpaySubscriptionId: string | null
    razorpayPlanId: string | null
    status: string | null
    startDate: Date | null
    endDate: Date | null
    contactViewsUsed: number | null
    contactViewsLimit: number | null
    profileBoostCredits: number | null
    verifiedBadgeIncluded: boolean | null
    horoscopeReportsIncluded: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    plan: number
    razorpaySubscriptionId: number
    razorpayPlanId: number
    status: number
    startDate: number
    endDate: number
    contactViewsUsed: number
    contactViewsLimit: number
    profileBoostCredits: number
    verifiedBadgeIncluded: number
    horoscopeReportsIncluded: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionAvgAggregateInputType = {
    contactViewsUsed?: true
    contactViewsLimit?: true
    profileBoostCredits?: true
    horoscopeReportsIncluded?: true
  }

  export type SubscriptionSumAggregateInputType = {
    contactViewsUsed?: true
    contactViewsLimit?: true
    profileBoostCredits?: true
    horoscopeReportsIncluded?: true
  }

  export type SubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    plan?: true
    razorpaySubscriptionId?: true
    razorpayPlanId?: true
    status?: true
    startDate?: true
    endDate?: true
    contactViewsUsed?: true
    contactViewsLimit?: true
    profileBoostCredits?: true
    verifiedBadgeIncluded?: true
    horoscopeReportsIncluded?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    plan?: true
    razorpaySubscriptionId?: true
    razorpayPlanId?: true
    status?: true
    startDate?: true
    endDate?: true
    contactViewsUsed?: true
    contactViewsLimit?: true
    profileBoostCredits?: true
    verifiedBadgeIncluded?: true
    horoscopeReportsIncluded?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    plan?: true
    razorpaySubscriptionId?: true
    razorpayPlanId?: true
    status?: true
    startDate?: true
    endDate?: true
    contactViewsUsed?: true
    contactViewsLimit?: true
    profileBoostCredits?: true
    verifiedBadgeIncluded?: true
    horoscopeReportsIncluded?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _avg?: SubscriptionAvgAggregateInputType
    _sum?: SubscriptionSumAggregateInputType
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    userId: string
    plan: $Enums.SubscriptionPlan
    razorpaySubscriptionId: string | null
    razorpayPlanId: string | null
    status: string
    startDate: Date
    endDate: Date
    contactViewsUsed: number
    contactViewsLimit: number | null
    profileBoostCredits: number
    verifiedBadgeIncluded: boolean
    horoscopeReportsIncluded: number
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    plan?: boolean
    razorpaySubscriptionId?: boolean
    razorpayPlanId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    contactViewsUsed?: boolean
    contactViewsLimit?: boolean
    profileBoostCredits?: boolean
    verifiedBadgeIncluded?: boolean
    horoscopeReportsIncluded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    contactViews?: boolean | Subscription$contactViewsArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    plan?: boolean
    razorpaySubscriptionId?: boolean
    razorpayPlanId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    contactViewsUsed?: boolean
    contactViewsLimit?: boolean
    profileBoostCredits?: boolean
    verifiedBadgeIncluded?: boolean
    horoscopeReportsIncluded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    userId?: boolean
    plan?: boolean
    razorpaySubscriptionId?: boolean
    razorpayPlanId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    contactViewsUsed?: boolean
    contactViewsLimit?: boolean
    profileBoostCredits?: boolean
    verifiedBadgeIncluded?: boolean
    horoscopeReportsIncluded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    contactViews?: boolean | Subscription$contactViewsArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      contactViews: Prisma.$ContactViewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      plan: $Enums.SubscriptionPlan
      razorpaySubscriptionId: string | null
      razorpayPlanId: string | null
      status: string
      startDate: Date
      endDate: Date
      contactViewsUsed: number
      contactViewsLimit: number | null
      profileBoostCredits: number
      verifiedBadgeIncluded: boolean
      horoscopeReportsIncluded: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    contactViews<T extends Subscription$contactViewsArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$contactViewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactViewPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */ 
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly userId: FieldRef<"Subscription", 'String'>
    readonly plan: FieldRef<"Subscription", 'SubscriptionPlan'>
    readonly razorpaySubscriptionId: FieldRef<"Subscription", 'String'>
    readonly razorpayPlanId: FieldRef<"Subscription", 'String'>
    readonly status: FieldRef<"Subscription", 'String'>
    readonly startDate: FieldRef<"Subscription", 'DateTime'>
    readonly endDate: FieldRef<"Subscription", 'DateTime'>
    readonly contactViewsUsed: FieldRef<"Subscription", 'Int'>
    readonly contactViewsLimit: FieldRef<"Subscription", 'Int'>
    readonly profileBoostCredits: FieldRef<"Subscription", 'Int'>
    readonly verifiedBadgeIncluded: FieldRef<"Subscription", 'Boolean'>
    readonly horoscopeReportsIncluded: FieldRef<"Subscription", 'Int'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
  }

  /**
   * Subscription.contactViews
   */
  export type Subscription$contactViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactView
     */
    select?: ContactViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactViewInclude<ExtArgs> | null
    where?: ContactViewWhereInput
    orderBy?: ContactViewOrderByWithRelationInput | ContactViewOrderByWithRelationInput[]
    cursor?: ContactViewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactViewScalarFieldEnum | ContactViewScalarFieldEnum[]
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    razorpayOrderId: string | null
    razorpayPaymentId: string | null
    amount: number | null
    currency: string | null
    status: $Enums.PaymentStatus | null
    type: string | null
    addOnType: $Enums.AddOnType | null
    subscriptionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    razorpayOrderId: string | null
    razorpayPaymentId: string | null
    amount: number | null
    currency: string | null
    status: $Enums.PaymentStatus | null
    type: string | null
    addOnType: $Enums.AddOnType | null
    subscriptionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    userId: number
    razorpayOrderId: number
    razorpayPaymentId: number
    amount: number
    currency: number
    status: number
    type: number
    addOnType: number
    subscriptionId: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    userId?: true
    razorpayOrderId?: true
    razorpayPaymentId?: true
    amount?: true
    currency?: true
    status?: true
    type?: true
    addOnType?: true
    subscriptionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    userId?: true
    razorpayOrderId?: true
    razorpayPaymentId?: true
    amount?: true
    currency?: true
    status?: true
    type?: true
    addOnType?: true
    subscriptionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    userId?: true
    razorpayOrderId?: true
    razorpayPaymentId?: true
    amount?: true
    currency?: true
    status?: true
    type?: true
    addOnType?: true
    subscriptionId?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    userId: string
    razorpayOrderId: string | null
    razorpayPaymentId: string | null
    amount: number
    currency: string
    status: $Enums.PaymentStatus
    type: string
    addOnType: $Enums.AddOnType | null
    subscriptionId: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    razorpayOrderId?: boolean
    razorpayPaymentId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    type?: boolean
    addOnType?: boolean
    subscriptionId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    addOns?: boolean | Payment$addOnsArgs<ExtArgs>
    services?: boolean | Payment$servicesArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    razorpayOrderId?: boolean
    razorpayPaymentId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    type?: boolean
    addOnType?: boolean
    subscriptionId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    userId?: boolean
    razorpayOrderId?: boolean
    razorpayPaymentId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    type?: boolean
    addOnType?: boolean
    subscriptionId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    addOns?: boolean | Payment$addOnsArgs<ExtArgs>
    services?: boolean | Payment$servicesArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      addOns: Prisma.$AddOnPayload<ExtArgs>[]
      services: Prisma.$ServicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      razorpayOrderId: string | null
      razorpayPaymentId: string | null
      amount: number
      currency: string
      status: $Enums.PaymentStatus
      type: string
      addOnType: $Enums.AddOnType | null
      subscriptionId: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    addOns<T extends Payment$addOnsArgs<ExtArgs> = {}>(args?: Subset<T, Payment$addOnsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddOnPayload<ExtArgs>, T, "findMany"> | Null>
    services<T extends Payment$servicesArgs<ExtArgs> = {}>(args?: Subset<T, Payment$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly userId: FieldRef<"Payment", 'String'>
    readonly razorpayOrderId: FieldRef<"Payment", 'String'>
    readonly razorpayPaymentId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Int'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly type: FieldRef<"Payment", 'String'>
    readonly addOnType: FieldRef<"Payment", 'AddOnType'>
    readonly subscriptionId: FieldRef<"Payment", 'String'>
    readonly metadata: FieldRef<"Payment", 'Json'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment.addOns
   */
  export type Payment$addOnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOn
     */
    select?: AddOnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnInclude<ExtArgs> | null
    where?: AddOnWhereInput
    orderBy?: AddOnOrderByWithRelationInput | AddOnOrderByWithRelationInput[]
    cursor?: AddOnWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddOnScalarFieldEnum | AddOnScalarFieldEnum[]
  }

  /**
   * Payment.services
   */
  export type Payment$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model AddOn
   */

  export type AggregateAddOn = {
    _count: AddOnCountAggregateOutputType | null
    _min: AddOnMinAggregateOutputType | null
    _max: AddOnMaxAggregateOutputType | null
  }

  export type AddOnMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.AddOnType | null
    paymentId: string | null
    expiresAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type AddOnMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.AddOnType | null
    paymentId: string | null
    expiresAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type AddOnCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    paymentId: number
    expiresAt: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type AddOnMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    paymentId?: true
    expiresAt?: true
    isActive?: true
    createdAt?: true
  }

  export type AddOnMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    paymentId?: true
    expiresAt?: true
    isActive?: true
    createdAt?: true
  }

  export type AddOnCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    paymentId?: true
    expiresAt?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type AddOnAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddOn to aggregate.
     */
    where?: AddOnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddOns to fetch.
     */
    orderBy?: AddOnOrderByWithRelationInput | AddOnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddOnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddOns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AddOns
    **/
    _count?: true | AddOnCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddOnMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddOnMaxAggregateInputType
  }

  export type GetAddOnAggregateType<T extends AddOnAggregateArgs> = {
        [P in keyof T & keyof AggregateAddOn]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddOn[P]>
      : GetScalarType<T[P], AggregateAddOn[P]>
  }




  export type AddOnGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddOnWhereInput
    orderBy?: AddOnOrderByWithAggregationInput | AddOnOrderByWithAggregationInput[]
    by: AddOnScalarFieldEnum[] | AddOnScalarFieldEnum
    having?: AddOnScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddOnCountAggregateInputType | true
    _min?: AddOnMinAggregateInputType
    _max?: AddOnMaxAggregateInputType
  }

  export type AddOnGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.AddOnType
    paymentId: string | null
    expiresAt: Date | null
    isActive: boolean
    createdAt: Date
    _count: AddOnCountAggregateOutputType | null
    _min: AddOnMinAggregateOutputType | null
    _max: AddOnMaxAggregateOutputType | null
  }

  type GetAddOnGroupByPayload<T extends AddOnGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddOnGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddOnGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddOnGroupByOutputType[P]>
            : GetScalarType<T[P], AddOnGroupByOutputType[P]>
        }
      >
    >


  export type AddOnSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    paymentId?: boolean
    expiresAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    payment?: boolean | AddOn$paymentArgs<ExtArgs>
  }, ExtArgs["result"]["addOn"]>

  export type AddOnSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    paymentId?: boolean
    expiresAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    payment?: boolean | AddOn$paymentArgs<ExtArgs>
  }, ExtArgs["result"]["addOn"]>

  export type AddOnSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    paymentId?: boolean
    expiresAt?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type AddOnInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | AddOn$paymentArgs<ExtArgs>
  }
  export type AddOnIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | AddOn$paymentArgs<ExtArgs>
  }

  export type $AddOnPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AddOn"
    objects: {
      payment: Prisma.$PaymentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.AddOnType
      paymentId: string | null
      expiresAt: Date | null
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["addOn"]>
    composites: {}
  }

  type AddOnGetPayload<S extends boolean | null | undefined | AddOnDefaultArgs> = $Result.GetResult<Prisma.$AddOnPayload, S>

  type AddOnCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AddOnFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AddOnCountAggregateInputType | true
    }

  export interface AddOnDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AddOn'], meta: { name: 'AddOn' } }
    /**
     * Find zero or one AddOn that matches the filter.
     * @param {AddOnFindUniqueArgs} args - Arguments to find a AddOn
     * @example
     * // Get one AddOn
     * const addOn = await prisma.addOn.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddOnFindUniqueArgs>(args: SelectSubset<T, AddOnFindUniqueArgs<ExtArgs>>): Prisma__AddOnClient<$Result.GetResult<Prisma.$AddOnPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AddOn that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AddOnFindUniqueOrThrowArgs} args - Arguments to find a AddOn
     * @example
     * // Get one AddOn
     * const addOn = await prisma.addOn.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddOnFindUniqueOrThrowArgs>(args: SelectSubset<T, AddOnFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddOnClient<$Result.GetResult<Prisma.$AddOnPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AddOn that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnFindFirstArgs} args - Arguments to find a AddOn
     * @example
     * // Get one AddOn
     * const addOn = await prisma.addOn.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddOnFindFirstArgs>(args?: SelectSubset<T, AddOnFindFirstArgs<ExtArgs>>): Prisma__AddOnClient<$Result.GetResult<Prisma.$AddOnPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AddOn that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnFindFirstOrThrowArgs} args - Arguments to find a AddOn
     * @example
     * // Get one AddOn
     * const addOn = await prisma.addOn.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddOnFindFirstOrThrowArgs>(args?: SelectSubset<T, AddOnFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddOnClient<$Result.GetResult<Prisma.$AddOnPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AddOns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AddOns
     * const addOns = await prisma.addOn.findMany()
     * 
     * // Get first 10 AddOns
     * const addOns = await prisma.addOn.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addOnWithIdOnly = await prisma.addOn.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddOnFindManyArgs>(args?: SelectSubset<T, AddOnFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddOnPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AddOn.
     * @param {AddOnCreateArgs} args - Arguments to create a AddOn.
     * @example
     * // Create one AddOn
     * const AddOn = await prisma.addOn.create({
     *   data: {
     *     // ... data to create a AddOn
     *   }
     * })
     * 
     */
    create<T extends AddOnCreateArgs>(args: SelectSubset<T, AddOnCreateArgs<ExtArgs>>): Prisma__AddOnClient<$Result.GetResult<Prisma.$AddOnPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AddOns.
     * @param {AddOnCreateManyArgs} args - Arguments to create many AddOns.
     * @example
     * // Create many AddOns
     * const addOn = await prisma.addOn.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddOnCreateManyArgs>(args?: SelectSubset<T, AddOnCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AddOns and returns the data saved in the database.
     * @param {AddOnCreateManyAndReturnArgs} args - Arguments to create many AddOns.
     * @example
     * // Create many AddOns
     * const addOn = await prisma.addOn.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AddOns and only return the `id`
     * const addOnWithIdOnly = await prisma.addOn.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AddOnCreateManyAndReturnArgs>(args?: SelectSubset<T, AddOnCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddOnPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AddOn.
     * @param {AddOnDeleteArgs} args - Arguments to delete one AddOn.
     * @example
     * // Delete one AddOn
     * const AddOn = await prisma.addOn.delete({
     *   where: {
     *     // ... filter to delete one AddOn
     *   }
     * })
     * 
     */
    delete<T extends AddOnDeleteArgs>(args: SelectSubset<T, AddOnDeleteArgs<ExtArgs>>): Prisma__AddOnClient<$Result.GetResult<Prisma.$AddOnPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AddOn.
     * @param {AddOnUpdateArgs} args - Arguments to update one AddOn.
     * @example
     * // Update one AddOn
     * const addOn = await prisma.addOn.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddOnUpdateArgs>(args: SelectSubset<T, AddOnUpdateArgs<ExtArgs>>): Prisma__AddOnClient<$Result.GetResult<Prisma.$AddOnPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AddOns.
     * @param {AddOnDeleteManyArgs} args - Arguments to filter AddOns to delete.
     * @example
     * // Delete a few AddOns
     * const { count } = await prisma.addOn.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddOnDeleteManyArgs>(args?: SelectSubset<T, AddOnDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AddOns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AddOns
     * const addOn = await prisma.addOn.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddOnUpdateManyArgs>(args: SelectSubset<T, AddOnUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AddOn.
     * @param {AddOnUpsertArgs} args - Arguments to update or create a AddOn.
     * @example
     * // Update or create a AddOn
     * const addOn = await prisma.addOn.upsert({
     *   create: {
     *     // ... data to create a AddOn
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AddOn we want to update
     *   }
     * })
     */
    upsert<T extends AddOnUpsertArgs>(args: SelectSubset<T, AddOnUpsertArgs<ExtArgs>>): Prisma__AddOnClient<$Result.GetResult<Prisma.$AddOnPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AddOns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnCountArgs} args - Arguments to filter AddOns to count.
     * @example
     * // Count the number of AddOns
     * const count = await prisma.addOn.count({
     *   where: {
     *     // ... the filter for the AddOns we want to count
     *   }
     * })
    **/
    count<T extends AddOnCountArgs>(
      args?: Subset<T, AddOnCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddOnCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AddOn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddOnAggregateArgs>(args: Subset<T, AddOnAggregateArgs>): Prisma.PrismaPromise<GetAddOnAggregateType<T>>

    /**
     * Group by AddOn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddOnGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddOnGroupByArgs['orderBy'] }
        : { orderBy?: AddOnGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddOnGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddOnGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AddOn model
   */
  readonly fields: AddOnFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AddOn.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddOnClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payment<T extends AddOn$paymentArgs<ExtArgs> = {}>(args?: Subset<T, AddOn$paymentArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AddOn model
   */ 
  interface AddOnFieldRefs {
    readonly id: FieldRef<"AddOn", 'String'>
    readonly userId: FieldRef<"AddOn", 'String'>
    readonly type: FieldRef<"AddOn", 'AddOnType'>
    readonly paymentId: FieldRef<"AddOn", 'String'>
    readonly expiresAt: FieldRef<"AddOn", 'DateTime'>
    readonly isActive: FieldRef<"AddOn", 'Boolean'>
    readonly createdAt: FieldRef<"AddOn", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AddOn findUnique
   */
  export type AddOnFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOn
     */
    select?: AddOnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnInclude<ExtArgs> | null
    /**
     * Filter, which AddOn to fetch.
     */
    where: AddOnWhereUniqueInput
  }

  /**
   * AddOn findUniqueOrThrow
   */
  export type AddOnFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOn
     */
    select?: AddOnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnInclude<ExtArgs> | null
    /**
     * Filter, which AddOn to fetch.
     */
    where: AddOnWhereUniqueInput
  }

  /**
   * AddOn findFirst
   */
  export type AddOnFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOn
     */
    select?: AddOnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnInclude<ExtArgs> | null
    /**
     * Filter, which AddOn to fetch.
     */
    where?: AddOnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddOns to fetch.
     */
    orderBy?: AddOnOrderByWithRelationInput | AddOnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddOns.
     */
    cursor?: AddOnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddOns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddOns.
     */
    distinct?: AddOnScalarFieldEnum | AddOnScalarFieldEnum[]
  }

  /**
   * AddOn findFirstOrThrow
   */
  export type AddOnFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOn
     */
    select?: AddOnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnInclude<ExtArgs> | null
    /**
     * Filter, which AddOn to fetch.
     */
    where?: AddOnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddOns to fetch.
     */
    orderBy?: AddOnOrderByWithRelationInput | AddOnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddOns.
     */
    cursor?: AddOnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddOns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddOns.
     */
    distinct?: AddOnScalarFieldEnum | AddOnScalarFieldEnum[]
  }

  /**
   * AddOn findMany
   */
  export type AddOnFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOn
     */
    select?: AddOnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnInclude<ExtArgs> | null
    /**
     * Filter, which AddOns to fetch.
     */
    where?: AddOnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddOns to fetch.
     */
    orderBy?: AddOnOrderByWithRelationInput | AddOnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AddOns.
     */
    cursor?: AddOnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddOns.
     */
    skip?: number
    distinct?: AddOnScalarFieldEnum | AddOnScalarFieldEnum[]
  }

  /**
   * AddOn create
   */
  export type AddOnCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOn
     */
    select?: AddOnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnInclude<ExtArgs> | null
    /**
     * The data needed to create a AddOn.
     */
    data: XOR<AddOnCreateInput, AddOnUncheckedCreateInput>
  }

  /**
   * AddOn createMany
   */
  export type AddOnCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AddOns.
     */
    data: AddOnCreateManyInput | AddOnCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AddOn createManyAndReturn
   */
  export type AddOnCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOn
     */
    select?: AddOnSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AddOns.
     */
    data: AddOnCreateManyInput | AddOnCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AddOn update
   */
  export type AddOnUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOn
     */
    select?: AddOnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnInclude<ExtArgs> | null
    /**
     * The data needed to update a AddOn.
     */
    data: XOR<AddOnUpdateInput, AddOnUncheckedUpdateInput>
    /**
     * Choose, which AddOn to update.
     */
    where: AddOnWhereUniqueInput
  }

  /**
   * AddOn updateMany
   */
  export type AddOnUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AddOns.
     */
    data: XOR<AddOnUpdateManyMutationInput, AddOnUncheckedUpdateManyInput>
    /**
     * Filter which AddOns to update
     */
    where?: AddOnWhereInput
  }

  /**
   * AddOn upsert
   */
  export type AddOnUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOn
     */
    select?: AddOnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnInclude<ExtArgs> | null
    /**
     * The filter to search for the AddOn to update in case it exists.
     */
    where: AddOnWhereUniqueInput
    /**
     * In case the AddOn found by the `where` argument doesn't exist, create a new AddOn with this data.
     */
    create: XOR<AddOnCreateInput, AddOnUncheckedCreateInput>
    /**
     * In case the AddOn was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddOnUpdateInput, AddOnUncheckedUpdateInput>
  }

  /**
   * AddOn delete
   */
  export type AddOnDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOn
     */
    select?: AddOnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnInclude<ExtArgs> | null
    /**
     * Filter which AddOn to delete.
     */
    where: AddOnWhereUniqueInput
  }

  /**
   * AddOn deleteMany
   */
  export type AddOnDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddOns to delete
     */
    where?: AddOnWhereInput
  }

  /**
   * AddOn.payment
   */
  export type AddOn$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
  }

  /**
   * AddOn without action
   */
  export type AddOnDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOn
     */
    select?: AddOnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    amount: number | null
    rating: number | null
  }

  export type ServiceSumAggregateOutputType = {
    amount: number | null
    rating: number | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.ServiceType | null
    status: $Enums.ServiceStatus | null
    paymentId: string | null
    amount: number | null
    scheduledAt: Date | null
    completedAt: Date | null
    notes: string | null
    rating: number | null
    review: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.ServiceType | null
    status: $Enums.ServiceStatus | null
    paymentId: string | null
    amount: number | null
    scheduledAt: Date | null
    completedAt: Date | null
    notes: string | null
    rating: number | null
    review: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    status: number
    paymentId: number
    amount: number
    metadata: number
    scheduledAt: number
    completedAt: number
    notes: number
    rating: number
    review: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    amount?: true
    rating?: true
  }

  export type ServiceSumAggregateInputType = {
    amount?: true
    rating?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    status?: true
    paymentId?: true
    amount?: true
    scheduledAt?: true
    completedAt?: true
    notes?: true
    rating?: true
    review?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    status?: true
    paymentId?: true
    amount?: true
    scheduledAt?: true
    completedAt?: true
    notes?: true
    rating?: true
    review?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    status?: true
    paymentId?: true
    amount?: true
    metadata?: true
    scheduledAt?: true
    completedAt?: true
    notes?: true
    rating?: true
    review?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.ServiceType
    status: $Enums.ServiceStatus
    paymentId: string | null
    amount: number
    metadata: JsonValue | null
    scheduledAt: Date | null
    completedAt: Date | null
    notes: string | null
    rating: number | null
    review: string | null
    createdAt: Date
    updatedAt: Date
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    status?: boolean
    paymentId?: boolean
    amount?: boolean
    metadata?: boolean
    scheduledAt?: boolean
    completedAt?: boolean
    notes?: boolean
    rating?: boolean
    review?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    payment?: boolean | Service$paymentArgs<ExtArgs>
    bookings?: boolean | Service$bookingsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    status?: boolean
    paymentId?: boolean
    amount?: boolean
    metadata?: boolean
    scheduledAt?: boolean
    completedAt?: boolean
    notes?: boolean
    rating?: boolean
    review?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    payment?: boolean | Service$paymentArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    status?: boolean
    paymentId?: boolean
    amount?: boolean
    metadata?: boolean
    scheduledAt?: boolean
    completedAt?: boolean
    notes?: boolean
    rating?: boolean
    review?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    payment?: boolean | Service$paymentArgs<ExtArgs>
    bookings?: boolean | Service$bookingsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    payment?: boolean | Service$paymentArgs<ExtArgs>
  }

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      payment: Prisma.$PaymentPayload<ExtArgs> | null
      bookings: Prisma.$ServiceBookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.ServiceType
      status: $Enums.ServiceStatus
      paymentId: string | null
      amount: number
      metadata: Prisma.JsonValue | null
      scheduledAt: Date | null
      completedAt: Date | null
      notes: string | null
      rating: number | null
      review: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    payment<T extends Service$paymentArgs<ExtArgs> = {}>(args?: Subset<T, Service$paymentArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    bookings<T extends Service$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Service$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceBookingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */ 
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'String'>
    readonly userId: FieldRef<"Service", 'String'>
    readonly type: FieldRef<"Service", 'ServiceType'>
    readonly status: FieldRef<"Service", 'ServiceStatus'>
    readonly paymentId: FieldRef<"Service", 'String'>
    readonly amount: FieldRef<"Service", 'Int'>
    readonly metadata: FieldRef<"Service", 'Json'>
    readonly scheduledAt: FieldRef<"Service", 'DateTime'>
    readonly completedAt: FieldRef<"Service", 'DateTime'>
    readonly notes: FieldRef<"Service", 'String'>
    readonly rating: FieldRef<"Service", 'Int'>
    readonly review: FieldRef<"Service", 'String'>
    readonly createdAt: FieldRef<"Service", 'DateTime'>
    readonly updatedAt: FieldRef<"Service", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
  }

  /**
   * Service.payment
   */
  export type Service$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
  }

  /**
   * Service.bookings
   */
  export type Service$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBooking
     */
    select?: ServiceBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingInclude<ExtArgs> | null
    where?: ServiceBookingWhereInput
    orderBy?: ServiceBookingOrderByWithRelationInput | ServiceBookingOrderByWithRelationInput[]
    cursor?: ServiceBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceBookingScalarFieldEnum | ServiceBookingScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model ServiceProvider
   */

  export type AggregateServiceProvider = {
    _count: ServiceProviderCountAggregateOutputType | null
    _avg: ServiceProviderAvgAggregateOutputType | null
    _sum: ServiceProviderSumAggregateOutputType | null
    _min: ServiceProviderMinAggregateOutputType | null
    _max: ServiceProviderMaxAggregateOutputType | null
  }

  export type ServiceProviderAvgAggregateOutputType = {
    rating: number | null
    totalBookings: number | null
  }

  export type ServiceProviderSumAggregateOutputType = {
    rating: number | null
    totalBookings: number | null
  }

  export type ServiceProviderMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    mobile: string | null
    serviceType: $Enums.ServiceType | null
    expertise: string | null
    rating: number | null
    totalBookings: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceProviderMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    mobile: string | null
    serviceType: $Enums.ServiceType | null
    expertise: string | null
    rating: number | null
    totalBookings: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceProviderCountAggregateOutputType = {
    id: number
    name: number
    email: number
    mobile: number
    serviceType: number
    expertise: number
    rating: number
    totalBookings: number
    isActive: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceProviderAvgAggregateInputType = {
    rating?: true
    totalBookings?: true
  }

  export type ServiceProviderSumAggregateInputType = {
    rating?: true
    totalBookings?: true
  }

  export type ServiceProviderMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    mobile?: true
    serviceType?: true
    expertise?: true
    rating?: true
    totalBookings?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceProviderMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    mobile?: true
    serviceType?: true
    expertise?: true
    rating?: true
    totalBookings?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceProviderCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    mobile?: true
    serviceType?: true
    expertise?: true
    rating?: true
    totalBookings?: true
    isActive?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceProviderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceProvider to aggregate.
     */
    where?: ServiceProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceProviders to fetch.
     */
    orderBy?: ServiceProviderOrderByWithRelationInput | ServiceProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceProviders
    **/
    _count?: true | ServiceProviderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceProviderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceProviderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceProviderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceProviderMaxAggregateInputType
  }

  export type GetServiceProviderAggregateType<T extends ServiceProviderAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceProvider]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceProvider[P]>
      : GetScalarType<T[P], AggregateServiceProvider[P]>
  }




  export type ServiceProviderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceProviderWhereInput
    orderBy?: ServiceProviderOrderByWithAggregationInput | ServiceProviderOrderByWithAggregationInput[]
    by: ServiceProviderScalarFieldEnum[] | ServiceProviderScalarFieldEnum
    having?: ServiceProviderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceProviderCountAggregateInputType | true
    _avg?: ServiceProviderAvgAggregateInputType
    _sum?: ServiceProviderSumAggregateInputType
    _min?: ServiceProviderMinAggregateInputType
    _max?: ServiceProviderMaxAggregateInputType
  }

  export type ServiceProviderGroupByOutputType = {
    id: string
    name: string
    email: string
    mobile: string
    serviceType: $Enums.ServiceType
    expertise: string | null
    rating: number
    totalBookings: number
    isActive: boolean
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ServiceProviderCountAggregateOutputType | null
    _avg: ServiceProviderAvgAggregateOutputType | null
    _sum: ServiceProviderSumAggregateOutputType | null
    _min: ServiceProviderMinAggregateOutputType | null
    _max: ServiceProviderMaxAggregateOutputType | null
  }

  type GetServiceProviderGroupByPayload<T extends ServiceProviderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceProviderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceProviderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceProviderGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceProviderGroupByOutputType[P]>
        }
      >
    >


  export type ServiceProviderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    mobile?: boolean
    serviceType?: boolean
    expertise?: boolean
    rating?: boolean
    totalBookings?: boolean
    isActive?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookings?: boolean | ServiceProvider$bookingsArgs<ExtArgs>
    _count?: boolean | ServiceProviderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceProvider"]>

  export type ServiceProviderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    mobile?: boolean
    serviceType?: boolean
    expertise?: boolean
    rating?: boolean
    totalBookings?: boolean
    isActive?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["serviceProvider"]>

  export type ServiceProviderSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    mobile?: boolean
    serviceType?: boolean
    expertise?: boolean
    rating?: boolean
    totalBookings?: boolean
    isActive?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceProviderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | ServiceProvider$bookingsArgs<ExtArgs>
    _count?: boolean | ServiceProviderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceProviderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServiceProviderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceProvider"
    objects: {
      bookings: Prisma.$ServiceBookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      mobile: string
      serviceType: $Enums.ServiceType
      expertise: string | null
      rating: number
      totalBookings: number
      isActive: boolean
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["serviceProvider"]>
    composites: {}
  }

  type ServiceProviderGetPayload<S extends boolean | null | undefined | ServiceProviderDefaultArgs> = $Result.GetResult<Prisma.$ServiceProviderPayload, S>

  type ServiceProviderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceProviderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceProviderCountAggregateInputType | true
    }

  export interface ServiceProviderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceProvider'], meta: { name: 'ServiceProvider' } }
    /**
     * Find zero or one ServiceProvider that matches the filter.
     * @param {ServiceProviderFindUniqueArgs} args - Arguments to find a ServiceProvider
     * @example
     * // Get one ServiceProvider
     * const serviceProvider = await prisma.serviceProvider.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceProviderFindUniqueArgs>(args: SelectSubset<T, ServiceProviderFindUniqueArgs<ExtArgs>>): Prisma__ServiceProviderClient<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ServiceProvider that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiceProviderFindUniqueOrThrowArgs} args - Arguments to find a ServiceProvider
     * @example
     * // Get one ServiceProvider
     * const serviceProvider = await prisma.serviceProvider.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceProviderFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceProviderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceProviderClient<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ServiceProvider that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProviderFindFirstArgs} args - Arguments to find a ServiceProvider
     * @example
     * // Get one ServiceProvider
     * const serviceProvider = await prisma.serviceProvider.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceProviderFindFirstArgs>(args?: SelectSubset<T, ServiceProviderFindFirstArgs<ExtArgs>>): Prisma__ServiceProviderClient<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ServiceProvider that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProviderFindFirstOrThrowArgs} args - Arguments to find a ServiceProvider
     * @example
     * // Get one ServiceProvider
     * const serviceProvider = await prisma.serviceProvider.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceProviderFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceProviderFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceProviderClient<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ServiceProviders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProviderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceProviders
     * const serviceProviders = await prisma.serviceProvider.findMany()
     * 
     * // Get first 10 ServiceProviders
     * const serviceProviders = await prisma.serviceProvider.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceProviderWithIdOnly = await prisma.serviceProvider.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceProviderFindManyArgs>(args?: SelectSubset<T, ServiceProviderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ServiceProvider.
     * @param {ServiceProviderCreateArgs} args - Arguments to create a ServiceProvider.
     * @example
     * // Create one ServiceProvider
     * const ServiceProvider = await prisma.serviceProvider.create({
     *   data: {
     *     // ... data to create a ServiceProvider
     *   }
     * })
     * 
     */
    create<T extends ServiceProviderCreateArgs>(args: SelectSubset<T, ServiceProviderCreateArgs<ExtArgs>>): Prisma__ServiceProviderClient<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ServiceProviders.
     * @param {ServiceProviderCreateManyArgs} args - Arguments to create many ServiceProviders.
     * @example
     * // Create many ServiceProviders
     * const serviceProvider = await prisma.serviceProvider.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceProviderCreateManyArgs>(args?: SelectSubset<T, ServiceProviderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceProviders and returns the data saved in the database.
     * @param {ServiceProviderCreateManyAndReturnArgs} args - Arguments to create many ServiceProviders.
     * @example
     * // Create many ServiceProviders
     * const serviceProvider = await prisma.serviceProvider.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceProviders and only return the `id`
     * const serviceProviderWithIdOnly = await prisma.serviceProvider.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceProviderCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceProviderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ServiceProvider.
     * @param {ServiceProviderDeleteArgs} args - Arguments to delete one ServiceProvider.
     * @example
     * // Delete one ServiceProvider
     * const ServiceProvider = await prisma.serviceProvider.delete({
     *   where: {
     *     // ... filter to delete one ServiceProvider
     *   }
     * })
     * 
     */
    delete<T extends ServiceProviderDeleteArgs>(args: SelectSubset<T, ServiceProviderDeleteArgs<ExtArgs>>): Prisma__ServiceProviderClient<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ServiceProvider.
     * @param {ServiceProviderUpdateArgs} args - Arguments to update one ServiceProvider.
     * @example
     * // Update one ServiceProvider
     * const serviceProvider = await prisma.serviceProvider.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceProviderUpdateArgs>(args: SelectSubset<T, ServiceProviderUpdateArgs<ExtArgs>>): Prisma__ServiceProviderClient<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ServiceProviders.
     * @param {ServiceProviderDeleteManyArgs} args - Arguments to filter ServiceProviders to delete.
     * @example
     * // Delete a few ServiceProviders
     * const { count } = await prisma.serviceProvider.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceProviderDeleteManyArgs>(args?: SelectSubset<T, ServiceProviderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceProviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProviderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceProviders
     * const serviceProvider = await prisma.serviceProvider.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceProviderUpdateManyArgs>(args: SelectSubset<T, ServiceProviderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceProvider.
     * @param {ServiceProviderUpsertArgs} args - Arguments to update or create a ServiceProvider.
     * @example
     * // Update or create a ServiceProvider
     * const serviceProvider = await prisma.serviceProvider.upsert({
     *   create: {
     *     // ... data to create a ServiceProvider
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceProvider we want to update
     *   }
     * })
     */
    upsert<T extends ServiceProviderUpsertArgs>(args: SelectSubset<T, ServiceProviderUpsertArgs<ExtArgs>>): Prisma__ServiceProviderClient<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ServiceProviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProviderCountArgs} args - Arguments to filter ServiceProviders to count.
     * @example
     * // Count the number of ServiceProviders
     * const count = await prisma.serviceProvider.count({
     *   where: {
     *     // ... the filter for the ServiceProviders we want to count
     *   }
     * })
    **/
    count<T extends ServiceProviderCountArgs>(
      args?: Subset<T, ServiceProviderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceProviderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceProvider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProviderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceProviderAggregateArgs>(args: Subset<T, ServiceProviderAggregateArgs>): Prisma.PrismaPromise<GetServiceProviderAggregateType<T>>

    /**
     * Group by ServiceProvider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProviderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceProviderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceProviderGroupByArgs['orderBy'] }
        : { orderBy?: ServiceProviderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceProviderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceProviderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceProvider model
   */
  readonly fields: ServiceProviderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceProvider.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceProviderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookings<T extends ServiceProvider$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProvider$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceBookingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceProvider model
   */ 
  interface ServiceProviderFieldRefs {
    readonly id: FieldRef<"ServiceProvider", 'String'>
    readonly name: FieldRef<"ServiceProvider", 'String'>
    readonly email: FieldRef<"ServiceProvider", 'String'>
    readonly mobile: FieldRef<"ServiceProvider", 'String'>
    readonly serviceType: FieldRef<"ServiceProvider", 'ServiceType'>
    readonly expertise: FieldRef<"ServiceProvider", 'String'>
    readonly rating: FieldRef<"ServiceProvider", 'Float'>
    readonly totalBookings: FieldRef<"ServiceProvider", 'Int'>
    readonly isActive: FieldRef<"ServiceProvider", 'Boolean'>
    readonly metadata: FieldRef<"ServiceProvider", 'Json'>
    readonly createdAt: FieldRef<"ServiceProvider", 'DateTime'>
    readonly updatedAt: FieldRef<"ServiceProvider", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceProvider findUnique
   */
  export type ServiceProviderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider
     */
    select?: ServiceProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderInclude<ExtArgs> | null
    /**
     * Filter, which ServiceProvider to fetch.
     */
    where: ServiceProviderWhereUniqueInput
  }

  /**
   * ServiceProvider findUniqueOrThrow
   */
  export type ServiceProviderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider
     */
    select?: ServiceProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderInclude<ExtArgs> | null
    /**
     * Filter, which ServiceProvider to fetch.
     */
    where: ServiceProviderWhereUniqueInput
  }

  /**
   * ServiceProvider findFirst
   */
  export type ServiceProviderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider
     */
    select?: ServiceProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderInclude<ExtArgs> | null
    /**
     * Filter, which ServiceProvider to fetch.
     */
    where?: ServiceProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceProviders to fetch.
     */
    orderBy?: ServiceProviderOrderByWithRelationInput | ServiceProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceProviders.
     */
    cursor?: ServiceProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceProviders.
     */
    distinct?: ServiceProviderScalarFieldEnum | ServiceProviderScalarFieldEnum[]
  }

  /**
   * ServiceProvider findFirstOrThrow
   */
  export type ServiceProviderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider
     */
    select?: ServiceProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderInclude<ExtArgs> | null
    /**
     * Filter, which ServiceProvider to fetch.
     */
    where?: ServiceProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceProviders to fetch.
     */
    orderBy?: ServiceProviderOrderByWithRelationInput | ServiceProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceProviders.
     */
    cursor?: ServiceProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceProviders.
     */
    distinct?: ServiceProviderScalarFieldEnum | ServiceProviderScalarFieldEnum[]
  }

  /**
   * ServiceProvider findMany
   */
  export type ServiceProviderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider
     */
    select?: ServiceProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderInclude<ExtArgs> | null
    /**
     * Filter, which ServiceProviders to fetch.
     */
    where?: ServiceProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceProviders to fetch.
     */
    orderBy?: ServiceProviderOrderByWithRelationInput | ServiceProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceProviders.
     */
    cursor?: ServiceProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceProviders.
     */
    skip?: number
    distinct?: ServiceProviderScalarFieldEnum | ServiceProviderScalarFieldEnum[]
  }

  /**
   * ServiceProvider create
   */
  export type ServiceProviderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider
     */
    select?: ServiceProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceProvider.
     */
    data: XOR<ServiceProviderCreateInput, ServiceProviderUncheckedCreateInput>
  }

  /**
   * ServiceProvider createMany
   */
  export type ServiceProviderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceProviders.
     */
    data: ServiceProviderCreateManyInput | ServiceProviderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceProvider createManyAndReturn
   */
  export type ServiceProviderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider
     */
    select?: ServiceProviderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ServiceProviders.
     */
    data: ServiceProviderCreateManyInput | ServiceProviderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceProvider update
   */
  export type ServiceProviderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider
     */
    select?: ServiceProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceProvider.
     */
    data: XOR<ServiceProviderUpdateInput, ServiceProviderUncheckedUpdateInput>
    /**
     * Choose, which ServiceProvider to update.
     */
    where: ServiceProviderWhereUniqueInput
  }

  /**
   * ServiceProvider updateMany
   */
  export type ServiceProviderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceProviders.
     */
    data: XOR<ServiceProviderUpdateManyMutationInput, ServiceProviderUncheckedUpdateManyInput>
    /**
     * Filter which ServiceProviders to update
     */
    where?: ServiceProviderWhereInput
  }

  /**
   * ServiceProvider upsert
   */
  export type ServiceProviderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider
     */
    select?: ServiceProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceProvider to update in case it exists.
     */
    where: ServiceProviderWhereUniqueInput
    /**
     * In case the ServiceProvider found by the `where` argument doesn't exist, create a new ServiceProvider with this data.
     */
    create: XOR<ServiceProviderCreateInput, ServiceProviderUncheckedCreateInput>
    /**
     * In case the ServiceProvider was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceProviderUpdateInput, ServiceProviderUncheckedUpdateInput>
  }

  /**
   * ServiceProvider delete
   */
  export type ServiceProviderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider
     */
    select?: ServiceProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderInclude<ExtArgs> | null
    /**
     * Filter which ServiceProvider to delete.
     */
    where: ServiceProviderWhereUniqueInput
  }

  /**
   * ServiceProvider deleteMany
   */
  export type ServiceProviderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceProviders to delete
     */
    where?: ServiceProviderWhereInput
  }

  /**
   * ServiceProvider.bookings
   */
  export type ServiceProvider$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBooking
     */
    select?: ServiceBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingInclude<ExtArgs> | null
    where?: ServiceBookingWhereInput
    orderBy?: ServiceBookingOrderByWithRelationInput | ServiceBookingOrderByWithRelationInput[]
    cursor?: ServiceBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceBookingScalarFieldEnum | ServiceBookingScalarFieldEnum[]
  }

  /**
   * ServiceProvider without action
   */
  export type ServiceProviderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider
     */
    select?: ServiceProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderInclude<ExtArgs> | null
  }


  /**
   * Model ServiceBooking
   */

  export type AggregateServiceBooking = {
    _count: ServiceBookingCountAggregateOutputType | null
    _avg: ServiceBookingAvgAggregateOutputType | null
    _sum: ServiceBookingSumAggregateOutputType | null
    _min: ServiceBookingMinAggregateOutputType | null
    _max: ServiceBookingMaxAggregateOutputType | null
  }

  export type ServiceBookingAvgAggregateOutputType = {
    duration: number | null
  }

  export type ServiceBookingSumAggregateOutputType = {
    duration: number | null
  }

  export type ServiceBookingMinAggregateOutputType = {
    id: string | null
    serviceId: string | null
    providerId: string | null
    userId: string | null
    scheduledAt: Date | null
    duration: number | null
    status: $Enums.ServiceStatus | null
    meetingLink: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceBookingMaxAggregateOutputType = {
    id: string | null
    serviceId: string | null
    providerId: string | null
    userId: string | null
    scheduledAt: Date | null
    duration: number | null
    status: $Enums.ServiceStatus | null
    meetingLink: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceBookingCountAggregateOutputType = {
    id: number
    serviceId: number
    providerId: number
    userId: number
    scheduledAt: number
    duration: number
    status: number
    meetingLink: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceBookingAvgAggregateInputType = {
    duration?: true
  }

  export type ServiceBookingSumAggregateInputType = {
    duration?: true
  }

  export type ServiceBookingMinAggregateInputType = {
    id?: true
    serviceId?: true
    providerId?: true
    userId?: true
    scheduledAt?: true
    duration?: true
    status?: true
    meetingLink?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceBookingMaxAggregateInputType = {
    id?: true
    serviceId?: true
    providerId?: true
    userId?: true
    scheduledAt?: true
    duration?: true
    status?: true
    meetingLink?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceBookingCountAggregateInputType = {
    id?: true
    serviceId?: true
    providerId?: true
    userId?: true
    scheduledAt?: true
    duration?: true
    status?: true
    meetingLink?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceBookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceBooking to aggregate.
     */
    where?: ServiceBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceBookings to fetch.
     */
    orderBy?: ServiceBookingOrderByWithRelationInput | ServiceBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceBookings
    **/
    _count?: true | ServiceBookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceBookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceBookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceBookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceBookingMaxAggregateInputType
  }

  export type GetServiceBookingAggregateType<T extends ServiceBookingAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceBooking[P]>
      : GetScalarType<T[P], AggregateServiceBooking[P]>
  }




  export type ServiceBookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceBookingWhereInput
    orderBy?: ServiceBookingOrderByWithAggregationInput | ServiceBookingOrderByWithAggregationInput[]
    by: ServiceBookingScalarFieldEnum[] | ServiceBookingScalarFieldEnum
    having?: ServiceBookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceBookingCountAggregateInputType | true
    _avg?: ServiceBookingAvgAggregateInputType
    _sum?: ServiceBookingSumAggregateInputType
    _min?: ServiceBookingMinAggregateInputType
    _max?: ServiceBookingMaxAggregateInputType
  }

  export type ServiceBookingGroupByOutputType = {
    id: string
    serviceId: string
    providerId: string | null
    userId: string
    scheduledAt: Date | null
    duration: number | null
    status: $Enums.ServiceStatus
    meetingLink: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ServiceBookingCountAggregateOutputType | null
    _avg: ServiceBookingAvgAggregateOutputType | null
    _sum: ServiceBookingSumAggregateOutputType | null
    _min: ServiceBookingMinAggregateOutputType | null
    _max: ServiceBookingMaxAggregateOutputType | null
  }

  type GetServiceBookingGroupByPayload<T extends ServiceBookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceBookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceBookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceBookingGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceBookingGroupByOutputType[P]>
        }
      >
    >


  export type ServiceBookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    providerId?: boolean
    userId?: boolean
    scheduledAt?: boolean
    duration?: boolean
    status?: boolean
    meetingLink?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    provider?: boolean | ServiceBooking$providerArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceBooking"]>

  export type ServiceBookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    providerId?: boolean
    userId?: boolean
    scheduledAt?: boolean
    duration?: boolean
    status?: boolean
    meetingLink?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    provider?: boolean | ServiceBooking$providerArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceBooking"]>

  export type ServiceBookingSelectScalar = {
    id?: boolean
    serviceId?: boolean
    providerId?: boolean
    userId?: boolean
    scheduledAt?: boolean
    duration?: boolean
    status?: boolean
    meetingLink?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceBookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    provider?: boolean | ServiceBooking$providerArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ServiceBookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    provider?: boolean | ServiceBooking$providerArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ServiceBookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceBooking"
    objects: {
      service: Prisma.$ServicePayload<ExtArgs>
      provider: Prisma.$ServiceProviderPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serviceId: string
      providerId: string | null
      userId: string
      scheduledAt: Date | null
      duration: number | null
      status: $Enums.ServiceStatus
      meetingLink: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["serviceBooking"]>
    composites: {}
  }

  type ServiceBookingGetPayload<S extends boolean | null | undefined | ServiceBookingDefaultArgs> = $Result.GetResult<Prisma.$ServiceBookingPayload, S>

  type ServiceBookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceBookingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceBookingCountAggregateInputType | true
    }

  export interface ServiceBookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceBooking'], meta: { name: 'ServiceBooking' } }
    /**
     * Find zero or one ServiceBooking that matches the filter.
     * @param {ServiceBookingFindUniqueArgs} args - Arguments to find a ServiceBooking
     * @example
     * // Get one ServiceBooking
     * const serviceBooking = await prisma.serviceBooking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceBookingFindUniqueArgs>(args: SelectSubset<T, ServiceBookingFindUniqueArgs<ExtArgs>>): Prisma__ServiceBookingClient<$Result.GetResult<Prisma.$ServiceBookingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ServiceBooking that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiceBookingFindUniqueOrThrowArgs} args - Arguments to find a ServiceBooking
     * @example
     * // Get one ServiceBooking
     * const serviceBooking = await prisma.serviceBooking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceBookingFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceBookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceBookingClient<$Result.GetResult<Prisma.$ServiceBookingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ServiceBooking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBookingFindFirstArgs} args - Arguments to find a ServiceBooking
     * @example
     * // Get one ServiceBooking
     * const serviceBooking = await prisma.serviceBooking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceBookingFindFirstArgs>(args?: SelectSubset<T, ServiceBookingFindFirstArgs<ExtArgs>>): Prisma__ServiceBookingClient<$Result.GetResult<Prisma.$ServiceBookingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ServiceBooking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBookingFindFirstOrThrowArgs} args - Arguments to find a ServiceBooking
     * @example
     * // Get one ServiceBooking
     * const serviceBooking = await prisma.serviceBooking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceBookingFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceBookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceBookingClient<$Result.GetResult<Prisma.$ServiceBookingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ServiceBookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceBookings
     * const serviceBookings = await prisma.serviceBooking.findMany()
     * 
     * // Get first 10 ServiceBookings
     * const serviceBookings = await prisma.serviceBooking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceBookingWithIdOnly = await prisma.serviceBooking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceBookingFindManyArgs>(args?: SelectSubset<T, ServiceBookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceBookingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ServiceBooking.
     * @param {ServiceBookingCreateArgs} args - Arguments to create a ServiceBooking.
     * @example
     * // Create one ServiceBooking
     * const ServiceBooking = await prisma.serviceBooking.create({
     *   data: {
     *     // ... data to create a ServiceBooking
     *   }
     * })
     * 
     */
    create<T extends ServiceBookingCreateArgs>(args: SelectSubset<T, ServiceBookingCreateArgs<ExtArgs>>): Prisma__ServiceBookingClient<$Result.GetResult<Prisma.$ServiceBookingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ServiceBookings.
     * @param {ServiceBookingCreateManyArgs} args - Arguments to create many ServiceBookings.
     * @example
     * // Create many ServiceBookings
     * const serviceBooking = await prisma.serviceBooking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceBookingCreateManyArgs>(args?: SelectSubset<T, ServiceBookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceBookings and returns the data saved in the database.
     * @param {ServiceBookingCreateManyAndReturnArgs} args - Arguments to create many ServiceBookings.
     * @example
     * // Create many ServiceBookings
     * const serviceBooking = await prisma.serviceBooking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceBookings and only return the `id`
     * const serviceBookingWithIdOnly = await prisma.serviceBooking.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceBookingCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceBookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceBookingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ServiceBooking.
     * @param {ServiceBookingDeleteArgs} args - Arguments to delete one ServiceBooking.
     * @example
     * // Delete one ServiceBooking
     * const ServiceBooking = await prisma.serviceBooking.delete({
     *   where: {
     *     // ... filter to delete one ServiceBooking
     *   }
     * })
     * 
     */
    delete<T extends ServiceBookingDeleteArgs>(args: SelectSubset<T, ServiceBookingDeleteArgs<ExtArgs>>): Prisma__ServiceBookingClient<$Result.GetResult<Prisma.$ServiceBookingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ServiceBooking.
     * @param {ServiceBookingUpdateArgs} args - Arguments to update one ServiceBooking.
     * @example
     * // Update one ServiceBooking
     * const serviceBooking = await prisma.serviceBooking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceBookingUpdateArgs>(args: SelectSubset<T, ServiceBookingUpdateArgs<ExtArgs>>): Prisma__ServiceBookingClient<$Result.GetResult<Prisma.$ServiceBookingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ServiceBookings.
     * @param {ServiceBookingDeleteManyArgs} args - Arguments to filter ServiceBookings to delete.
     * @example
     * // Delete a few ServiceBookings
     * const { count } = await prisma.serviceBooking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceBookingDeleteManyArgs>(args?: SelectSubset<T, ServiceBookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceBookings
     * const serviceBooking = await prisma.serviceBooking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceBookingUpdateManyArgs>(args: SelectSubset<T, ServiceBookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceBooking.
     * @param {ServiceBookingUpsertArgs} args - Arguments to update or create a ServiceBooking.
     * @example
     * // Update or create a ServiceBooking
     * const serviceBooking = await prisma.serviceBooking.upsert({
     *   create: {
     *     // ... data to create a ServiceBooking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceBooking we want to update
     *   }
     * })
     */
    upsert<T extends ServiceBookingUpsertArgs>(args: SelectSubset<T, ServiceBookingUpsertArgs<ExtArgs>>): Prisma__ServiceBookingClient<$Result.GetResult<Prisma.$ServiceBookingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ServiceBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBookingCountArgs} args - Arguments to filter ServiceBookings to count.
     * @example
     * // Count the number of ServiceBookings
     * const count = await prisma.serviceBooking.count({
     *   where: {
     *     // ... the filter for the ServiceBookings we want to count
     *   }
     * })
    **/
    count<T extends ServiceBookingCountArgs>(
      args?: Subset<T, ServiceBookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceBookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceBookingAggregateArgs>(args: Subset<T, ServiceBookingAggregateArgs>): Prisma.PrismaPromise<GetServiceBookingAggregateType<T>>

    /**
     * Group by ServiceBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceBookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceBookingGroupByArgs['orderBy'] }
        : { orderBy?: ServiceBookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceBookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceBooking model
   */
  readonly fields: ServiceBookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceBooking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceBookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    provider<T extends ServiceBooking$providerArgs<ExtArgs> = {}>(args?: Subset<T, ServiceBooking$providerArgs<ExtArgs>>): Prisma__ServiceProviderClient<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceBooking model
   */ 
  interface ServiceBookingFieldRefs {
    readonly id: FieldRef<"ServiceBooking", 'String'>
    readonly serviceId: FieldRef<"ServiceBooking", 'String'>
    readonly providerId: FieldRef<"ServiceBooking", 'String'>
    readonly userId: FieldRef<"ServiceBooking", 'String'>
    readonly scheduledAt: FieldRef<"ServiceBooking", 'DateTime'>
    readonly duration: FieldRef<"ServiceBooking", 'Int'>
    readonly status: FieldRef<"ServiceBooking", 'ServiceStatus'>
    readonly meetingLink: FieldRef<"ServiceBooking", 'String'>
    readonly notes: FieldRef<"ServiceBooking", 'String'>
    readonly createdAt: FieldRef<"ServiceBooking", 'DateTime'>
    readonly updatedAt: FieldRef<"ServiceBooking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceBooking findUnique
   */
  export type ServiceBookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBooking
     */
    select?: ServiceBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingInclude<ExtArgs> | null
    /**
     * Filter, which ServiceBooking to fetch.
     */
    where: ServiceBookingWhereUniqueInput
  }

  /**
   * ServiceBooking findUniqueOrThrow
   */
  export type ServiceBookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBooking
     */
    select?: ServiceBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingInclude<ExtArgs> | null
    /**
     * Filter, which ServiceBooking to fetch.
     */
    where: ServiceBookingWhereUniqueInput
  }

  /**
   * ServiceBooking findFirst
   */
  export type ServiceBookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBooking
     */
    select?: ServiceBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingInclude<ExtArgs> | null
    /**
     * Filter, which ServiceBooking to fetch.
     */
    where?: ServiceBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceBookings to fetch.
     */
    orderBy?: ServiceBookingOrderByWithRelationInput | ServiceBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceBookings.
     */
    cursor?: ServiceBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceBookings.
     */
    distinct?: ServiceBookingScalarFieldEnum | ServiceBookingScalarFieldEnum[]
  }

  /**
   * ServiceBooking findFirstOrThrow
   */
  export type ServiceBookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBooking
     */
    select?: ServiceBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingInclude<ExtArgs> | null
    /**
     * Filter, which ServiceBooking to fetch.
     */
    where?: ServiceBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceBookings to fetch.
     */
    orderBy?: ServiceBookingOrderByWithRelationInput | ServiceBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceBookings.
     */
    cursor?: ServiceBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceBookings.
     */
    distinct?: ServiceBookingScalarFieldEnum | ServiceBookingScalarFieldEnum[]
  }

  /**
   * ServiceBooking findMany
   */
  export type ServiceBookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBooking
     */
    select?: ServiceBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingInclude<ExtArgs> | null
    /**
     * Filter, which ServiceBookings to fetch.
     */
    where?: ServiceBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceBookings to fetch.
     */
    orderBy?: ServiceBookingOrderByWithRelationInput | ServiceBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceBookings.
     */
    cursor?: ServiceBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceBookings.
     */
    skip?: number
    distinct?: ServiceBookingScalarFieldEnum | ServiceBookingScalarFieldEnum[]
  }

  /**
   * ServiceBooking create
   */
  export type ServiceBookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBooking
     */
    select?: ServiceBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceBooking.
     */
    data: XOR<ServiceBookingCreateInput, ServiceBookingUncheckedCreateInput>
  }

  /**
   * ServiceBooking createMany
   */
  export type ServiceBookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceBookings.
     */
    data: ServiceBookingCreateManyInput | ServiceBookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceBooking createManyAndReturn
   */
  export type ServiceBookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBooking
     */
    select?: ServiceBookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ServiceBookings.
     */
    data: ServiceBookingCreateManyInput | ServiceBookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceBooking update
   */
  export type ServiceBookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBooking
     */
    select?: ServiceBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceBooking.
     */
    data: XOR<ServiceBookingUpdateInput, ServiceBookingUncheckedUpdateInput>
    /**
     * Choose, which ServiceBooking to update.
     */
    where: ServiceBookingWhereUniqueInput
  }

  /**
   * ServiceBooking updateMany
   */
  export type ServiceBookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceBookings.
     */
    data: XOR<ServiceBookingUpdateManyMutationInput, ServiceBookingUncheckedUpdateManyInput>
    /**
     * Filter which ServiceBookings to update
     */
    where?: ServiceBookingWhereInput
  }

  /**
   * ServiceBooking upsert
   */
  export type ServiceBookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBooking
     */
    select?: ServiceBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceBooking to update in case it exists.
     */
    where: ServiceBookingWhereUniqueInput
    /**
     * In case the ServiceBooking found by the `where` argument doesn't exist, create a new ServiceBooking with this data.
     */
    create: XOR<ServiceBookingCreateInput, ServiceBookingUncheckedCreateInput>
    /**
     * In case the ServiceBooking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceBookingUpdateInput, ServiceBookingUncheckedUpdateInput>
  }

  /**
   * ServiceBooking delete
   */
  export type ServiceBookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBooking
     */
    select?: ServiceBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingInclude<ExtArgs> | null
    /**
     * Filter which ServiceBooking to delete.
     */
    where: ServiceBookingWhereUniqueInput
  }

  /**
   * ServiceBooking deleteMany
   */
  export type ServiceBookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceBookings to delete
     */
    where?: ServiceBookingWhereInput
  }

  /**
   * ServiceBooking.provider
   */
  export type ServiceBooking$providerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider
     */
    select?: ServiceProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderInclude<ExtArgs> | null
    where?: ServiceProviderWhereInput
  }

  /**
   * ServiceBooking without action
   */
  export type ServiceBookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBooking
     */
    select?: ServiceBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    message: number
    isRead: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: string
    title: string
    message: string
    isRead: boolean
    metadata: JsonValue | null
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      title: string
      message: string
      isRead: boolean
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly metadata: FieldRef<"Notification", 'Json'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model SavedSearch
   */

  export type AggregateSavedSearch = {
    _count: SavedSearchCountAggregateOutputType | null
    _min: SavedSearchMinAggregateOutputType | null
    _max: SavedSearchMaxAggregateOutputType | null
  }

  export type SavedSearchMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SavedSearchMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SavedSearchCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    filters: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SavedSearchMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SavedSearchMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SavedSearchCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    filters?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SavedSearchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SavedSearch to aggregate.
     */
    where?: SavedSearchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedSearches to fetch.
     */
    orderBy?: SavedSearchOrderByWithRelationInput | SavedSearchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SavedSearchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedSearches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedSearches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SavedSearches
    **/
    _count?: true | SavedSearchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SavedSearchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SavedSearchMaxAggregateInputType
  }

  export type GetSavedSearchAggregateType<T extends SavedSearchAggregateArgs> = {
        [P in keyof T & keyof AggregateSavedSearch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSavedSearch[P]>
      : GetScalarType<T[P], AggregateSavedSearch[P]>
  }




  export type SavedSearchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SavedSearchWhereInput
    orderBy?: SavedSearchOrderByWithAggregationInput | SavedSearchOrderByWithAggregationInput[]
    by: SavedSearchScalarFieldEnum[] | SavedSearchScalarFieldEnum
    having?: SavedSearchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SavedSearchCountAggregateInputType | true
    _min?: SavedSearchMinAggregateInputType
    _max?: SavedSearchMaxAggregateInputType
  }

  export type SavedSearchGroupByOutputType = {
    id: string
    userId: string
    name: string
    filters: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: SavedSearchCountAggregateOutputType | null
    _min: SavedSearchMinAggregateOutputType | null
    _max: SavedSearchMaxAggregateOutputType | null
  }

  type GetSavedSearchGroupByPayload<T extends SavedSearchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SavedSearchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SavedSearchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SavedSearchGroupByOutputType[P]>
            : GetScalarType<T[P], SavedSearchGroupByOutputType[P]>
        }
      >
    >


  export type SavedSearchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    filters?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["savedSearch"]>

  export type SavedSearchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    filters?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["savedSearch"]>

  export type SavedSearchSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    filters?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $SavedSearchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SavedSearch"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      filters: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["savedSearch"]>
    composites: {}
  }

  type SavedSearchGetPayload<S extends boolean | null | undefined | SavedSearchDefaultArgs> = $Result.GetResult<Prisma.$SavedSearchPayload, S>

  type SavedSearchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SavedSearchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SavedSearchCountAggregateInputType | true
    }

  export interface SavedSearchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SavedSearch'], meta: { name: 'SavedSearch' } }
    /**
     * Find zero or one SavedSearch that matches the filter.
     * @param {SavedSearchFindUniqueArgs} args - Arguments to find a SavedSearch
     * @example
     * // Get one SavedSearch
     * const savedSearch = await prisma.savedSearch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SavedSearchFindUniqueArgs>(args: SelectSubset<T, SavedSearchFindUniqueArgs<ExtArgs>>): Prisma__SavedSearchClient<$Result.GetResult<Prisma.$SavedSearchPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SavedSearch that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SavedSearchFindUniqueOrThrowArgs} args - Arguments to find a SavedSearch
     * @example
     * // Get one SavedSearch
     * const savedSearch = await prisma.savedSearch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SavedSearchFindUniqueOrThrowArgs>(args: SelectSubset<T, SavedSearchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SavedSearchClient<$Result.GetResult<Prisma.$SavedSearchPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SavedSearch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedSearchFindFirstArgs} args - Arguments to find a SavedSearch
     * @example
     * // Get one SavedSearch
     * const savedSearch = await prisma.savedSearch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SavedSearchFindFirstArgs>(args?: SelectSubset<T, SavedSearchFindFirstArgs<ExtArgs>>): Prisma__SavedSearchClient<$Result.GetResult<Prisma.$SavedSearchPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SavedSearch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedSearchFindFirstOrThrowArgs} args - Arguments to find a SavedSearch
     * @example
     * // Get one SavedSearch
     * const savedSearch = await prisma.savedSearch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SavedSearchFindFirstOrThrowArgs>(args?: SelectSubset<T, SavedSearchFindFirstOrThrowArgs<ExtArgs>>): Prisma__SavedSearchClient<$Result.GetResult<Prisma.$SavedSearchPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SavedSearches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedSearchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SavedSearches
     * const savedSearches = await prisma.savedSearch.findMany()
     * 
     * // Get first 10 SavedSearches
     * const savedSearches = await prisma.savedSearch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const savedSearchWithIdOnly = await prisma.savedSearch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SavedSearchFindManyArgs>(args?: SelectSubset<T, SavedSearchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedSearchPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SavedSearch.
     * @param {SavedSearchCreateArgs} args - Arguments to create a SavedSearch.
     * @example
     * // Create one SavedSearch
     * const SavedSearch = await prisma.savedSearch.create({
     *   data: {
     *     // ... data to create a SavedSearch
     *   }
     * })
     * 
     */
    create<T extends SavedSearchCreateArgs>(args: SelectSubset<T, SavedSearchCreateArgs<ExtArgs>>): Prisma__SavedSearchClient<$Result.GetResult<Prisma.$SavedSearchPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SavedSearches.
     * @param {SavedSearchCreateManyArgs} args - Arguments to create many SavedSearches.
     * @example
     * // Create many SavedSearches
     * const savedSearch = await prisma.savedSearch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SavedSearchCreateManyArgs>(args?: SelectSubset<T, SavedSearchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SavedSearches and returns the data saved in the database.
     * @param {SavedSearchCreateManyAndReturnArgs} args - Arguments to create many SavedSearches.
     * @example
     * // Create many SavedSearches
     * const savedSearch = await prisma.savedSearch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SavedSearches and only return the `id`
     * const savedSearchWithIdOnly = await prisma.savedSearch.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SavedSearchCreateManyAndReturnArgs>(args?: SelectSubset<T, SavedSearchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedSearchPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SavedSearch.
     * @param {SavedSearchDeleteArgs} args - Arguments to delete one SavedSearch.
     * @example
     * // Delete one SavedSearch
     * const SavedSearch = await prisma.savedSearch.delete({
     *   where: {
     *     // ... filter to delete one SavedSearch
     *   }
     * })
     * 
     */
    delete<T extends SavedSearchDeleteArgs>(args: SelectSubset<T, SavedSearchDeleteArgs<ExtArgs>>): Prisma__SavedSearchClient<$Result.GetResult<Prisma.$SavedSearchPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SavedSearch.
     * @param {SavedSearchUpdateArgs} args - Arguments to update one SavedSearch.
     * @example
     * // Update one SavedSearch
     * const savedSearch = await prisma.savedSearch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SavedSearchUpdateArgs>(args: SelectSubset<T, SavedSearchUpdateArgs<ExtArgs>>): Prisma__SavedSearchClient<$Result.GetResult<Prisma.$SavedSearchPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SavedSearches.
     * @param {SavedSearchDeleteManyArgs} args - Arguments to filter SavedSearches to delete.
     * @example
     * // Delete a few SavedSearches
     * const { count } = await prisma.savedSearch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SavedSearchDeleteManyArgs>(args?: SelectSubset<T, SavedSearchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SavedSearches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedSearchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SavedSearches
     * const savedSearch = await prisma.savedSearch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SavedSearchUpdateManyArgs>(args: SelectSubset<T, SavedSearchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SavedSearch.
     * @param {SavedSearchUpsertArgs} args - Arguments to update or create a SavedSearch.
     * @example
     * // Update or create a SavedSearch
     * const savedSearch = await prisma.savedSearch.upsert({
     *   create: {
     *     // ... data to create a SavedSearch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SavedSearch we want to update
     *   }
     * })
     */
    upsert<T extends SavedSearchUpsertArgs>(args: SelectSubset<T, SavedSearchUpsertArgs<ExtArgs>>): Prisma__SavedSearchClient<$Result.GetResult<Prisma.$SavedSearchPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SavedSearches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedSearchCountArgs} args - Arguments to filter SavedSearches to count.
     * @example
     * // Count the number of SavedSearches
     * const count = await prisma.savedSearch.count({
     *   where: {
     *     // ... the filter for the SavedSearches we want to count
     *   }
     * })
    **/
    count<T extends SavedSearchCountArgs>(
      args?: Subset<T, SavedSearchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SavedSearchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SavedSearch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedSearchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SavedSearchAggregateArgs>(args: Subset<T, SavedSearchAggregateArgs>): Prisma.PrismaPromise<GetSavedSearchAggregateType<T>>

    /**
     * Group by SavedSearch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedSearchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SavedSearchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SavedSearchGroupByArgs['orderBy'] }
        : { orderBy?: SavedSearchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SavedSearchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSavedSearchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SavedSearch model
   */
  readonly fields: SavedSearchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SavedSearch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SavedSearchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SavedSearch model
   */ 
  interface SavedSearchFieldRefs {
    readonly id: FieldRef<"SavedSearch", 'String'>
    readonly userId: FieldRef<"SavedSearch", 'String'>
    readonly name: FieldRef<"SavedSearch", 'String'>
    readonly filters: FieldRef<"SavedSearch", 'Json'>
    readonly createdAt: FieldRef<"SavedSearch", 'DateTime'>
    readonly updatedAt: FieldRef<"SavedSearch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SavedSearch findUnique
   */
  export type SavedSearchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedSearch
     */
    select?: SavedSearchSelect<ExtArgs> | null
    /**
     * Filter, which SavedSearch to fetch.
     */
    where: SavedSearchWhereUniqueInput
  }

  /**
   * SavedSearch findUniqueOrThrow
   */
  export type SavedSearchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedSearch
     */
    select?: SavedSearchSelect<ExtArgs> | null
    /**
     * Filter, which SavedSearch to fetch.
     */
    where: SavedSearchWhereUniqueInput
  }

  /**
   * SavedSearch findFirst
   */
  export type SavedSearchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedSearch
     */
    select?: SavedSearchSelect<ExtArgs> | null
    /**
     * Filter, which SavedSearch to fetch.
     */
    where?: SavedSearchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedSearches to fetch.
     */
    orderBy?: SavedSearchOrderByWithRelationInput | SavedSearchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SavedSearches.
     */
    cursor?: SavedSearchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedSearches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedSearches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SavedSearches.
     */
    distinct?: SavedSearchScalarFieldEnum | SavedSearchScalarFieldEnum[]
  }

  /**
   * SavedSearch findFirstOrThrow
   */
  export type SavedSearchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedSearch
     */
    select?: SavedSearchSelect<ExtArgs> | null
    /**
     * Filter, which SavedSearch to fetch.
     */
    where?: SavedSearchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedSearches to fetch.
     */
    orderBy?: SavedSearchOrderByWithRelationInput | SavedSearchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SavedSearches.
     */
    cursor?: SavedSearchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedSearches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedSearches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SavedSearches.
     */
    distinct?: SavedSearchScalarFieldEnum | SavedSearchScalarFieldEnum[]
  }

  /**
   * SavedSearch findMany
   */
  export type SavedSearchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedSearch
     */
    select?: SavedSearchSelect<ExtArgs> | null
    /**
     * Filter, which SavedSearches to fetch.
     */
    where?: SavedSearchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedSearches to fetch.
     */
    orderBy?: SavedSearchOrderByWithRelationInput | SavedSearchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SavedSearches.
     */
    cursor?: SavedSearchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedSearches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedSearches.
     */
    skip?: number
    distinct?: SavedSearchScalarFieldEnum | SavedSearchScalarFieldEnum[]
  }

  /**
   * SavedSearch create
   */
  export type SavedSearchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedSearch
     */
    select?: SavedSearchSelect<ExtArgs> | null
    /**
     * The data needed to create a SavedSearch.
     */
    data: XOR<SavedSearchCreateInput, SavedSearchUncheckedCreateInput>
  }

  /**
   * SavedSearch createMany
   */
  export type SavedSearchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SavedSearches.
     */
    data: SavedSearchCreateManyInput | SavedSearchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SavedSearch createManyAndReturn
   */
  export type SavedSearchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedSearch
     */
    select?: SavedSearchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SavedSearches.
     */
    data: SavedSearchCreateManyInput | SavedSearchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SavedSearch update
   */
  export type SavedSearchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedSearch
     */
    select?: SavedSearchSelect<ExtArgs> | null
    /**
     * The data needed to update a SavedSearch.
     */
    data: XOR<SavedSearchUpdateInput, SavedSearchUncheckedUpdateInput>
    /**
     * Choose, which SavedSearch to update.
     */
    where: SavedSearchWhereUniqueInput
  }

  /**
   * SavedSearch updateMany
   */
  export type SavedSearchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SavedSearches.
     */
    data: XOR<SavedSearchUpdateManyMutationInput, SavedSearchUncheckedUpdateManyInput>
    /**
     * Filter which SavedSearches to update
     */
    where?: SavedSearchWhereInput
  }

  /**
   * SavedSearch upsert
   */
  export type SavedSearchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedSearch
     */
    select?: SavedSearchSelect<ExtArgs> | null
    /**
     * The filter to search for the SavedSearch to update in case it exists.
     */
    where: SavedSearchWhereUniqueInput
    /**
     * In case the SavedSearch found by the `where` argument doesn't exist, create a new SavedSearch with this data.
     */
    create: XOR<SavedSearchCreateInput, SavedSearchUncheckedCreateInput>
    /**
     * In case the SavedSearch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SavedSearchUpdateInput, SavedSearchUncheckedUpdateInput>
  }

  /**
   * SavedSearch delete
   */
  export type SavedSearchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedSearch
     */
    select?: SavedSearchSelect<ExtArgs> | null
    /**
     * Filter which SavedSearch to delete.
     */
    where: SavedSearchWhereUniqueInput
  }

  /**
   * SavedSearch deleteMany
   */
  export type SavedSearchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SavedSearches to delete
     */
    where?: SavedSearchWhereInput
  }

  /**
   * SavedSearch without action
   */
  export type SavedSearchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedSearch
     */
    select?: SavedSearchSelect<ExtArgs> | null
  }


  /**
   * Model OTP
   */

  export type AggregateOTP = {
    _count: OTPCountAggregateOutputType | null
    _min: OTPMinAggregateOutputType | null
    _max: OTPMaxAggregateOutputType | null
  }

  export type OTPMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    code: string | null
    type: string | null
    expiresAt: Date | null
    isUsed: boolean | null
    createdAt: Date | null
  }

  export type OTPMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    code: string | null
    type: string | null
    expiresAt: Date | null
    isUsed: boolean | null
    createdAt: Date | null
  }

  export type OTPCountAggregateOutputType = {
    id: number
    identifier: number
    code: number
    type: number
    expiresAt: number
    isUsed: number
    createdAt: number
    _all: number
  }


  export type OTPMinAggregateInputType = {
    id?: true
    identifier?: true
    code?: true
    type?: true
    expiresAt?: true
    isUsed?: true
    createdAt?: true
  }

  export type OTPMaxAggregateInputType = {
    id?: true
    identifier?: true
    code?: true
    type?: true
    expiresAt?: true
    isUsed?: true
    createdAt?: true
  }

  export type OTPCountAggregateInputType = {
    id?: true
    identifier?: true
    code?: true
    type?: true
    expiresAt?: true
    isUsed?: true
    createdAt?: true
    _all?: true
  }

  export type OTPAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OTP to aggregate.
     */
    where?: OTPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OTPS to fetch.
     */
    orderBy?: OTPOrderByWithRelationInput | OTPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OTPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OTPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OTPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OTPS
    **/
    _count?: true | OTPCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OTPMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OTPMaxAggregateInputType
  }

  export type GetOTPAggregateType<T extends OTPAggregateArgs> = {
        [P in keyof T & keyof AggregateOTP]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOTP[P]>
      : GetScalarType<T[P], AggregateOTP[P]>
  }




  export type OTPGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OTPWhereInput
    orderBy?: OTPOrderByWithAggregationInput | OTPOrderByWithAggregationInput[]
    by: OTPScalarFieldEnum[] | OTPScalarFieldEnum
    having?: OTPScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OTPCountAggregateInputType | true
    _min?: OTPMinAggregateInputType
    _max?: OTPMaxAggregateInputType
  }

  export type OTPGroupByOutputType = {
    id: string
    identifier: string
    code: string
    type: string
    expiresAt: Date
    isUsed: boolean
    createdAt: Date
    _count: OTPCountAggregateOutputType | null
    _min: OTPMinAggregateOutputType | null
    _max: OTPMaxAggregateOutputType | null
  }

  type GetOTPGroupByPayload<T extends OTPGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OTPGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OTPGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OTPGroupByOutputType[P]>
            : GetScalarType<T[P], OTPGroupByOutputType[P]>
        }
      >
    >


  export type OTPSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    code?: boolean
    type?: boolean
    expiresAt?: boolean
    isUsed?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["oTP"]>

  export type OTPSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    code?: boolean
    type?: boolean
    expiresAt?: boolean
    isUsed?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["oTP"]>

  export type OTPSelectScalar = {
    id?: boolean
    identifier?: boolean
    code?: boolean
    type?: boolean
    expiresAt?: boolean
    isUsed?: boolean
    createdAt?: boolean
  }


  export type $OTPPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OTP"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      code: string
      type: string
      expiresAt: Date
      isUsed: boolean
      createdAt: Date
    }, ExtArgs["result"]["oTP"]>
    composites: {}
  }

  type OTPGetPayload<S extends boolean | null | undefined | OTPDefaultArgs> = $Result.GetResult<Prisma.$OTPPayload, S>

  type OTPCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OTPFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OTPCountAggregateInputType | true
    }

  export interface OTPDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OTP'], meta: { name: 'OTP' } }
    /**
     * Find zero or one OTP that matches the filter.
     * @param {OTPFindUniqueArgs} args - Arguments to find a OTP
     * @example
     * // Get one OTP
     * const oTP = await prisma.oTP.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OTPFindUniqueArgs>(args: SelectSubset<T, OTPFindUniqueArgs<ExtArgs>>): Prisma__OTPClient<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OTP that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OTPFindUniqueOrThrowArgs} args - Arguments to find a OTP
     * @example
     * // Get one OTP
     * const oTP = await prisma.oTP.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OTPFindUniqueOrThrowArgs>(args: SelectSubset<T, OTPFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OTPClient<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OTP that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPFindFirstArgs} args - Arguments to find a OTP
     * @example
     * // Get one OTP
     * const oTP = await prisma.oTP.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OTPFindFirstArgs>(args?: SelectSubset<T, OTPFindFirstArgs<ExtArgs>>): Prisma__OTPClient<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OTP that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPFindFirstOrThrowArgs} args - Arguments to find a OTP
     * @example
     * // Get one OTP
     * const oTP = await prisma.oTP.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OTPFindFirstOrThrowArgs>(args?: SelectSubset<T, OTPFindFirstOrThrowArgs<ExtArgs>>): Prisma__OTPClient<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OTPS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OTPS
     * const oTPS = await prisma.oTP.findMany()
     * 
     * // Get first 10 OTPS
     * const oTPS = await prisma.oTP.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oTPWithIdOnly = await prisma.oTP.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OTPFindManyArgs>(args?: SelectSubset<T, OTPFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OTP.
     * @param {OTPCreateArgs} args - Arguments to create a OTP.
     * @example
     * // Create one OTP
     * const OTP = await prisma.oTP.create({
     *   data: {
     *     // ... data to create a OTP
     *   }
     * })
     * 
     */
    create<T extends OTPCreateArgs>(args: SelectSubset<T, OTPCreateArgs<ExtArgs>>): Prisma__OTPClient<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OTPS.
     * @param {OTPCreateManyArgs} args - Arguments to create many OTPS.
     * @example
     * // Create many OTPS
     * const oTP = await prisma.oTP.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OTPCreateManyArgs>(args?: SelectSubset<T, OTPCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OTPS and returns the data saved in the database.
     * @param {OTPCreateManyAndReturnArgs} args - Arguments to create many OTPS.
     * @example
     * // Create many OTPS
     * const oTP = await prisma.oTP.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OTPS and only return the `id`
     * const oTPWithIdOnly = await prisma.oTP.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OTPCreateManyAndReturnArgs>(args?: SelectSubset<T, OTPCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OTP.
     * @param {OTPDeleteArgs} args - Arguments to delete one OTP.
     * @example
     * // Delete one OTP
     * const OTP = await prisma.oTP.delete({
     *   where: {
     *     // ... filter to delete one OTP
     *   }
     * })
     * 
     */
    delete<T extends OTPDeleteArgs>(args: SelectSubset<T, OTPDeleteArgs<ExtArgs>>): Prisma__OTPClient<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OTP.
     * @param {OTPUpdateArgs} args - Arguments to update one OTP.
     * @example
     * // Update one OTP
     * const oTP = await prisma.oTP.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OTPUpdateArgs>(args: SelectSubset<T, OTPUpdateArgs<ExtArgs>>): Prisma__OTPClient<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OTPS.
     * @param {OTPDeleteManyArgs} args - Arguments to filter OTPS to delete.
     * @example
     * // Delete a few OTPS
     * const { count } = await prisma.oTP.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OTPDeleteManyArgs>(args?: SelectSubset<T, OTPDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OTPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OTPS
     * const oTP = await prisma.oTP.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OTPUpdateManyArgs>(args: SelectSubset<T, OTPUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OTP.
     * @param {OTPUpsertArgs} args - Arguments to update or create a OTP.
     * @example
     * // Update or create a OTP
     * const oTP = await prisma.oTP.upsert({
     *   create: {
     *     // ... data to create a OTP
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OTP we want to update
     *   }
     * })
     */
    upsert<T extends OTPUpsertArgs>(args: SelectSubset<T, OTPUpsertArgs<ExtArgs>>): Prisma__OTPClient<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OTPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPCountArgs} args - Arguments to filter OTPS to count.
     * @example
     * // Count the number of OTPS
     * const count = await prisma.oTP.count({
     *   where: {
     *     // ... the filter for the OTPS we want to count
     *   }
     * })
    **/
    count<T extends OTPCountArgs>(
      args?: Subset<T, OTPCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OTPCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OTP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OTPAggregateArgs>(args: Subset<T, OTPAggregateArgs>): Prisma.PrismaPromise<GetOTPAggregateType<T>>

    /**
     * Group by OTP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OTPGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OTPGroupByArgs['orderBy'] }
        : { orderBy?: OTPGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OTPGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOTPGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OTP model
   */
  readonly fields: OTPFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OTP.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OTPClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OTP model
   */ 
  interface OTPFieldRefs {
    readonly id: FieldRef<"OTP", 'String'>
    readonly identifier: FieldRef<"OTP", 'String'>
    readonly code: FieldRef<"OTP", 'String'>
    readonly type: FieldRef<"OTP", 'String'>
    readonly expiresAt: FieldRef<"OTP", 'DateTime'>
    readonly isUsed: FieldRef<"OTP", 'Boolean'>
    readonly createdAt: FieldRef<"OTP", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OTP findUnique
   */
  export type OTPFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Filter, which OTP to fetch.
     */
    where: OTPWhereUniqueInput
  }

  /**
   * OTP findUniqueOrThrow
   */
  export type OTPFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Filter, which OTP to fetch.
     */
    where: OTPWhereUniqueInput
  }

  /**
   * OTP findFirst
   */
  export type OTPFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Filter, which OTP to fetch.
     */
    where?: OTPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OTPS to fetch.
     */
    orderBy?: OTPOrderByWithRelationInput | OTPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OTPS.
     */
    cursor?: OTPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OTPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OTPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OTPS.
     */
    distinct?: OTPScalarFieldEnum | OTPScalarFieldEnum[]
  }

  /**
   * OTP findFirstOrThrow
   */
  export type OTPFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Filter, which OTP to fetch.
     */
    where?: OTPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OTPS to fetch.
     */
    orderBy?: OTPOrderByWithRelationInput | OTPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OTPS.
     */
    cursor?: OTPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OTPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OTPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OTPS.
     */
    distinct?: OTPScalarFieldEnum | OTPScalarFieldEnum[]
  }

  /**
   * OTP findMany
   */
  export type OTPFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Filter, which OTPS to fetch.
     */
    where?: OTPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OTPS to fetch.
     */
    orderBy?: OTPOrderByWithRelationInput | OTPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OTPS.
     */
    cursor?: OTPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OTPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OTPS.
     */
    skip?: number
    distinct?: OTPScalarFieldEnum | OTPScalarFieldEnum[]
  }

  /**
   * OTP create
   */
  export type OTPCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * The data needed to create a OTP.
     */
    data: XOR<OTPCreateInput, OTPUncheckedCreateInput>
  }

  /**
   * OTP createMany
   */
  export type OTPCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OTPS.
     */
    data: OTPCreateManyInput | OTPCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OTP createManyAndReturn
   */
  export type OTPCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OTPS.
     */
    data: OTPCreateManyInput | OTPCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OTP update
   */
  export type OTPUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * The data needed to update a OTP.
     */
    data: XOR<OTPUpdateInput, OTPUncheckedUpdateInput>
    /**
     * Choose, which OTP to update.
     */
    where: OTPWhereUniqueInput
  }

  /**
   * OTP updateMany
   */
  export type OTPUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OTPS.
     */
    data: XOR<OTPUpdateManyMutationInput, OTPUncheckedUpdateManyInput>
    /**
     * Filter which OTPS to update
     */
    where?: OTPWhereInput
  }

  /**
   * OTP upsert
   */
  export type OTPUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * The filter to search for the OTP to update in case it exists.
     */
    where: OTPWhereUniqueInput
    /**
     * In case the OTP found by the `where` argument doesn't exist, create a new OTP with this data.
     */
    create: XOR<OTPCreateInput, OTPUncheckedCreateInput>
    /**
     * In case the OTP was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OTPUpdateInput, OTPUncheckedUpdateInput>
  }

  /**
   * OTP delete
   */
  export type OTPDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Filter which OTP to delete.
     */
    where: OTPWhereUniqueInput
  }

  /**
   * OTP deleteMany
   */
  export type OTPDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OTPS to delete
     */
    where?: OTPWhereInput
  }

  /**
   * OTP without action
   */
  export type OTPDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
  }


  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: string
    email: string
    password: string
    name: string
    role: string
    createdAt: Date
    updatedAt: Date
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      name: string
      role: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */ 
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'String'>
    readonly email: FieldRef<"Admin", 'String'>
    readonly password: FieldRef<"Admin", 'String'>
    readonly name: FieldRef<"Admin", 'String'>
    readonly role: FieldRef<"Admin", 'String'>
    readonly createdAt: FieldRef<"Admin", 'DateTime'>
    readonly updatedAt: FieldRef<"Admin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin createManyAndReturn
   */
  export type AdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
  }


  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportMinAggregateOutputType = {
    id: string | null
    reporterId: string | null
    reportedUserId: string | null
    type: string | null
    reason: string | null
    description: string | null
    status: string | null
    reviewedBy: string | null
    reviewedAt: Date | null
    createdAt: Date | null
  }

  export type ReportMaxAggregateOutputType = {
    id: string | null
    reporterId: string | null
    reportedUserId: string | null
    type: string | null
    reason: string | null
    description: string | null
    status: string | null
    reviewedBy: string | null
    reviewedAt: Date | null
    createdAt: Date | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    reporterId: number
    reportedUserId: number
    type: number
    reason: number
    description: number
    status: number
    reviewedBy: number
    reviewedAt: number
    createdAt: number
    _all: number
  }


  export type ReportMinAggregateInputType = {
    id?: true
    reporterId?: true
    reportedUserId?: true
    type?: true
    reason?: true
    description?: true
    status?: true
    reviewedBy?: true
    reviewedAt?: true
    createdAt?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    reporterId?: true
    reportedUserId?: true
    type?: true
    reason?: true
    description?: true
    status?: true
    reviewedBy?: true
    reviewedAt?: true
    createdAt?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    reporterId?: true
    reportedUserId?: true
    type?: true
    reason?: true
    description?: true
    status?: true
    reviewedBy?: true
    reviewedAt?: true
    createdAt?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithAggregationInput | ReportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    id: string
    reporterId: string
    reportedUserId: string
    type: string
    reason: string
    description: string | null
    status: string
    reviewedBy: string | null
    reviewedAt: Date | null
    createdAt: Date
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reporterId?: boolean
    reportedUserId?: boolean
    type?: boolean
    reason?: boolean
    description?: boolean
    status?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["report"]>

  export type ReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reporterId?: boolean
    reportedUserId?: boolean
    type?: boolean
    reason?: boolean
    description?: boolean
    status?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["report"]>

  export type ReportSelectScalar = {
    id?: boolean
    reporterId?: boolean
    reportedUserId?: boolean
    type?: boolean
    reason?: boolean
    description?: boolean
    status?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
  }


  export type $ReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Report"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reporterId: string
      reportedUserId: string
      type: string
      reason: string
      description: string | null
      status: string
      reviewedBy: string | null
      reviewedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["report"]>
    composites: {}
  }

  type ReportGetPayload<S extends boolean | null | undefined | ReportDefaultArgs> = $Result.GetResult<Prisma.$ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportFindUniqueArgs>(args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Report that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportFindFirstArgs>(args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportFindManyArgs>(args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
     */
    create<T extends ReportCreateArgs>(args: SelectSubset<T, ReportCreateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reports.
     * @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportCreateManyArgs>(args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reports and returns the data saved in the database.
     * @param {ReportCreateManyAndReturnArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reports and only return the `id`
     * const reportWithIdOnly = await prisma.report.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
     */
    delete<T extends ReportDeleteArgs>(args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportUpdateArgs>(args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportDeleteManyArgs>(args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportUpdateManyArgs>(args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
     */
    upsert<T extends ReportUpsertArgs>(args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Report model
   */
  readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Report model
   */ 
  interface ReportFieldRefs {
    readonly id: FieldRef<"Report", 'String'>
    readonly reporterId: FieldRef<"Report", 'String'>
    readonly reportedUserId: FieldRef<"Report", 'String'>
    readonly type: FieldRef<"Report", 'String'>
    readonly reason: FieldRef<"Report", 'String'>
    readonly description: FieldRef<"Report", 'String'>
    readonly status: FieldRef<"Report", 'String'>
    readonly reviewedBy: FieldRef<"Report", 'String'>
    readonly reviewedAt: FieldRef<"Report", 'DateTime'>
    readonly createdAt: FieldRef<"Report", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }

  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Report createManyAndReturn
   */
  export type ReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
  }

  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }

  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
  }

  /**
   * Report without action
   */
  export type ReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
  }


  /**
   * Model Shortlist
   */

  export type AggregateShortlist = {
    _count: ShortlistCountAggregateOutputType | null
    _min: ShortlistMinAggregateOutputType | null
    _max: ShortlistMaxAggregateOutputType | null
  }

  export type ShortlistMinAggregateOutputType = {
    id: string | null
    userId: string | null
    profileId: string | null
    folderName: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShortlistMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    profileId: string | null
    folderName: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShortlistCountAggregateOutputType = {
    id: number
    userId: number
    profileId: number
    folderName: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShortlistMinAggregateInputType = {
    id?: true
    userId?: true
    profileId?: true
    folderName?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShortlistMaxAggregateInputType = {
    id?: true
    userId?: true
    profileId?: true
    folderName?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShortlistCountAggregateInputType = {
    id?: true
    userId?: true
    profileId?: true
    folderName?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShortlistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shortlist to aggregate.
     */
    where?: ShortlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shortlists to fetch.
     */
    orderBy?: ShortlistOrderByWithRelationInput | ShortlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShortlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shortlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shortlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shortlists
    **/
    _count?: true | ShortlistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShortlistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShortlistMaxAggregateInputType
  }

  export type GetShortlistAggregateType<T extends ShortlistAggregateArgs> = {
        [P in keyof T & keyof AggregateShortlist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShortlist[P]>
      : GetScalarType<T[P], AggregateShortlist[P]>
  }




  export type ShortlistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShortlistWhereInput
    orderBy?: ShortlistOrderByWithAggregationInput | ShortlistOrderByWithAggregationInput[]
    by: ShortlistScalarFieldEnum[] | ShortlistScalarFieldEnum
    having?: ShortlistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShortlistCountAggregateInputType | true
    _min?: ShortlistMinAggregateInputType
    _max?: ShortlistMaxAggregateInputType
  }

  export type ShortlistGroupByOutputType = {
    id: string
    userId: string
    profileId: string
    folderName: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ShortlistCountAggregateOutputType | null
    _min: ShortlistMinAggregateOutputType | null
    _max: ShortlistMaxAggregateOutputType | null
  }

  type GetShortlistGroupByPayload<T extends ShortlistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShortlistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShortlistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShortlistGroupByOutputType[P]>
            : GetScalarType<T[P], ShortlistGroupByOutputType[P]>
        }
      >
    >


  export type ShortlistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    profileId?: boolean
    folderName?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shortlist"]>

  export type ShortlistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    profileId?: boolean
    folderName?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shortlist"]>

  export type ShortlistSelectScalar = {
    id?: boolean
    userId?: boolean
    profileId?: boolean
    folderName?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShortlistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type ShortlistIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $ShortlistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shortlist"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      profile: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      profileId: string
      folderName: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shortlist"]>
    composites: {}
  }

  type ShortlistGetPayload<S extends boolean | null | undefined | ShortlistDefaultArgs> = $Result.GetResult<Prisma.$ShortlistPayload, S>

  type ShortlistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShortlistFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ShortlistCountAggregateInputType | true
    }

  export interface ShortlistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shortlist'], meta: { name: 'Shortlist' } }
    /**
     * Find zero or one Shortlist that matches the filter.
     * @param {ShortlistFindUniqueArgs} args - Arguments to find a Shortlist
     * @example
     * // Get one Shortlist
     * const shortlist = await prisma.shortlist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShortlistFindUniqueArgs>(args: SelectSubset<T, ShortlistFindUniqueArgs<ExtArgs>>): Prisma__ShortlistClient<$Result.GetResult<Prisma.$ShortlistPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Shortlist that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ShortlistFindUniqueOrThrowArgs} args - Arguments to find a Shortlist
     * @example
     * // Get one Shortlist
     * const shortlist = await prisma.shortlist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShortlistFindUniqueOrThrowArgs>(args: SelectSubset<T, ShortlistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShortlistClient<$Result.GetResult<Prisma.$ShortlistPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Shortlist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShortlistFindFirstArgs} args - Arguments to find a Shortlist
     * @example
     * // Get one Shortlist
     * const shortlist = await prisma.shortlist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShortlistFindFirstArgs>(args?: SelectSubset<T, ShortlistFindFirstArgs<ExtArgs>>): Prisma__ShortlistClient<$Result.GetResult<Prisma.$ShortlistPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Shortlist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShortlistFindFirstOrThrowArgs} args - Arguments to find a Shortlist
     * @example
     * // Get one Shortlist
     * const shortlist = await prisma.shortlist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShortlistFindFirstOrThrowArgs>(args?: SelectSubset<T, ShortlistFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShortlistClient<$Result.GetResult<Prisma.$ShortlistPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Shortlists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShortlistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shortlists
     * const shortlists = await prisma.shortlist.findMany()
     * 
     * // Get first 10 Shortlists
     * const shortlists = await prisma.shortlist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shortlistWithIdOnly = await prisma.shortlist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShortlistFindManyArgs>(args?: SelectSubset<T, ShortlistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShortlistPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Shortlist.
     * @param {ShortlistCreateArgs} args - Arguments to create a Shortlist.
     * @example
     * // Create one Shortlist
     * const Shortlist = await prisma.shortlist.create({
     *   data: {
     *     // ... data to create a Shortlist
     *   }
     * })
     * 
     */
    create<T extends ShortlistCreateArgs>(args: SelectSubset<T, ShortlistCreateArgs<ExtArgs>>): Prisma__ShortlistClient<$Result.GetResult<Prisma.$ShortlistPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Shortlists.
     * @param {ShortlistCreateManyArgs} args - Arguments to create many Shortlists.
     * @example
     * // Create many Shortlists
     * const shortlist = await prisma.shortlist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShortlistCreateManyArgs>(args?: SelectSubset<T, ShortlistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Shortlists and returns the data saved in the database.
     * @param {ShortlistCreateManyAndReturnArgs} args - Arguments to create many Shortlists.
     * @example
     * // Create many Shortlists
     * const shortlist = await prisma.shortlist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Shortlists and only return the `id`
     * const shortlistWithIdOnly = await prisma.shortlist.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShortlistCreateManyAndReturnArgs>(args?: SelectSubset<T, ShortlistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShortlistPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Shortlist.
     * @param {ShortlistDeleteArgs} args - Arguments to delete one Shortlist.
     * @example
     * // Delete one Shortlist
     * const Shortlist = await prisma.shortlist.delete({
     *   where: {
     *     // ... filter to delete one Shortlist
     *   }
     * })
     * 
     */
    delete<T extends ShortlistDeleteArgs>(args: SelectSubset<T, ShortlistDeleteArgs<ExtArgs>>): Prisma__ShortlistClient<$Result.GetResult<Prisma.$ShortlistPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Shortlist.
     * @param {ShortlistUpdateArgs} args - Arguments to update one Shortlist.
     * @example
     * // Update one Shortlist
     * const shortlist = await prisma.shortlist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShortlistUpdateArgs>(args: SelectSubset<T, ShortlistUpdateArgs<ExtArgs>>): Prisma__ShortlistClient<$Result.GetResult<Prisma.$ShortlistPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Shortlists.
     * @param {ShortlistDeleteManyArgs} args - Arguments to filter Shortlists to delete.
     * @example
     * // Delete a few Shortlists
     * const { count } = await prisma.shortlist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShortlistDeleteManyArgs>(args?: SelectSubset<T, ShortlistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shortlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShortlistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shortlists
     * const shortlist = await prisma.shortlist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShortlistUpdateManyArgs>(args: SelectSubset<T, ShortlistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Shortlist.
     * @param {ShortlistUpsertArgs} args - Arguments to update or create a Shortlist.
     * @example
     * // Update or create a Shortlist
     * const shortlist = await prisma.shortlist.upsert({
     *   create: {
     *     // ... data to create a Shortlist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shortlist we want to update
     *   }
     * })
     */
    upsert<T extends ShortlistUpsertArgs>(args: SelectSubset<T, ShortlistUpsertArgs<ExtArgs>>): Prisma__ShortlistClient<$Result.GetResult<Prisma.$ShortlistPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Shortlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShortlistCountArgs} args - Arguments to filter Shortlists to count.
     * @example
     * // Count the number of Shortlists
     * const count = await prisma.shortlist.count({
     *   where: {
     *     // ... the filter for the Shortlists we want to count
     *   }
     * })
    **/
    count<T extends ShortlistCountArgs>(
      args?: Subset<T, ShortlistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShortlistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shortlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShortlistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShortlistAggregateArgs>(args: Subset<T, ShortlistAggregateArgs>): Prisma.PrismaPromise<GetShortlistAggregateType<T>>

    /**
     * Group by Shortlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShortlistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShortlistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShortlistGroupByArgs['orderBy'] }
        : { orderBy?: ShortlistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShortlistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShortlistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shortlist model
   */
  readonly fields: ShortlistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shortlist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShortlistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Shortlist model
   */ 
  interface ShortlistFieldRefs {
    readonly id: FieldRef<"Shortlist", 'String'>
    readonly userId: FieldRef<"Shortlist", 'String'>
    readonly profileId: FieldRef<"Shortlist", 'String'>
    readonly folderName: FieldRef<"Shortlist", 'String'>
    readonly notes: FieldRef<"Shortlist", 'String'>
    readonly createdAt: FieldRef<"Shortlist", 'DateTime'>
    readonly updatedAt: FieldRef<"Shortlist", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Shortlist findUnique
   */
  export type ShortlistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shortlist
     */
    select?: ShortlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShortlistInclude<ExtArgs> | null
    /**
     * Filter, which Shortlist to fetch.
     */
    where: ShortlistWhereUniqueInput
  }

  /**
   * Shortlist findUniqueOrThrow
   */
  export type ShortlistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shortlist
     */
    select?: ShortlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShortlistInclude<ExtArgs> | null
    /**
     * Filter, which Shortlist to fetch.
     */
    where: ShortlistWhereUniqueInput
  }

  /**
   * Shortlist findFirst
   */
  export type ShortlistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shortlist
     */
    select?: ShortlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShortlistInclude<ExtArgs> | null
    /**
     * Filter, which Shortlist to fetch.
     */
    where?: ShortlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shortlists to fetch.
     */
    orderBy?: ShortlistOrderByWithRelationInput | ShortlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shortlists.
     */
    cursor?: ShortlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shortlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shortlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shortlists.
     */
    distinct?: ShortlistScalarFieldEnum | ShortlistScalarFieldEnum[]
  }

  /**
   * Shortlist findFirstOrThrow
   */
  export type ShortlistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shortlist
     */
    select?: ShortlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShortlistInclude<ExtArgs> | null
    /**
     * Filter, which Shortlist to fetch.
     */
    where?: ShortlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shortlists to fetch.
     */
    orderBy?: ShortlistOrderByWithRelationInput | ShortlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shortlists.
     */
    cursor?: ShortlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shortlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shortlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shortlists.
     */
    distinct?: ShortlistScalarFieldEnum | ShortlistScalarFieldEnum[]
  }

  /**
   * Shortlist findMany
   */
  export type ShortlistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shortlist
     */
    select?: ShortlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShortlistInclude<ExtArgs> | null
    /**
     * Filter, which Shortlists to fetch.
     */
    where?: ShortlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shortlists to fetch.
     */
    orderBy?: ShortlistOrderByWithRelationInput | ShortlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shortlists.
     */
    cursor?: ShortlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shortlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shortlists.
     */
    skip?: number
    distinct?: ShortlistScalarFieldEnum | ShortlistScalarFieldEnum[]
  }

  /**
   * Shortlist create
   */
  export type ShortlistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shortlist
     */
    select?: ShortlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShortlistInclude<ExtArgs> | null
    /**
     * The data needed to create a Shortlist.
     */
    data: XOR<ShortlistCreateInput, ShortlistUncheckedCreateInput>
  }

  /**
   * Shortlist createMany
   */
  export type ShortlistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shortlists.
     */
    data: ShortlistCreateManyInput | ShortlistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shortlist createManyAndReturn
   */
  export type ShortlistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shortlist
     */
    select?: ShortlistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Shortlists.
     */
    data: ShortlistCreateManyInput | ShortlistCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShortlistIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shortlist update
   */
  export type ShortlistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shortlist
     */
    select?: ShortlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShortlistInclude<ExtArgs> | null
    /**
     * The data needed to update a Shortlist.
     */
    data: XOR<ShortlistUpdateInput, ShortlistUncheckedUpdateInput>
    /**
     * Choose, which Shortlist to update.
     */
    where: ShortlistWhereUniqueInput
  }

  /**
   * Shortlist updateMany
   */
  export type ShortlistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shortlists.
     */
    data: XOR<ShortlistUpdateManyMutationInput, ShortlistUncheckedUpdateManyInput>
    /**
     * Filter which Shortlists to update
     */
    where?: ShortlistWhereInput
  }

  /**
   * Shortlist upsert
   */
  export type ShortlistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shortlist
     */
    select?: ShortlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShortlistInclude<ExtArgs> | null
    /**
     * The filter to search for the Shortlist to update in case it exists.
     */
    where: ShortlistWhereUniqueInput
    /**
     * In case the Shortlist found by the `where` argument doesn't exist, create a new Shortlist with this data.
     */
    create: XOR<ShortlistCreateInput, ShortlistUncheckedCreateInput>
    /**
     * In case the Shortlist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShortlistUpdateInput, ShortlistUncheckedUpdateInput>
  }

  /**
   * Shortlist delete
   */
  export type ShortlistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shortlist
     */
    select?: ShortlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShortlistInclude<ExtArgs> | null
    /**
     * Filter which Shortlist to delete.
     */
    where: ShortlistWhereUniqueInput
  }

  /**
   * Shortlist deleteMany
   */
  export type ShortlistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shortlists to delete
     */
    where?: ShortlistWhereInput
  }

  /**
   * Shortlist without action
   */
  export type ShortlistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shortlist
     */
    select?: ShortlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShortlistInclude<ExtArgs> | null
  }


  /**
   * Model BlockedUser
   */

  export type AggregateBlockedUser = {
    _count: BlockedUserCountAggregateOutputType | null
    _min: BlockedUserMinAggregateOutputType | null
    _max: BlockedUserMaxAggregateOutputType | null
  }

  export type BlockedUserMinAggregateOutputType = {
    id: string | null
    blockerId: string | null
    blockedId: string | null
    reason: string | null
    createdAt: Date | null
  }

  export type BlockedUserMaxAggregateOutputType = {
    id: string | null
    blockerId: string | null
    blockedId: string | null
    reason: string | null
    createdAt: Date | null
  }

  export type BlockedUserCountAggregateOutputType = {
    id: number
    blockerId: number
    blockedId: number
    reason: number
    createdAt: number
    _all: number
  }


  export type BlockedUserMinAggregateInputType = {
    id?: true
    blockerId?: true
    blockedId?: true
    reason?: true
    createdAt?: true
  }

  export type BlockedUserMaxAggregateInputType = {
    id?: true
    blockerId?: true
    blockedId?: true
    reason?: true
    createdAt?: true
  }

  export type BlockedUserCountAggregateInputType = {
    id?: true
    blockerId?: true
    blockedId?: true
    reason?: true
    createdAt?: true
    _all?: true
  }

  export type BlockedUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockedUser to aggregate.
     */
    where?: BlockedUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockedUsers to fetch.
     */
    orderBy?: BlockedUserOrderByWithRelationInput | BlockedUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlockedUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockedUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlockedUsers
    **/
    _count?: true | BlockedUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlockedUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlockedUserMaxAggregateInputType
  }

  export type GetBlockedUserAggregateType<T extends BlockedUserAggregateArgs> = {
        [P in keyof T & keyof AggregateBlockedUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlockedUser[P]>
      : GetScalarType<T[P], AggregateBlockedUser[P]>
  }




  export type BlockedUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockedUserWhereInput
    orderBy?: BlockedUserOrderByWithAggregationInput | BlockedUserOrderByWithAggregationInput[]
    by: BlockedUserScalarFieldEnum[] | BlockedUserScalarFieldEnum
    having?: BlockedUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlockedUserCountAggregateInputType | true
    _min?: BlockedUserMinAggregateInputType
    _max?: BlockedUserMaxAggregateInputType
  }

  export type BlockedUserGroupByOutputType = {
    id: string
    blockerId: string
    blockedId: string
    reason: string | null
    createdAt: Date
    _count: BlockedUserCountAggregateOutputType | null
    _min: BlockedUserMinAggregateOutputType | null
    _max: BlockedUserMaxAggregateOutputType | null
  }

  type GetBlockedUserGroupByPayload<T extends BlockedUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlockedUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlockedUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlockedUserGroupByOutputType[P]>
            : GetScalarType<T[P], BlockedUserGroupByOutputType[P]>
        }
      >
    >


  export type BlockedUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    blockerId?: boolean
    blockedId?: boolean
    reason?: boolean
    createdAt?: boolean
    blocker?: boolean | UserDefaultArgs<ExtArgs>
    blocked?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blockedUser"]>

  export type BlockedUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    blockerId?: boolean
    blockedId?: boolean
    reason?: boolean
    createdAt?: boolean
    blocker?: boolean | UserDefaultArgs<ExtArgs>
    blocked?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blockedUser"]>

  export type BlockedUserSelectScalar = {
    id?: boolean
    blockerId?: boolean
    blockedId?: boolean
    reason?: boolean
    createdAt?: boolean
  }

  export type BlockedUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blocker?: boolean | UserDefaultArgs<ExtArgs>
    blocked?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BlockedUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blocker?: boolean | UserDefaultArgs<ExtArgs>
    blocked?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BlockedUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlockedUser"
    objects: {
      blocker: Prisma.$UserPayload<ExtArgs>
      blocked: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      blockerId: string
      blockedId: string
      reason: string | null
      createdAt: Date
    }, ExtArgs["result"]["blockedUser"]>
    composites: {}
  }

  type BlockedUserGetPayload<S extends boolean | null | undefined | BlockedUserDefaultArgs> = $Result.GetResult<Prisma.$BlockedUserPayload, S>

  type BlockedUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BlockedUserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BlockedUserCountAggregateInputType | true
    }

  export interface BlockedUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlockedUser'], meta: { name: 'BlockedUser' } }
    /**
     * Find zero or one BlockedUser that matches the filter.
     * @param {BlockedUserFindUniqueArgs} args - Arguments to find a BlockedUser
     * @example
     * // Get one BlockedUser
     * const blockedUser = await prisma.blockedUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlockedUserFindUniqueArgs>(args: SelectSubset<T, BlockedUserFindUniqueArgs<ExtArgs>>): Prisma__BlockedUserClient<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BlockedUser that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BlockedUserFindUniqueOrThrowArgs} args - Arguments to find a BlockedUser
     * @example
     * // Get one BlockedUser
     * const blockedUser = await prisma.blockedUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlockedUserFindUniqueOrThrowArgs>(args: SelectSubset<T, BlockedUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlockedUserClient<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BlockedUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUserFindFirstArgs} args - Arguments to find a BlockedUser
     * @example
     * // Get one BlockedUser
     * const blockedUser = await prisma.blockedUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlockedUserFindFirstArgs>(args?: SelectSubset<T, BlockedUserFindFirstArgs<ExtArgs>>): Prisma__BlockedUserClient<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BlockedUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUserFindFirstOrThrowArgs} args - Arguments to find a BlockedUser
     * @example
     * // Get one BlockedUser
     * const blockedUser = await prisma.blockedUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlockedUserFindFirstOrThrowArgs>(args?: SelectSubset<T, BlockedUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlockedUserClient<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BlockedUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlockedUsers
     * const blockedUsers = await prisma.blockedUser.findMany()
     * 
     * // Get first 10 BlockedUsers
     * const blockedUsers = await prisma.blockedUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blockedUserWithIdOnly = await prisma.blockedUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlockedUserFindManyArgs>(args?: SelectSubset<T, BlockedUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BlockedUser.
     * @param {BlockedUserCreateArgs} args - Arguments to create a BlockedUser.
     * @example
     * // Create one BlockedUser
     * const BlockedUser = await prisma.blockedUser.create({
     *   data: {
     *     // ... data to create a BlockedUser
     *   }
     * })
     * 
     */
    create<T extends BlockedUserCreateArgs>(args: SelectSubset<T, BlockedUserCreateArgs<ExtArgs>>): Prisma__BlockedUserClient<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BlockedUsers.
     * @param {BlockedUserCreateManyArgs} args - Arguments to create many BlockedUsers.
     * @example
     * // Create many BlockedUsers
     * const blockedUser = await prisma.blockedUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlockedUserCreateManyArgs>(args?: SelectSubset<T, BlockedUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlockedUsers and returns the data saved in the database.
     * @param {BlockedUserCreateManyAndReturnArgs} args - Arguments to create many BlockedUsers.
     * @example
     * // Create many BlockedUsers
     * const blockedUser = await prisma.blockedUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlockedUsers and only return the `id`
     * const blockedUserWithIdOnly = await prisma.blockedUser.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlockedUserCreateManyAndReturnArgs>(args?: SelectSubset<T, BlockedUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BlockedUser.
     * @param {BlockedUserDeleteArgs} args - Arguments to delete one BlockedUser.
     * @example
     * // Delete one BlockedUser
     * const BlockedUser = await prisma.blockedUser.delete({
     *   where: {
     *     // ... filter to delete one BlockedUser
     *   }
     * })
     * 
     */
    delete<T extends BlockedUserDeleteArgs>(args: SelectSubset<T, BlockedUserDeleteArgs<ExtArgs>>): Prisma__BlockedUserClient<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BlockedUser.
     * @param {BlockedUserUpdateArgs} args - Arguments to update one BlockedUser.
     * @example
     * // Update one BlockedUser
     * const blockedUser = await prisma.blockedUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlockedUserUpdateArgs>(args: SelectSubset<T, BlockedUserUpdateArgs<ExtArgs>>): Prisma__BlockedUserClient<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BlockedUsers.
     * @param {BlockedUserDeleteManyArgs} args - Arguments to filter BlockedUsers to delete.
     * @example
     * // Delete a few BlockedUsers
     * const { count } = await prisma.blockedUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlockedUserDeleteManyArgs>(args?: SelectSubset<T, BlockedUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlockedUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlockedUsers
     * const blockedUser = await prisma.blockedUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlockedUserUpdateManyArgs>(args: SelectSubset<T, BlockedUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BlockedUser.
     * @param {BlockedUserUpsertArgs} args - Arguments to update or create a BlockedUser.
     * @example
     * // Update or create a BlockedUser
     * const blockedUser = await prisma.blockedUser.upsert({
     *   create: {
     *     // ... data to create a BlockedUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlockedUser we want to update
     *   }
     * })
     */
    upsert<T extends BlockedUserUpsertArgs>(args: SelectSubset<T, BlockedUserUpsertArgs<ExtArgs>>): Prisma__BlockedUserClient<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BlockedUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUserCountArgs} args - Arguments to filter BlockedUsers to count.
     * @example
     * // Count the number of BlockedUsers
     * const count = await prisma.blockedUser.count({
     *   where: {
     *     // ... the filter for the BlockedUsers we want to count
     *   }
     * })
    **/
    count<T extends BlockedUserCountArgs>(
      args?: Subset<T, BlockedUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlockedUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlockedUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlockedUserAggregateArgs>(args: Subset<T, BlockedUserAggregateArgs>): Prisma.PrismaPromise<GetBlockedUserAggregateType<T>>

    /**
     * Group by BlockedUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlockedUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlockedUserGroupByArgs['orderBy'] }
        : { orderBy?: BlockedUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlockedUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlockedUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlockedUser model
   */
  readonly fields: BlockedUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlockedUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlockedUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blocker<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    blocked<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlockedUser model
   */ 
  interface BlockedUserFieldRefs {
    readonly id: FieldRef<"BlockedUser", 'String'>
    readonly blockerId: FieldRef<"BlockedUser", 'String'>
    readonly blockedId: FieldRef<"BlockedUser", 'String'>
    readonly reason: FieldRef<"BlockedUser", 'String'>
    readonly createdAt: FieldRef<"BlockedUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlockedUser findUnique
   */
  export type BlockedUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    /**
     * Filter, which BlockedUser to fetch.
     */
    where: BlockedUserWhereUniqueInput
  }

  /**
   * BlockedUser findUniqueOrThrow
   */
  export type BlockedUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    /**
     * Filter, which BlockedUser to fetch.
     */
    where: BlockedUserWhereUniqueInput
  }

  /**
   * BlockedUser findFirst
   */
  export type BlockedUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    /**
     * Filter, which BlockedUser to fetch.
     */
    where?: BlockedUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockedUsers to fetch.
     */
    orderBy?: BlockedUserOrderByWithRelationInput | BlockedUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockedUsers.
     */
    cursor?: BlockedUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockedUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockedUsers.
     */
    distinct?: BlockedUserScalarFieldEnum | BlockedUserScalarFieldEnum[]
  }

  /**
   * BlockedUser findFirstOrThrow
   */
  export type BlockedUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    /**
     * Filter, which BlockedUser to fetch.
     */
    where?: BlockedUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockedUsers to fetch.
     */
    orderBy?: BlockedUserOrderByWithRelationInput | BlockedUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockedUsers.
     */
    cursor?: BlockedUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockedUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockedUsers.
     */
    distinct?: BlockedUserScalarFieldEnum | BlockedUserScalarFieldEnum[]
  }

  /**
   * BlockedUser findMany
   */
  export type BlockedUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    /**
     * Filter, which BlockedUsers to fetch.
     */
    where?: BlockedUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockedUsers to fetch.
     */
    orderBy?: BlockedUserOrderByWithRelationInput | BlockedUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlockedUsers.
     */
    cursor?: BlockedUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockedUsers.
     */
    skip?: number
    distinct?: BlockedUserScalarFieldEnum | BlockedUserScalarFieldEnum[]
  }

  /**
   * BlockedUser create
   */
  export type BlockedUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    /**
     * The data needed to create a BlockedUser.
     */
    data: XOR<BlockedUserCreateInput, BlockedUserUncheckedCreateInput>
  }

  /**
   * BlockedUser createMany
   */
  export type BlockedUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlockedUsers.
     */
    data: BlockedUserCreateManyInput | BlockedUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlockedUser createManyAndReturn
   */
  export type BlockedUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BlockedUsers.
     */
    data: BlockedUserCreateManyInput | BlockedUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlockedUser update
   */
  export type BlockedUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    /**
     * The data needed to update a BlockedUser.
     */
    data: XOR<BlockedUserUpdateInput, BlockedUserUncheckedUpdateInput>
    /**
     * Choose, which BlockedUser to update.
     */
    where: BlockedUserWhereUniqueInput
  }

  /**
   * BlockedUser updateMany
   */
  export type BlockedUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlockedUsers.
     */
    data: XOR<BlockedUserUpdateManyMutationInput, BlockedUserUncheckedUpdateManyInput>
    /**
     * Filter which BlockedUsers to update
     */
    where?: BlockedUserWhereInput
  }

  /**
   * BlockedUser upsert
   */
  export type BlockedUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    /**
     * The filter to search for the BlockedUser to update in case it exists.
     */
    where: BlockedUserWhereUniqueInput
    /**
     * In case the BlockedUser found by the `where` argument doesn't exist, create a new BlockedUser with this data.
     */
    create: XOR<BlockedUserCreateInput, BlockedUserUncheckedCreateInput>
    /**
     * In case the BlockedUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlockedUserUpdateInput, BlockedUserUncheckedUpdateInput>
  }

  /**
   * BlockedUser delete
   */
  export type BlockedUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    /**
     * Filter which BlockedUser to delete.
     */
    where: BlockedUserWhereUniqueInput
  }

  /**
   * BlockedUser deleteMany
   */
  export type BlockedUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockedUsers to delete
     */
    where?: BlockedUserWhereInput
  }

  /**
   * BlockedUser without action
   */
  export type BlockedUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
  }


  /**
   * Model Horoscope
   */

  export type AggregateHoroscope = {
    _count: HoroscopeCountAggregateOutputType | null
    _min: HoroscopeMinAggregateOutputType | null
    _max: HoroscopeMaxAggregateOutputType | null
  }

  export type HoroscopeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    profileId: string | null
    horoscopeUrl: string | null
    birthTime: string | null
    birthPlace: string | null
    rashi: string | null
    nakshatra: string | null
    mangalDosha: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HoroscopeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    profileId: string | null
    horoscopeUrl: string | null
    birthTime: string | null
    birthPlace: string | null
    rashi: string | null
    nakshatra: string | null
    mangalDosha: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HoroscopeCountAggregateOutputType = {
    id: number
    userId: number
    profileId: number
    horoscopeUrl: number
    birthTime: number
    birthPlace: number
    rashi: number
    nakshatra: number
    mangalDosha: number
    horoscopeData: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HoroscopeMinAggregateInputType = {
    id?: true
    userId?: true
    profileId?: true
    horoscopeUrl?: true
    birthTime?: true
    birthPlace?: true
    rashi?: true
    nakshatra?: true
    mangalDosha?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HoroscopeMaxAggregateInputType = {
    id?: true
    userId?: true
    profileId?: true
    horoscopeUrl?: true
    birthTime?: true
    birthPlace?: true
    rashi?: true
    nakshatra?: true
    mangalDosha?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HoroscopeCountAggregateInputType = {
    id?: true
    userId?: true
    profileId?: true
    horoscopeUrl?: true
    birthTime?: true
    birthPlace?: true
    rashi?: true
    nakshatra?: true
    mangalDosha?: true
    horoscopeData?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HoroscopeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Horoscope to aggregate.
     */
    where?: HoroscopeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Horoscopes to fetch.
     */
    orderBy?: HoroscopeOrderByWithRelationInput | HoroscopeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HoroscopeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Horoscopes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Horoscopes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Horoscopes
    **/
    _count?: true | HoroscopeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HoroscopeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HoroscopeMaxAggregateInputType
  }

  export type GetHoroscopeAggregateType<T extends HoroscopeAggregateArgs> = {
        [P in keyof T & keyof AggregateHoroscope]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHoroscope[P]>
      : GetScalarType<T[P], AggregateHoroscope[P]>
  }




  export type HoroscopeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HoroscopeWhereInput
    orderBy?: HoroscopeOrderByWithAggregationInput | HoroscopeOrderByWithAggregationInput[]
    by: HoroscopeScalarFieldEnum[] | HoroscopeScalarFieldEnum
    having?: HoroscopeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HoroscopeCountAggregateInputType | true
    _min?: HoroscopeMinAggregateInputType
    _max?: HoroscopeMaxAggregateInputType
  }

  export type HoroscopeGroupByOutputType = {
    id: string
    userId: string
    profileId: string
    horoscopeUrl: string | null
    birthTime: string | null
    birthPlace: string | null
    rashi: string | null
    nakshatra: string | null
    mangalDosha: boolean | null
    horoscopeData: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: HoroscopeCountAggregateOutputType | null
    _min: HoroscopeMinAggregateOutputType | null
    _max: HoroscopeMaxAggregateOutputType | null
  }

  type GetHoroscopeGroupByPayload<T extends HoroscopeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HoroscopeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HoroscopeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HoroscopeGroupByOutputType[P]>
            : GetScalarType<T[P], HoroscopeGroupByOutputType[P]>
        }
      >
    >


  export type HoroscopeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    profileId?: boolean
    horoscopeUrl?: boolean
    birthTime?: boolean
    birthPlace?: boolean
    rashi?: boolean
    nakshatra?: boolean
    mangalDosha?: boolean
    horoscopeData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    matches1?: boolean | Horoscope$matches1Args<ExtArgs>
    matches2?: boolean | Horoscope$matches2Args<ExtArgs>
    _count?: boolean | HoroscopeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["horoscope"]>

  export type HoroscopeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    profileId?: boolean
    horoscopeUrl?: boolean
    birthTime?: boolean
    birthPlace?: boolean
    rashi?: boolean
    nakshatra?: boolean
    mangalDosha?: boolean
    horoscopeData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["horoscope"]>

  export type HoroscopeSelectScalar = {
    id?: boolean
    userId?: boolean
    profileId?: boolean
    horoscopeUrl?: boolean
    birthTime?: boolean
    birthPlace?: boolean
    rashi?: boolean
    nakshatra?: boolean
    mangalDosha?: boolean
    horoscopeData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HoroscopeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    matches1?: boolean | Horoscope$matches1Args<ExtArgs>
    matches2?: boolean | Horoscope$matches2Args<ExtArgs>
    _count?: boolean | HoroscopeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HoroscopeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $HoroscopePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Horoscope"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      profile: Prisma.$ProfilePayload<ExtArgs>
      matches1: Prisma.$HoroscopeMatchPayload<ExtArgs>[]
      matches2: Prisma.$HoroscopeMatchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      profileId: string
      horoscopeUrl: string | null
      birthTime: string | null
      birthPlace: string | null
      rashi: string | null
      nakshatra: string | null
      mangalDosha: boolean | null
      horoscopeData: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["horoscope"]>
    composites: {}
  }

  type HoroscopeGetPayload<S extends boolean | null | undefined | HoroscopeDefaultArgs> = $Result.GetResult<Prisma.$HoroscopePayload, S>

  type HoroscopeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HoroscopeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HoroscopeCountAggregateInputType | true
    }

  export interface HoroscopeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Horoscope'], meta: { name: 'Horoscope' } }
    /**
     * Find zero or one Horoscope that matches the filter.
     * @param {HoroscopeFindUniqueArgs} args - Arguments to find a Horoscope
     * @example
     * // Get one Horoscope
     * const horoscope = await prisma.horoscope.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HoroscopeFindUniqueArgs>(args: SelectSubset<T, HoroscopeFindUniqueArgs<ExtArgs>>): Prisma__HoroscopeClient<$Result.GetResult<Prisma.$HoroscopePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Horoscope that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HoroscopeFindUniqueOrThrowArgs} args - Arguments to find a Horoscope
     * @example
     * // Get one Horoscope
     * const horoscope = await prisma.horoscope.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HoroscopeFindUniqueOrThrowArgs>(args: SelectSubset<T, HoroscopeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HoroscopeClient<$Result.GetResult<Prisma.$HoroscopePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Horoscope that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoroscopeFindFirstArgs} args - Arguments to find a Horoscope
     * @example
     * // Get one Horoscope
     * const horoscope = await prisma.horoscope.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HoroscopeFindFirstArgs>(args?: SelectSubset<T, HoroscopeFindFirstArgs<ExtArgs>>): Prisma__HoroscopeClient<$Result.GetResult<Prisma.$HoroscopePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Horoscope that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoroscopeFindFirstOrThrowArgs} args - Arguments to find a Horoscope
     * @example
     * // Get one Horoscope
     * const horoscope = await prisma.horoscope.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HoroscopeFindFirstOrThrowArgs>(args?: SelectSubset<T, HoroscopeFindFirstOrThrowArgs<ExtArgs>>): Prisma__HoroscopeClient<$Result.GetResult<Prisma.$HoroscopePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Horoscopes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoroscopeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Horoscopes
     * const horoscopes = await prisma.horoscope.findMany()
     * 
     * // Get first 10 Horoscopes
     * const horoscopes = await prisma.horoscope.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const horoscopeWithIdOnly = await prisma.horoscope.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HoroscopeFindManyArgs>(args?: SelectSubset<T, HoroscopeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HoroscopePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Horoscope.
     * @param {HoroscopeCreateArgs} args - Arguments to create a Horoscope.
     * @example
     * // Create one Horoscope
     * const Horoscope = await prisma.horoscope.create({
     *   data: {
     *     // ... data to create a Horoscope
     *   }
     * })
     * 
     */
    create<T extends HoroscopeCreateArgs>(args: SelectSubset<T, HoroscopeCreateArgs<ExtArgs>>): Prisma__HoroscopeClient<$Result.GetResult<Prisma.$HoroscopePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Horoscopes.
     * @param {HoroscopeCreateManyArgs} args - Arguments to create many Horoscopes.
     * @example
     * // Create many Horoscopes
     * const horoscope = await prisma.horoscope.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HoroscopeCreateManyArgs>(args?: SelectSubset<T, HoroscopeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Horoscopes and returns the data saved in the database.
     * @param {HoroscopeCreateManyAndReturnArgs} args - Arguments to create many Horoscopes.
     * @example
     * // Create many Horoscopes
     * const horoscope = await prisma.horoscope.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Horoscopes and only return the `id`
     * const horoscopeWithIdOnly = await prisma.horoscope.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HoroscopeCreateManyAndReturnArgs>(args?: SelectSubset<T, HoroscopeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HoroscopePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Horoscope.
     * @param {HoroscopeDeleteArgs} args - Arguments to delete one Horoscope.
     * @example
     * // Delete one Horoscope
     * const Horoscope = await prisma.horoscope.delete({
     *   where: {
     *     // ... filter to delete one Horoscope
     *   }
     * })
     * 
     */
    delete<T extends HoroscopeDeleteArgs>(args: SelectSubset<T, HoroscopeDeleteArgs<ExtArgs>>): Prisma__HoroscopeClient<$Result.GetResult<Prisma.$HoroscopePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Horoscope.
     * @param {HoroscopeUpdateArgs} args - Arguments to update one Horoscope.
     * @example
     * // Update one Horoscope
     * const horoscope = await prisma.horoscope.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HoroscopeUpdateArgs>(args: SelectSubset<T, HoroscopeUpdateArgs<ExtArgs>>): Prisma__HoroscopeClient<$Result.GetResult<Prisma.$HoroscopePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Horoscopes.
     * @param {HoroscopeDeleteManyArgs} args - Arguments to filter Horoscopes to delete.
     * @example
     * // Delete a few Horoscopes
     * const { count } = await prisma.horoscope.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HoroscopeDeleteManyArgs>(args?: SelectSubset<T, HoroscopeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Horoscopes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoroscopeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Horoscopes
     * const horoscope = await prisma.horoscope.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HoroscopeUpdateManyArgs>(args: SelectSubset<T, HoroscopeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Horoscope.
     * @param {HoroscopeUpsertArgs} args - Arguments to update or create a Horoscope.
     * @example
     * // Update or create a Horoscope
     * const horoscope = await prisma.horoscope.upsert({
     *   create: {
     *     // ... data to create a Horoscope
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Horoscope we want to update
     *   }
     * })
     */
    upsert<T extends HoroscopeUpsertArgs>(args: SelectSubset<T, HoroscopeUpsertArgs<ExtArgs>>): Prisma__HoroscopeClient<$Result.GetResult<Prisma.$HoroscopePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Horoscopes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoroscopeCountArgs} args - Arguments to filter Horoscopes to count.
     * @example
     * // Count the number of Horoscopes
     * const count = await prisma.horoscope.count({
     *   where: {
     *     // ... the filter for the Horoscopes we want to count
     *   }
     * })
    **/
    count<T extends HoroscopeCountArgs>(
      args?: Subset<T, HoroscopeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HoroscopeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Horoscope.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoroscopeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HoroscopeAggregateArgs>(args: Subset<T, HoroscopeAggregateArgs>): Prisma.PrismaPromise<GetHoroscopeAggregateType<T>>

    /**
     * Group by Horoscope.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoroscopeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HoroscopeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HoroscopeGroupByArgs['orderBy'] }
        : { orderBy?: HoroscopeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HoroscopeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHoroscopeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Horoscope model
   */
  readonly fields: HoroscopeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Horoscope.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HoroscopeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    matches1<T extends Horoscope$matches1Args<ExtArgs> = {}>(args?: Subset<T, Horoscope$matches1Args<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HoroscopeMatchPayload<ExtArgs>, T, "findMany"> | Null>
    matches2<T extends Horoscope$matches2Args<ExtArgs> = {}>(args?: Subset<T, Horoscope$matches2Args<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HoroscopeMatchPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Horoscope model
   */ 
  interface HoroscopeFieldRefs {
    readonly id: FieldRef<"Horoscope", 'String'>
    readonly userId: FieldRef<"Horoscope", 'String'>
    readonly profileId: FieldRef<"Horoscope", 'String'>
    readonly horoscopeUrl: FieldRef<"Horoscope", 'String'>
    readonly birthTime: FieldRef<"Horoscope", 'String'>
    readonly birthPlace: FieldRef<"Horoscope", 'String'>
    readonly rashi: FieldRef<"Horoscope", 'String'>
    readonly nakshatra: FieldRef<"Horoscope", 'String'>
    readonly mangalDosha: FieldRef<"Horoscope", 'Boolean'>
    readonly horoscopeData: FieldRef<"Horoscope", 'Json'>
    readonly createdAt: FieldRef<"Horoscope", 'DateTime'>
    readonly updatedAt: FieldRef<"Horoscope", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Horoscope findUnique
   */
  export type HoroscopeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Horoscope
     */
    select?: HoroscopeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoroscopeInclude<ExtArgs> | null
    /**
     * Filter, which Horoscope to fetch.
     */
    where: HoroscopeWhereUniqueInput
  }

  /**
   * Horoscope findUniqueOrThrow
   */
  export type HoroscopeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Horoscope
     */
    select?: HoroscopeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoroscopeInclude<ExtArgs> | null
    /**
     * Filter, which Horoscope to fetch.
     */
    where: HoroscopeWhereUniqueInput
  }

  /**
   * Horoscope findFirst
   */
  export type HoroscopeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Horoscope
     */
    select?: HoroscopeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoroscopeInclude<ExtArgs> | null
    /**
     * Filter, which Horoscope to fetch.
     */
    where?: HoroscopeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Horoscopes to fetch.
     */
    orderBy?: HoroscopeOrderByWithRelationInput | HoroscopeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Horoscopes.
     */
    cursor?: HoroscopeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Horoscopes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Horoscopes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Horoscopes.
     */
    distinct?: HoroscopeScalarFieldEnum | HoroscopeScalarFieldEnum[]
  }

  /**
   * Horoscope findFirstOrThrow
   */
  export type HoroscopeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Horoscope
     */
    select?: HoroscopeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoroscopeInclude<ExtArgs> | null
    /**
     * Filter, which Horoscope to fetch.
     */
    where?: HoroscopeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Horoscopes to fetch.
     */
    orderBy?: HoroscopeOrderByWithRelationInput | HoroscopeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Horoscopes.
     */
    cursor?: HoroscopeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Horoscopes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Horoscopes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Horoscopes.
     */
    distinct?: HoroscopeScalarFieldEnum | HoroscopeScalarFieldEnum[]
  }

  /**
   * Horoscope findMany
   */
  export type HoroscopeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Horoscope
     */
    select?: HoroscopeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoroscopeInclude<ExtArgs> | null
    /**
     * Filter, which Horoscopes to fetch.
     */
    where?: HoroscopeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Horoscopes to fetch.
     */
    orderBy?: HoroscopeOrderByWithRelationInput | HoroscopeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Horoscopes.
     */
    cursor?: HoroscopeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Horoscopes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Horoscopes.
     */
    skip?: number
    distinct?: HoroscopeScalarFieldEnum | HoroscopeScalarFieldEnum[]
  }

  /**
   * Horoscope create
   */
  export type HoroscopeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Horoscope
     */
    select?: HoroscopeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoroscopeInclude<ExtArgs> | null
    /**
     * The data needed to create a Horoscope.
     */
    data: XOR<HoroscopeCreateInput, HoroscopeUncheckedCreateInput>
  }

  /**
   * Horoscope createMany
   */
  export type HoroscopeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Horoscopes.
     */
    data: HoroscopeCreateManyInput | HoroscopeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Horoscope createManyAndReturn
   */
  export type HoroscopeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Horoscope
     */
    select?: HoroscopeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Horoscopes.
     */
    data: HoroscopeCreateManyInput | HoroscopeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoroscopeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Horoscope update
   */
  export type HoroscopeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Horoscope
     */
    select?: HoroscopeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoroscopeInclude<ExtArgs> | null
    /**
     * The data needed to update a Horoscope.
     */
    data: XOR<HoroscopeUpdateInput, HoroscopeUncheckedUpdateInput>
    /**
     * Choose, which Horoscope to update.
     */
    where: HoroscopeWhereUniqueInput
  }

  /**
   * Horoscope updateMany
   */
  export type HoroscopeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Horoscopes.
     */
    data: XOR<HoroscopeUpdateManyMutationInput, HoroscopeUncheckedUpdateManyInput>
    /**
     * Filter which Horoscopes to update
     */
    where?: HoroscopeWhereInput
  }

  /**
   * Horoscope upsert
   */
  export type HoroscopeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Horoscope
     */
    select?: HoroscopeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoroscopeInclude<ExtArgs> | null
    /**
     * The filter to search for the Horoscope to update in case it exists.
     */
    where: HoroscopeWhereUniqueInput
    /**
     * In case the Horoscope found by the `where` argument doesn't exist, create a new Horoscope with this data.
     */
    create: XOR<HoroscopeCreateInput, HoroscopeUncheckedCreateInput>
    /**
     * In case the Horoscope was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HoroscopeUpdateInput, HoroscopeUncheckedUpdateInput>
  }

  /**
   * Horoscope delete
   */
  export type HoroscopeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Horoscope
     */
    select?: HoroscopeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoroscopeInclude<ExtArgs> | null
    /**
     * Filter which Horoscope to delete.
     */
    where: HoroscopeWhereUniqueInput
  }

  /**
   * Horoscope deleteMany
   */
  export type HoroscopeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Horoscopes to delete
     */
    where?: HoroscopeWhereInput
  }

  /**
   * Horoscope.matches1
   */
  export type Horoscope$matches1Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HoroscopeMatch
     */
    select?: HoroscopeMatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoroscopeMatchInclude<ExtArgs> | null
    where?: HoroscopeMatchWhereInput
    orderBy?: HoroscopeMatchOrderByWithRelationInput | HoroscopeMatchOrderByWithRelationInput[]
    cursor?: HoroscopeMatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HoroscopeMatchScalarFieldEnum | HoroscopeMatchScalarFieldEnum[]
  }

  /**
   * Horoscope.matches2
   */
  export type Horoscope$matches2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HoroscopeMatch
     */
    select?: HoroscopeMatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoroscopeMatchInclude<ExtArgs> | null
    where?: HoroscopeMatchWhereInput
    orderBy?: HoroscopeMatchOrderByWithRelationInput | HoroscopeMatchOrderByWithRelationInput[]
    cursor?: HoroscopeMatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HoroscopeMatchScalarFieldEnum | HoroscopeMatchScalarFieldEnum[]
  }

  /**
   * Horoscope without action
   */
  export type HoroscopeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Horoscope
     */
    select?: HoroscopeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoroscopeInclude<ExtArgs> | null
  }


  /**
   * Model HoroscopeMatch
   */

  export type AggregateHoroscopeMatch = {
    _count: HoroscopeMatchCountAggregateOutputType | null
    _avg: HoroscopeMatchAvgAggregateOutputType | null
    _sum: HoroscopeMatchSumAggregateOutputType | null
    _min: HoroscopeMatchMinAggregateOutputType | null
    _max: HoroscopeMatchMaxAggregateOutputType | null
  }

  export type HoroscopeMatchAvgAggregateOutputType = {
    ashtakootScore: number | null
    overallScore: number | null
  }

  export type HoroscopeMatchSumAggregateOutputType = {
    ashtakootScore: number | null
    overallScore: number | null
  }

  export type HoroscopeMatchMinAggregateOutputType = {
    id: string | null
    user1Id: string | null
    user2Id: string | null
    horoscope1Id: string | null
    horoscope2Id: string | null
    ashtakootScore: number | null
    mangalDoshaMatch: boolean | null
    overallScore: number | null
    createdAt: Date | null
  }

  export type HoroscopeMatchMaxAggregateOutputType = {
    id: string | null
    user1Id: string | null
    user2Id: string | null
    horoscope1Id: string | null
    horoscope2Id: string | null
    ashtakootScore: number | null
    mangalDoshaMatch: boolean | null
    overallScore: number | null
    createdAt: Date | null
  }

  export type HoroscopeMatchCountAggregateOutputType = {
    id: number
    user1Id: number
    user2Id: number
    horoscope1Id: number
    horoscope2Id: number
    ashtakootScore: number
    mangalDoshaMatch: number
    overallScore: number
    matchDetails: number
    createdAt: number
    _all: number
  }


  export type HoroscopeMatchAvgAggregateInputType = {
    ashtakootScore?: true
    overallScore?: true
  }

  export type HoroscopeMatchSumAggregateInputType = {
    ashtakootScore?: true
    overallScore?: true
  }

  export type HoroscopeMatchMinAggregateInputType = {
    id?: true
    user1Id?: true
    user2Id?: true
    horoscope1Id?: true
    horoscope2Id?: true
    ashtakootScore?: true
    mangalDoshaMatch?: true
    overallScore?: true
    createdAt?: true
  }

  export type HoroscopeMatchMaxAggregateInputType = {
    id?: true
    user1Id?: true
    user2Id?: true
    horoscope1Id?: true
    horoscope2Id?: true
    ashtakootScore?: true
    mangalDoshaMatch?: true
    overallScore?: true
    createdAt?: true
  }

  export type HoroscopeMatchCountAggregateInputType = {
    id?: true
    user1Id?: true
    user2Id?: true
    horoscope1Id?: true
    horoscope2Id?: true
    ashtakootScore?: true
    mangalDoshaMatch?: true
    overallScore?: true
    matchDetails?: true
    createdAt?: true
    _all?: true
  }

  export type HoroscopeMatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HoroscopeMatch to aggregate.
     */
    where?: HoroscopeMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HoroscopeMatches to fetch.
     */
    orderBy?: HoroscopeMatchOrderByWithRelationInput | HoroscopeMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HoroscopeMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HoroscopeMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HoroscopeMatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HoroscopeMatches
    **/
    _count?: true | HoroscopeMatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HoroscopeMatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HoroscopeMatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HoroscopeMatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HoroscopeMatchMaxAggregateInputType
  }

  export type GetHoroscopeMatchAggregateType<T extends HoroscopeMatchAggregateArgs> = {
        [P in keyof T & keyof AggregateHoroscopeMatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHoroscopeMatch[P]>
      : GetScalarType<T[P], AggregateHoroscopeMatch[P]>
  }




  export type HoroscopeMatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HoroscopeMatchWhereInput
    orderBy?: HoroscopeMatchOrderByWithAggregationInput | HoroscopeMatchOrderByWithAggregationInput[]
    by: HoroscopeMatchScalarFieldEnum[] | HoroscopeMatchScalarFieldEnum
    having?: HoroscopeMatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HoroscopeMatchCountAggregateInputType | true
    _avg?: HoroscopeMatchAvgAggregateInputType
    _sum?: HoroscopeMatchSumAggregateInputType
    _min?: HoroscopeMatchMinAggregateInputType
    _max?: HoroscopeMatchMaxAggregateInputType
  }

  export type HoroscopeMatchGroupByOutputType = {
    id: string
    user1Id: string
    user2Id: string
    horoscope1Id: string
    horoscope2Id: string
    ashtakootScore: number | null
    mangalDoshaMatch: boolean | null
    overallScore: number | null
    matchDetails: JsonValue | null
    createdAt: Date
    _count: HoroscopeMatchCountAggregateOutputType | null
    _avg: HoroscopeMatchAvgAggregateOutputType | null
    _sum: HoroscopeMatchSumAggregateOutputType | null
    _min: HoroscopeMatchMinAggregateOutputType | null
    _max: HoroscopeMatchMaxAggregateOutputType | null
  }

  type GetHoroscopeMatchGroupByPayload<T extends HoroscopeMatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HoroscopeMatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HoroscopeMatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HoroscopeMatchGroupByOutputType[P]>
            : GetScalarType<T[P], HoroscopeMatchGroupByOutputType[P]>
        }
      >
    >


  export type HoroscopeMatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user1Id?: boolean
    user2Id?: boolean
    horoscope1Id?: boolean
    horoscope2Id?: boolean
    ashtakootScore?: boolean
    mangalDoshaMatch?: boolean
    overallScore?: boolean
    matchDetails?: boolean
    createdAt?: boolean
    horoscope1?: boolean | HoroscopeDefaultArgs<ExtArgs>
    horoscope2?: boolean | HoroscopeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["horoscopeMatch"]>

  export type HoroscopeMatchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user1Id?: boolean
    user2Id?: boolean
    horoscope1Id?: boolean
    horoscope2Id?: boolean
    ashtakootScore?: boolean
    mangalDoshaMatch?: boolean
    overallScore?: boolean
    matchDetails?: boolean
    createdAt?: boolean
    horoscope1?: boolean | HoroscopeDefaultArgs<ExtArgs>
    horoscope2?: boolean | HoroscopeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["horoscopeMatch"]>

  export type HoroscopeMatchSelectScalar = {
    id?: boolean
    user1Id?: boolean
    user2Id?: boolean
    horoscope1Id?: boolean
    horoscope2Id?: boolean
    ashtakootScore?: boolean
    mangalDoshaMatch?: boolean
    overallScore?: boolean
    matchDetails?: boolean
    createdAt?: boolean
  }

  export type HoroscopeMatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    horoscope1?: boolean | HoroscopeDefaultArgs<ExtArgs>
    horoscope2?: boolean | HoroscopeDefaultArgs<ExtArgs>
  }
  export type HoroscopeMatchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    horoscope1?: boolean | HoroscopeDefaultArgs<ExtArgs>
    horoscope2?: boolean | HoroscopeDefaultArgs<ExtArgs>
  }

  export type $HoroscopeMatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HoroscopeMatch"
    objects: {
      horoscope1: Prisma.$HoroscopePayload<ExtArgs>
      horoscope2: Prisma.$HoroscopePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user1Id: string
      user2Id: string
      horoscope1Id: string
      horoscope2Id: string
      ashtakootScore: number | null
      mangalDoshaMatch: boolean | null
      overallScore: number | null
      matchDetails: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["horoscopeMatch"]>
    composites: {}
  }

  type HoroscopeMatchGetPayload<S extends boolean | null | undefined | HoroscopeMatchDefaultArgs> = $Result.GetResult<Prisma.$HoroscopeMatchPayload, S>

  type HoroscopeMatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HoroscopeMatchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HoroscopeMatchCountAggregateInputType | true
    }

  export interface HoroscopeMatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HoroscopeMatch'], meta: { name: 'HoroscopeMatch' } }
    /**
     * Find zero or one HoroscopeMatch that matches the filter.
     * @param {HoroscopeMatchFindUniqueArgs} args - Arguments to find a HoroscopeMatch
     * @example
     * // Get one HoroscopeMatch
     * const horoscopeMatch = await prisma.horoscopeMatch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HoroscopeMatchFindUniqueArgs>(args: SelectSubset<T, HoroscopeMatchFindUniqueArgs<ExtArgs>>): Prisma__HoroscopeMatchClient<$Result.GetResult<Prisma.$HoroscopeMatchPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HoroscopeMatch that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HoroscopeMatchFindUniqueOrThrowArgs} args - Arguments to find a HoroscopeMatch
     * @example
     * // Get one HoroscopeMatch
     * const horoscopeMatch = await prisma.horoscopeMatch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HoroscopeMatchFindUniqueOrThrowArgs>(args: SelectSubset<T, HoroscopeMatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HoroscopeMatchClient<$Result.GetResult<Prisma.$HoroscopeMatchPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HoroscopeMatch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoroscopeMatchFindFirstArgs} args - Arguments to find a HoroscopeMatch
     * @example
     * // Get one HoroscopeMatch
     * const horoscopeMatch = await prisma.horoscopeMatch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HoroscopeMatchFindFirstArgs>(args?: SelectSubset<T, HoroscopeMatchFindFirstArgs<ExtArgs>>): Prisma__HoroscopeMatchClient<$Result.GetResult<Prisma.$HoroscopeMatchPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HoroscopeMatch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoroscopeMatchFindFirstOrThrowArgs} args - Arguments to find a HoroscopeMatch
     * @example
     * // Get one HoroscopeMatch
     * const horoscopeMatch = await prisma.horoscopeMatch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HoroscopeMatchFindFirstOrThrowArgs>(args?: SelectSubset<T, HoroscopeMatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__HoroscopeMatchClient<$Result.GetResult<Prisma.$HoroscopeMatchPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HoroscopeMatches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoroscopeMatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HoroscopeMatches
     * const horoscopeMatches = await prisma.horoscopeMatch.findMany()
     * 
     * // Get first 10 HoroscopeMatches
     * const horoscopeMatches = await prisma.horoscopeMatch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const horoscopeMatchWithIdOnly = await prisma.horoscopeMatch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HoroscopeMatchFindManyArgs>(args?: SelectSubset<T, HoroscopeMatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HoroscopeMatchPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HoroscopeMatch.
     * @param {HoroscopeMatchCreateArgs} args - Arguments to create a HoroscopeMatch.
     * @example
     * // Create one HoroscopeMatch
     * const HoroscopeMatch = await prisma.horoscopeMatch.create({
     *   data: {
     *     // ... data to create a HoroscopeMatch
     *   }
     * })
     * 
     */
    create<T extends HoroscopeMatchCreateArgs>(args: SelectSubset<T, HoroscopeMatchCreateArgs<ExtArgs>>): Prisma__HoroscopeMatchClient<$Result.GetResult<Prisma.$HoroscopeMatchPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HoroscopeMatches.
     * @param {HoroscopeMatchCreateManyArgs} args - Arguments to create many HoroscopeMatches.
     * @example
     * // Create many HoroscopeMatches
     * const horoscopeMatch = await prisma.horoscopeMatch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HoroscopeMatchCreateManyArgs>(args?: SelectSubset<T, HoroscopeMatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HoroscopeMatches and returns the data saved in the database.
     * @param {HoroscopeMatchCreateManyAndReturnArgs} args - Arguments to create many HoroscopeMatches.
     * @example
     * // Create many HoroscopeMatches
     * const horoscopeMatch = await prisma.horoscopeMatch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HoroscopeMatches and only return the `id`
     * const horoscopeMatchWithIdOnly = await prisma.horoscopeMatch.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HoroscopeMatchCreateManyAndReturnArgs>(args?: SelectSubset<T, HoroscopeMatchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HoroscopeMatchPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HoroscopeMatch.
     * @param {HoroscopeMatchDeleteArgs} args - Arguments to delete one HoroscopeMatch.
     * @example
     * // Delete one HoroscopeMatch
     * const HoroscopeMatch = await prisma.horoscopeMatch.delete({
     *   where: {
     *     // ... filter to delete one HoroscopeMatch
     *   }
     * })
     * 
     */
    delete<T extends HoroscopeMatchDeleteArgs>(args: SelectSubset<T, HoroscopeMatchDeleteArgs<ExtArgs>>): Prisma__HoroscopeMatchClient<$Result.GetResult<Prisma.$HoroscopeMatchPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HoroscopeMatch.
     * @param {HoroscopeMatchUpdateArgs} args - Arguments to update one HoroscopeMatch.
     * @example
     * // Update one HoroscopeMatch
     * const horoscopeMatch = await prisma.horoscopeMatch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HoroscopeMatchUpdateArgs>(args: SelectSubset<T, HoroscopeMatchUpdateArgs<ExtArgs>>): Prisma__HoroscopeMatchClient<$Result.GetResult<Prisma.$HoroscopeMatchPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HoroscopeMatches.
     * @param {HoroscopeMatchDeleteManyArgs} args - Arguments to filter HoroscopeMatches to delete.
     * @example
     * // Delete a few HoroscopeMatches
     * const { count } = await prisma.horoscopeMatch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HoroscopeMatchDeleteManyArgs>(args?: SelectSubset<T, HoroscopeMatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HoroscopeMatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoroscopeMatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HoroscopeMatches
     * const horoscopeMatch = await prisma.horoscopeMatch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HoroscopeMatchUpdateManyArgs>(args: SelectSubset<T, HoroscopeMatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HoroscopeMatch.
     * @param {HoroscopeMatchUpsertArgs} args - Arguments to update or create a HoroscopeMatch.
     * @example
     * // Update or create a HoroscopeMatch
     * const horoscopeMatch = await prisma.horoscopeMatch.upsert({
     *   create: {
     *     // ... data to create a HoroscopeMatch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HoroscopeMatch we want to update
     *   }
     * })
     */
    upsert<T extends HoroscopeMatchUpsertArgs>(args: SelectSubset<T, HoroscopeMatchUpsertArgs<ExtArgs>>): Prisma__HoroscopeMatchClient<$Result.GetResult<Prisma.$HoroscopeMatchPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HoroscopeMatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoroscopeMatchCountArgs} args - Arguments to filter HoroscopeMatches to count.
     * @example
     * // Count the number of HoroscopeMatches
     * const count = await prisma.horoscopeMatch.count({
     *   where: {
     *     // ... the filter for the HoroscopeMatches we want to count
     *   }
     * })
    **/
    count<T extends HoroscopeMatchCountArgs>(
      args?: Subset<T, HoroscopeMatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HoroscopeMatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HoroscopeMatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoroscopeMatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HoroscopeMatchAggregateArgs>(args: Subset<T, HoroscopeMatchAggregateArgs>): Prisma.PrismaPromise<GetHoroscopeMatchAggregateType<T>>

    /**
     * Group by HoroscopeMatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoroscopeMatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HoroscopeMatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HoroscopeMatchGroupByArgs['orderBy'] }
        : { orderBy?: HoroscopeMatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HoroscopeMatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHoroscopeMatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HoroscopeMatch model
   */
  readonly fields: HoroscopeMatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HoroscopeMatch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HoroscopeMatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    horoscope1<T extends HoroscopeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HoroscopeDefaultArgs<ExtArgs>>): Prisma__HoroscopeClient<$Result.GetResult<Prisma.$HoroscopePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    horoscope2<T extends HoroscopeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HoroscopeDefaultArgs<ExtArgs>>): Prisma__HoroscopeClient<$Result.GetResult<Prisma.$HoroscopePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HoroscopeMatch model
   */ 
  interface HoroscopeMatchFieldRefs {
    readonly id: FieldRef<"HoroscopeMatch", 'String'>
    readonly user1Id: FieldRef<"HoroscopeMatch", 'String'>
    readonly user2Id: FieldRef<"HoroscopeMatch", 'String'>
    readonly horoscope1Id: FieldRef<"HoroscopeMatch", 'String'>
    readonly horoscope2Id: FieldRef<"HoroscopeMatch", 'String'>
    readonly ashtakootScore: FieldRef<"HoroscopeMatch", 'Int'>
    readonly mangalDoshaMatch: FieldRef<"HoroscopeMatch", 'Boolean'>
    readonly overallScore: FieldRef<"HoroscopeMatch", 'Int'>
    readonly matchDetails: FieldRef<"HoroscopeMatch", 'Json'>
    readonly createdAt: FieldRef<"HoroscopeMatch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HoroscopeMatch findUnique
   */
  export type HoroscopeMatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HoroscopeMatch
     */
    select?: HoroscopeMatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoroscopeMatchInclude<ExtArgs> | null
    /**
     * Filter, which HoroscopeMatch to fetch.
     */
    where: HoroscopeMatchWhereUniqueInput
  }

  /**
   * HoroscopeMatch findUniqueOrThrow
   */
  export type HoroscopeMatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HoroscopeMatch
     */
    select?: HoroscopeMatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoroscopeMatchInclude<ExtArgs> | null
    /**
     * Filter, which HoroscopeMatch to fetch.
     */
    where: HoroscopeMatchWhereUniqueInput
  }

  /**
   * HoroscopeMatch findFirst
   */
  export type HoroscopeMatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HoroscopeMatch
     */
    select?: HoroscopeMatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoroscopeMatchInclude<ExtArgs> | null
    /**
     * Filter, which HoroscopeMatch to fetch.
     */
    where?: HoroscopeMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HoroscopeMatches to fetch.
     */
    orderBy?: HoroscopeMatchOrderByWithRelationInput | HoroscopeMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HoroscopeMatches.
     */
    cursor?: HoroscopeMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HoroscopeMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HoroscopeMatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HoroscopeMatches.
     */
    distinct?: HoroscopeMatchScalarFieldEnum | HoroscopeMatchScalarFieldEnum[]
  }

  /**
   * HoroscopeMatch findFirstOrThrow
   */
  export type HoroscopeMatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HoroscopeMatch
     */
    select?: HoroscopeMatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoroscopeMatchInclude<ExtArgs> | null
    /**
     * Filter, which HoroscopeMatch to fetch.
     */
    where?: HoroscopeMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HoroscopeMatches to fetch.
     */
    orderBy?: HoroscopeMatchOrderByWithRelationInput | HoroscopeMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HoroscopeMatches.
     */
    cursor?: HoroscopeMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HoroscopeMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HoroscopeMatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HoroscopeMatches.
     */
    distinct?: HoroscopeMatchScalarFieldEnum | HoroscopeMatchScalarFieldEnum[]
  }

  /**
   * HoroscopeMatch findMany
   */
  export type HoroscopeMatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HoroscopeMatch
     */
    select?: HoroscopeMatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoroscopeMatchInclude<ExtArgs> | null
    /**
     * Filter, which HoroscopeMatches to fetch.
     */
    where?: HoroscopeMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HoroscopeMatches to fetch.
     */
    orderBy?: HoroscopeMatchOrderByWithRelationInput | HoroscopeMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HoroscopeMatches.
     */
    cursor?: HoroscopeMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HoroscopeMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HoroscopeMatches.
     */
    skip?: number
    distinct?: HoroscopeMatchScalarFieldEnum | HoroscopeMatchScalarFieldEnum[]
  }

  /**
   * HoroscopeMatch create
   */
  export type HoroscopeMatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HoroscopeMatch
     */
    select?: HoroscopeMatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoroscopeMatchInclude<ExtArgs> | null
    /**
     * The data needed to create a HoroscopeMatch.
     */
    data: XOR<HoroscopeMatchCreateInput, HoroscopeMatchUncheckedCreateInput>
  }

  /**
   * HoroscopeMatch createMany
   */
  export type HoroscopeMatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HoroscopeMatches.
     */
    data: HoroscopeMatchCreateManyInput | HoroscopeMatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HoroscopeMatch createManyAndReturn
   */
  export type HoroscopeMatchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HoroscopeMatch
     */
    select?: HoroscopeMatchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HoroscopeMatches.
     */
    data: HoroscopeMatchCreateManyInput | HoroscopeMatchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoroscopeMatchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HoroscopeMatch update
   */
  export type HoroscopeMatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HoroscopeMatch
     */
    select?: HoroscopeMatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoroscopeMatchInclude<ExtArgs> | null
    /**
     * The data needed to update a HoroscopeMatch.
     */
    data: XOR<HoroscopeMatchUpdateInput, HoroscopeMatchUncheckedUpdateInput>
    /**
     * Choose, which HoroscopeMatch to update.
     */
    where: HoroscopeMatchWhereUniqueInput
  }

  /**
   * HoroscopeMatch updateMany
   */
  export type HoroscopeMatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HoroscopeMatches.
     */
    data: XOR<HoroscopeMatchUpdateManyMutationInput, HoroscopeMatchUncheckedUpdateManyInput>
    /**
     * Filter which HoroscopeMatches to update
     */
    where?: HoroscopeMatchWhereInput
  }

  /**
   * HoroscopeMatch upsert
   */
  export type HoroscopeMatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HoroscopeMatch
     */
    select?: HoroscopeMatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoroscopeMatchInclude<ExtArgs> | null
    /**
     * The filter to search for the HoroscopeMatch to update in case it exists.
     */
    where: HoroscopeMatchWhereUniqueInput
    /**
     * In case the HoroscopeMatch found by the `where` argument doesn't exist, create a new HoroscopeMatch with this data.
     */
    create: XOR<HoroscopeMatchCreateInput, HoroscopeMatchUncheckedCreateInput>
    /**
     * In case the HoroscopeMatch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HoroscopeMatchUpdateInput, HoroscopeMatchUncheckedUpdateInput>
  }

  /**
   * HoroscopeMatch delete
   */
  export type HoroscopeMatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HoroscopeMatch
     */
    select?: HoroscopeMatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoroscopeMatchInclude<ExtArgs> | null
    /**
     * Filter which HoroscopeMatch to delete.
     */
    where: HoroscopeMatchWhereUniqueInput
  }

  /**
   * HoroscopeMatch deleteMany
   */
  export type HoroscopeMatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HoroscopeMatches to delete
     */
    where?: HoroscopeMatchWhereInput
  }

  /**
   * HoroscopeMatch without action
   */
  export type HoroscopeMatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HoroscopeMatch
     */
    select?: HoroscopeMatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoroscopeMatchInclude<ExtArgs> | null
  }


  /**
   * Model SuccessStory
   */

  export type AggregateSuccessStory = {
    _count: SuccessStoryCountAggregateOutputType | null
    _min: SuccessStoryMinAggregateOutputType | null
    _max: SuccessStoryMaxAggregateOutputType | null
  }

  export type SuccessStoryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    partnerId: string | null
    title: string | null
    story: string | null
    weddingDate: Date | null
    isApproved: boolean | null
    isFeatured: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SuccessStoryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    partnerId: string | null
    title: string | null
    story: string | null
    weddingDate: Date | null
    isApproved: boolean | null
    isFeatured: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SuccessStoryCountAggregateOutputType = {
    id: number
    userId: number
    partnerId: number
    title: number
    story: number
    weddingDate: number
    photos: number
    isApproved: number
    isFeatured: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SuccessStoryMinAggregateInputType = {
    id?: true
    userId?: true
    partnerId?: true
    title?: true
    story?: true
    weddingDate?: true
    isApproved?: true
    isFeatured?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SuccessStoryMaxAggregateInputType = {
    id?: true
    userId?: true
    partnerId?: true
    title?: true
    story?: true
    weddingDate?: true
    isApproved?: true
    isFeatured?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SuccessStoryCountAggregateInputType = {
    id?: true
    userId?: true
    partnerId?: true
    title?: true
    story?: true
    weddingDate?: true
    photos?: true
    isApproved?: true
    isFeatured?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SuccessStoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SuccessStory to aggregate.
     */
    where?: SuccessStoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuccessStories to fetch.
     */
    orderBy?: SuccessStoryOrderByWithRelationInput | SuccessStoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SuccessStoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuccessStories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuccessStories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SuccessStories
    **/
    _count?: true | SuccessStoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SuccessStoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SuccessStoryMaxAggregateInputType
  }

  export type GetSuccessStoryAggregateType<T extends SuccessStoryAggregateArgs> = {
        [P in keyof T & keyof AggregateSuccessStory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSuccessStory[P]>
      : GetScalarType<T[P], AggregateSuccessStory[P]>
  }




  export type SuccessStoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SuccessStoryWhereInput
    orderBy?: SuccessStoryOrderByWithAggregationInput | SuccessStoryOrderByWithAggregationInput[]
    by: SuccessStoryScalarFieldEnum[] | SuccessStoryScalarFieldEnum
    having?: SuccessStoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SuccessStoryCountAggregateInputType | true
    _min?: SuccessStoryMinAggregateInputType
    _max?: SuccessStoryMaxAggregateInputType
  }

  export type SuccessStoryGroupByOutputType = {
    id: string
    userId: string
    partnerId: string
    title: string
    story: string
    weddingDate: Date | null
    photos: JsonValue | null
    isApproved: boolean
    isFeatured: boolean
    createdAt: Date
    updatedAt: Date
    _count: SuccessStoryCountAggregateOutputType | null
    _min: SuccessStoryMinAggregateOutputType | null
    _max: SuccessStoryMaxAggregateOutputType | null
  }

  type GetSuccessStoryGroupByPayload<T extends SuccessStoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SuccessStoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SuccessStoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SuccessStoryGroupByOutputType[P]>
            : GetScalarType<T[P], SuccessStoryGroupByOutputType[P]>
        }
      >
    >


  export type SuccessStorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    partnerId?: boolean
    title?: boolean
    story?: boolean
    weddingDate?: boolean
    photos?: boolean
    isApproved?: boolean
    isFeatured?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["successStory"]>

  export type SuccessStorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    partnerId?: boolean
    title?: boolean
    story?: boolean
    weddingDate?: boolean
    photos?: boolean
    isApproved?: boolean
    isFeatured?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["successStory"]>

  export type SuccessStorySelectScalar = {
    id?: boolean
    userId?: boolean
    partnerId?: boolean
    title?: boolean
    story?: boolean
    weddingDate?: boolean
    photos?: boolean
    isApproved?: boolean
    isFeatured?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SuccessStoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SuccessStoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SuccessStoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SuccessStory"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      partnerId: string
      title: string
      story: string
      weddingDate: Date | null
      photos: Prisma.JsonValue | null
      isApproved: boolean
      isFeatured: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["successStory"]>
    composites: {}
  }

  type SuccessStoryGetPayload<S extends boolean | null | undefined | SuccessStoryDefaultArgs> = $Result.GetResult<Prisma.$SuccessStoryPayload, S>

  type SuccessStoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SuccessStoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SuccessStoryCountAggregateInputType | true
    }

  export interface SuccessStoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SuccessStory'], meta: { name: 'SuccessStory' } }
    /**
     * Find zero or one SuccessStory that matches the filter.
     * @param {SuccessStoryFindUniqueArgs} args - Arguments to find a SuccessStory
     * @example
     * // Get one SuccessStory
     * const successStory = await prisma.successStory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SuccessStoryFindUniqueArgs>(args: SelectSubset<T, SuccessStoryFindUniqueArgs<ExtArgs>>): Prisma__SuccessStoryClient<$Result.GetResult<Prisma.$SuccessStoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SuccessStory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SuccessStoryFindUniqueOrThrowArgs} args - Arguments to find a SuccessStory
     * @example
     * // Get one SuccessStory
     * const successStory = await prisma.successStory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SuccessStoryFindUniqueOrThrowArgs>(args: SelectSubset<T, SuccessStoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SuccessStoryClient<$Result.GetResult<Prisma.$SuccessStoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SuccessStory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuccessStoryFindFirstArgs} args - Arguments to find a SuccessStory
     * @example
     * // Get one SuccessStory
     * const successStory = await prisma.successStory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SuccessStoryFindFirstArgs>(args?: SelectSubset<T, SuccessStoryFindFirstArgs<ExtArgs>>): Prisma__SuccessStoryClient<$Result.GetResult<Prisma.$SuccessStoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SuccessStory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuccessStoryFindFirstOrThrowArgs} args - Arguments to find a SuccessStory
     * @example
     * // Get one SuccessStory
     * const successStory = await prisma.successStory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SuccessStoryFindFirstOrThrowArgs>(args?: SelectSubset<T, SuccessStoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SuccessStoryClient<$Result.GetResult<Prisma.$SuccessStoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SuccessStories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuccessStoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SuccessStories
     * const successStories = await prisma.successStory.findMany()
     * 
     * // Get first 10 SuccessStories
     * const successStories = await prisma.successStory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const successStoryWithIdOnly = await prisma.successStory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SuccessStoryFindManyArgs>(args?: SelectSubset<T, SuccessStoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuccessStoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SuccessStory.
     * @param {SuccessStoryCreateArgs} args - Arguments to create a SuccessStory.
     * @example
     * // Create one SuccessStory
     * const SuccessStory = await prisma.successStory.create({
     *   data: {
     *     // ... data to create a SuccessStory
     *   }
     * })
     * 
     */
    create<T extends SuccessStoryCreateArgs>(args: SelectSubset<T, SuccessStoryCreateArgs<ExtArgs>>): Prisma__SuccessStoryClient<$Result.GetResult<Prisma.$SuccessStoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SuccessStories.
     * @param {SuccessStoryCreateManyArgs} args - Arguments to create many SuccessStories.
     * @example
     * // Create many SuccessStories
     * const successStory = await prisma.successStory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SuccessStoryCreateManyArgs>(args?: SelectSubset<T, SuccessStoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SuccessStories and returns the data saved in the database.
     * @param {SuccessStoryCreateManyAndReturnArgs} args - Arguments to create many SuccessStories.
     * @example
     * // Create many SuccessStories
     * const successStory = await prisma.successStory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SuccessStories and only return the `id`
     * const successStoryWithIdOnly = await prisma.successStory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SuccessStoryCreateManyAndReturnArgs>(args?: SelectSubset<T, SuccessStoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuccessStoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SuccessStory.
     * @param {SuccessStoryDeleteArgs} args - Arguments to delete one SuccessStory.
     * @example
     * // Delete one SuccessStory
     * const SuccessStory = await prisma.successStory.delete({
     *   where: {
     *     // ... filter to delete one SuccessStory
     *   }
     * })
     * 
     */
    delete<T extends SuccessStoryDeleteArgs>(args: SelectSubset<T, SuccessStoryDeleteArgs<ExtArgs>>): Prisma__SuccessStoryClient<$Result.GetResult<Prisma.$SuccessStoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SuccessStory.
     * @param {SuccessStoryUpdateArgs} args - Arguments to update one SuccessStory.
     * @example
     * // Update one SuccessStory
     * const successStory = await prisma.successStory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SuccessStoryUpdateArgs>(args: SelectSubset<T, SuccessStoryUpdateArgs<ExtArgs>>): Prisma__SuccessStoryClient<$Result.GetResult<Prisma.$SuccessStoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SuccessStories.
     * @param {SuccessStoryDeleteManyArgs} args - Arguments to filter SuccessStories to delete.
     * @example
     * // Delete a few SuccessStories
     * const { count } = await prisma.successStory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SuccessStoryDeleteManyArgs>(args?: SelectSubset<T, SuccessStoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SuccessStories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuccessStoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SuccessStories
     * const successStory = await prisma.successStory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SuccessStoryUpdateManyArgs>(args: SelectSubset<T, SuccessStoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SuccessStory.
     * @param {SuccessStoryUpsertArgs} args - Arguments to update or create a SuccessStory.
     * @example
     * // Update or create a SuccessStory
     * const successStory = await prisma.successStory.upsert({
     *   create: {
     *     // ... data to create a SuccessStory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SuccessStory we want to update
     *   }
     * })
     */
    upsert<T extends SuccessStoryUpsertArgs>(args: SelectSubset<T, SuccessStoryUpsertArgs<ExtArgs>>): Prisma__SuccessStoryClient<$Result.GetResult<Prisma.$SuccessStoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SuccessStories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuccessStoryCountArgs} args - Arguments to filter SuccessStories to count.
     * @example
     * // Count the number of SuccessStories
     * const count = await prisma.successStory.count({
     *   where: {
     *     // ... the filter for the SuccessStories we want to count
     *   }
     * })
    **/
    count<T extends SuccessStoryCountArgs>(
      args?: Subset<T, SuccessStoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SuccessStoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SuccessStory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuccessStoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SuccessStoryAggregateArgs>(args: Subset<T, SuccessStoryAggregateArgs>): Prisma.PrismaPromise<GetSuccessStoryAggregateType<T>>

    /**
     * Group by SuccessStory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuccessStoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SuccessStoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SuccessStoryGroupByArgs['orderBy'] }
        : { orderBy?: SuccessStoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SuccessStoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSuccessStoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SuccessStory model
   */
  readonly fields: SuccessStoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SuccessStory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SuccessStoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SuccessStory model
   */ 
  interface SuccessStoryFieldRefs {
    readonly id: FieldRef<"SuccessStory", 'String'>
    readonly userId: FieldRef<"SuccessStory", 'String'>
    readonly partnerId: FieldRef<"SuccessStory", 'String'>
    readonly title: FieldRef<"SuccessStory", 'String'>
    readonly story: FieldRef<"SuccessStory", 'String'>
    readonly weddingDate: FieldRef<"SuccessStory", 'DateTime'>
    readonly photos: FieldRef<"SuccessStory", 'Json'>
    readonly isApproved: FieldRef<"SuccessStory", 'Boolean'>
    readonly isFeatured: FieldRef<"SuccessStory", 'Boolean'>
    readonly createdAt: FieldRef<"SuccessStory", 'DateTime'>
    readonly updatedAt: FieldRef<"SuccessStory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SuccessStory findUnique
   */
  export type SuccessStoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuccessStory
     */
    select?: SuccessStorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuccessStoryInclude<ExtArgs> | null
    /**
     * Filter, which SuccessStory to fetch.
     */
    where: SuccessStoryWhereUniqueInput
  }

  /**
   * SuccessStory findUniqueOrThrow
   */
  export type SuccessStoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuccessStory
     */
    select?: SuccessStorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuccessStoryInclude<ExtArgs> | null
    /**
     * Filter, which SuccessStory to fetch.
     */
    where: SuccessStoryWhereUniqueInput
  }

  /**
   * SuccessStory findFirst
   */
  export type SuccessStoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuccessStory
     */
    select?: SuccessStorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuccessStoryInclude<ExtArgs> | null
    /**
     * Filter, which SuccessStory to fetch.
     */
    where?: SuccessStoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuccessStories to fetch.
     */
    orderBy?: SuccessStoryOrderByWithRelationInput | SuccessStoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SuccessStories.
     */
    cursor?: SuccessStoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuccessStories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuccessStories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SuccessStories.
     */
    distinct?: SuccessStoryScalarFieldEnum | SuccessStoryScalarFieldEnum[]
  }

  /**
   * SuccessStory findFirstOrThrow
   */
  export type SuccessStoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuccessStory
     */
    select?: SuccessStorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuccessStoryInclude<ExtArgs> | null
    /**
     * Filter, which SuccessStory to fetch.
     */
    where?: SuccessStoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuccessStories to fetch.
     */
    orderBy?: SuccessStoryOrderByWithRelationInput | SuccessStoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SuccessStories.
     */
    cursor?: SuccessStoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuccessStories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuccessStories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SuccessStories.
     */
    distinct?: SuccessStoryScalarFieldEnum | SuccessStoryScalarFieldEnum[]
  }

  /**
   * SuccessStory findMany
   */
  export type SuccessStoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuccessStory
     */
    select?: SuccessStorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuccessStoryInclude<ExtArgs> | null
    /**
     * Filter, which SuccessStories to fetch.
     */
    where?: SuccessStoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuccessStories to fetch.
     */
    orderBy?: SuccessStoryOrderByWithRelationInput | SuccessStoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SuccessStories.
     */
    cursor?: SuccessStoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuccessStories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuccessStories.
     */
    skip?: number
    distinct?: SuccessStoryScalarFieldEnum | SuccessStoryScalarFieldEnum[]
  }

  /**
   * SuccessStory create
   */
  export type SuccessStoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuccessStory
     */
    select?: SuccessStorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuccessStoryInclude<ExtArgs> | null
    /**
     * The data needed to create a SuccessStory.
     */
    data: XOR<SuccessStoryCreateInput, SuccessStoryUncheckedCreateInput>
  }

  /**
   * SuccessStory createMany
   */
  export type SuccessStoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SuccessStories.
     */
    data: SuccessStoryCreateManyInput | SuccessStoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SuccessStory createManyAndReturn
   */
  export type SuccessStoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuccessStory
     */
    select?: SuccessStorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SuccessStories.
     */
    data: SuccessStoryCreateManyInput | SuccessStoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuccessStoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SuccessStory update
   */
  export type SuccessStoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuccessStory
     */
    select?: SuccessStorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuccessStoryInclude<ExtArgs> | null
    /**
     * The data needed to update a SuccessStory.
     */
    data: XOR<SuccessStoryUpdateInput, SuccessStoryUncheckedUpdateInput>
    /**
     * Choose, which SuccessStory to update.
     */
    where: SuccessStoryWhereUniqueInput
  }

  /**
   * SuccessStory updateMany
   */
  export type SuccessStoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SuccessStories.
     */
    data: XOR<SuccessStoryUpdateManyMutationInput, SuccessStoryUncheckedUpdateManyInput>
    /**
     * Filter which SuccessStories to update
     */
    where?: SuccessStoryWhereInput
  }

  /**
   * SuccessStory upsert
   */
  export type SuccessStoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuccessStory
     */
    select?: SuccessStorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuccessStoryInclude<ExtArgs> | null
    /**
     * The filter to search for the SuccessStory to update in case it exists.
     */
    where: SuccessStoryWhereUniqueInput
    /**
     * In case the SuccessStory found by the `where` argument doesn't exist, create a new SuccessStory with this data.
     */
    create: XOR<SuccessStoryCreateInput, SuccessStoryUncheckedCreateInput>
    /**
     * In case the SuccessStory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SuccessStoryUpdateInput, SuccessStoryUncheckedUpdateInput>
  }

  /**
   * SuccessStory delete
   */
  export type SuccessStoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuccessStory
     */
    select?: SuccessStorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuccessStoryInclude<ExtArgs> | null
    /**
     * Filter which SuccessStory to delete.
     */
    where: SuccessStoryWhereUniqueInput
  }

  /**
   * SuccessStory deleteMany
   */
  export type SuccessStoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SuccessStories to delete
     */
    where?: SuccessStoryWhereInput
  }

  /**
   * SuccessStory without action
   */
  export type SuccessStoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuccessStory
     */
    select?: SuccessStorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuccessStoryInclude<ExtArgs> | null
  }


  /**
   * Model FamilyMember
   */

  export type AggregateFamilyMember = {
    _count: FamilyMemberCountAggregateOutputType | null
    _min: FamilyMemberMinAggregateOutputType | null
    _max: FamilyMemberMaxAggregateOutputType | null
  }

  export type FamilyMemberMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    relation: string | null
    email: string | null
    mobile: string | null
    password: string | null
    canViewMatches: boolean | null
    canSendInterests: boolean | null
    canChat: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FamilyMemberMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    relation: string | null
    email: string | null
    mobile: string | null
    password: string | null
    canViewMatches: boolean | null
    canSendInterests: boolean | null
    canChat: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FamilyMemberCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    relation: number
    email: number
    mobile: number
    password: number
    canViewMatches: number
    canSendInterests: number
    canChat: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FamilyMemberMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    relation?: true
    email?: true
    mobile?: true
    password?: true
    canViewMatches?: true
    canSendInterests?: true
    canChat?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FamilyMemberMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    relation?: true
    email?: true
    mobile?: true
    password?: true
    canViewMatches?: true
    canSendInterests?: true
    canChat?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FamilyMemberCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    relation?: true
    email?: true
    mobile?: true
    password?: true
    canViewMatches?: true
    canSendInterests?: true
    canChat?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FamilyMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FamilyMember to aggregate.
     */
    where?: FamilyMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyMembers to fetch.
     */
    orderBy?: FamilyMemberOrderByWithRelationInput | FamilyMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FamilyMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FamilyMembers
    **/
    _count?: true | FamilyMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FamilyMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FamilyMemberMaxAggregateInputType
  }

  export type GetFamilyMemberAggregateType<T extends FamilyMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateFamilyMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFamilyMember[P]>
      : GetScalarType<T[P], AggregateFamilyMember[P]>
  }




  export type FamilyMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FamilyMemberWhereInput
    orderBy?: FamilyMemberOrderByWithAggregationInput | FamilyMemberOrderByWithAggregationInput[]
    by: FamilyMemberScalarFieldEnum[] | FamilyMemberScalarFieldEnum
    having?: FamilyMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FamilyMemberCountAggregateInputType | true
    _min?: FamilyMemberMinAggregateInputType
    _max?: FamilyMemberMaxAggregateInputType
  }

  export type FamilyMemberGroupByOutputType = {
    id: string
    userId: string
    name: string
    relation: string
    email: string | null
    mobile: string | null
    password: string | null
    canViewMatches: boolean
    canSendInterests: boolean
    canChat: boolean
    createdAt: Date
    updatedAt: Date
    _count: FamilyMemberCountAggregateOutputType | null
    _min: FamilyMemberMinAggregateOutputType | null
    _max: FamilyMemberMaxAggregateOutputType | null
  }

  type GetFamilyMemberGroupByPayload<T extends FamilyMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FamilyMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FamilyMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FamilyMemberGroupByOutputType[P]>
            : GetScalarType<T[P], FamilyMemberGroupByOutputType[P]>
        }
      >
    >


  export type FamilyMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    relation?: boolean
    email?: boolean
    mobile?: boolean
    password?: boolean
    canViewMatches?: boolean
    canSendInterests?: boolean
    canChat?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["familyMember"]>

  export type FamilyMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    relation?: boolean
    email?: boolean
    mobile?: boolean
    password?: boolean
    canViewMatches?: boolean
    canSendInterests?: boolean
    canChat?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["familyMember"]>

  export type FamilyMemberSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    relation?: boolean
    email?: boolean
    mobile?: boolean
    password?: boolean
    canViewMatches?: boolean
    canSendInterests?: boolean
    canChat?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FamilyMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FamilyMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FamilyMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FamilyMember"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      relation: string
      email: string | null
      mobile: string | null
      password: string | null
      canViewMatches: boolean
      canSendInterests: boolean
      canChat: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["familyMember"]>
    composites: {}
  }

  type FamilyMemberGetPayload<S extends boolean | null | undefined | FamilyMemberDefaultArgs> = $Result.GetResult<Prisma.$FamilyMemberPayload, S>

  type FamilyMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FamilyMemberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FamilyMemberCountAggregateInputType | true
    }

  export interface FamilyMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FamilyMember'], meta: { name: 'FamilyMember' } }
    /**
     * Find zero or one FamilyMember that matches the filter.
     * @param {FamilyMemberFindUniqueArgs} args - Arguments to find a FamilyMember
     * @example
     * // Get one FamilyMember
     * const familyMember = await prisma.familyMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FamilyMemberFindUniqueArgs>(args: SelectSubset<T, FamilyMemberFindUniqueArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FamilyMember that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FamilyMemberFindUniqueOrThrowArgs} args - Arguments to find a FamilyMember
     * @example
     * // Get one FamilyMember
     * const familyMember = await prisma.familyMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FamilyMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, FamilyMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FamilyMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMemberFindFirstArgs} args - Arguments to find a FamilyMember
     * @example
     * // Get one FamilyMember
     * const familyMember = await prisma.familyMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FamilyMemberFindFirstArgs>(args?: SelectSubset<T, FamilyMemberFindFirstArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FamilyMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMemberFindFirstOrThrowArgs} args - Arguments to find a FamilyMember
     * @example
     * // Get one FamilyMember
     * const familyMember = await prisma.familyMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FamilyMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, FamilyMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FamilyMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FamilyMembers
     * const familyMembers = await prisma.familyMember.findMany()
     * 
     * // Get first 10 FamilyMembers
     * const familyMembers = await prisma.familyMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const familyMemberWithIdOnly = await prisma.familyMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FamilyMemberFindManyArgs>(args?: SelectSubset<T, FamilyMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FamilyMember.
     * @param {FamilyMemberCreateArgs} args - Arguments to create a FamilyMember.
     * @example
     * // Create one FamilyMember
     * const FamilyMember = await prisma.familyMember.create({
     *   data: {
     *     // ... data to create a FamilyMember
     *   }
     * })
     * 
     */
    create<T extends FamilyMemberCreateArgs>(args: SelectSubset<T, FamilyMemberCreateArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FamilyMembers.
     * @param {FamilyMemberCreateManyArgs} args - Arguments to create many FamilyMembers.
     * @example
     * // Create many FamilyMembers
     * const familyMember = await prisma.familyMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FamilyMemberCreateManyArgs>(args?: SelectSubset<T, FamilyMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FamilyMembers and returns the data saved in the database.
     * @param {FamilyMemberCreateManyAndReturnArgs} args - Arguments to create many FamilyMembers.
     * @example
     * // Create many FamilyMembers
     * const familyMember = await prisma.familyMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FamilyMembers and only return the `id`
     * const familyMemberWithIdOnly = await prisma.familyMember.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FamilyMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, FamilyMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FamilyMember.
     * @param {FamilyMemberDeleteArgs} args - Arguments to delete one FamilyMember.
     * @example
     * // Delete one FamilyMember
     * const FamilyMember = await prisma.familyMember.delete({
     *   where: {
     *     // ... filter to delete one FamilyMember
     *   }
     * })
     * 
     */
    delete<T extends FamilyMemberDeleteArgs>(args: SelectSubset<T, FamilyMemberDeleteArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FamilyMember.
     * @param {FamilyMemberUpdateArgs} args - Arguments to update one FamilyMember.
     * @example
     * // Update one FamilyMember
     * const familyMember = await prisma.familyMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FamilyMemberUpdateArgs>(args: SelectSubset<T, FamilyMemberUpdateArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FamilyMembers.
     * @param {FamilyMemberDeleteManyArgs} args - Arguments to filter FamilyMembers to delete.
     * @example
     * // Delete a few FamilyMembers
     * const { count } = await prisma.familyMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FamilyMemberDeleteManyArgs>(args?: SelectSubset<T, FamilyMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FamilyMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FamilyMembers
     * const familyMember = await prisma.familyMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FamilyMemberUpdateManyArgs>(args: SelectSubset<T, FamilyMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FamilyMember.
     * @param {FamilyMemberUpsertArgs} args - Arguments to update or create a FamilyMember.
     * @example
     * // Update or create a FamilyMember
     * const familyMember = await prisma.familyMember.upsert({
     *   create: {
     *     // ... data to create a FamilyMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FamilyMember we want to update
     *   }
     * })
     */
    upsert<T extends FamilyMemberUpsertArgs>(args: SelectSubset<T, FamilyMemberUpsertArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FamilyMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMemberCountArgs} args - Arguments to filter FamilyMembers to count.
     * @example
     * // Count the number of FamilyMembers
     * const count = await prisma.familyMember.count({
     *   where: {
     *     // ... the filter for the FamilyMembers we want to count
     *   }
     * })
    **/
    count<T extends FamilyMemberCountArgs>(
      args?: Subset<T, FamilyMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FamilyMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FamilyMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FamilyMemberAggregateArgs>(args: Subset<T, FamilyMemberAggregateArgs>): Prisma.PrismaPromise<GetFamilyMemberAggregateType<T>>

    /**
     * Group by FamilyMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FamilyMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FamilyMemberGroupByArgs['orderBy'] }
        : { orderBy?: FamilyMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FamilyMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFamilyMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FamilyMember model
   */
  readonly fields: FamilyMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FamilyMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FamilyMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FamilyMember model
   */ 
  interface FamilyMemberFieldRefs {
    readonly id: FieldRef<"FamilyMember", 'String'>
    readonly userId: FieldRef<"FamilyMember", 'String'>
    readonly name: FieldRef<"FamilyMember", 'String'>
    readonly relation: FieldRef<"FamilyMember", 'String'>
    readonly email: FieldRef<"FamilyMember", 'String'>
    readonly mobile: FieldRef<"FamilyMember", 'String'>
    readonly password: FieldRef<"FamilyMember", 'String'>
    readonly canViewMatches: FieldRef<"FamilyMember", 'Boolean'>
    readonly canSendInterests: FieldRef<"FamilyMember", 'Boolean'>
    readonly canChat: FieldRef<"FamilyMember", 'Boolean'>
    readonly createdAt: FieldRef<"FamilyMember", 'DateTime'>
    readonly updatedAt: FieldRef<"FamilyMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FamilyMember findUnique
   */
  export type FamilyMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    /**
     * Filter, which FamilyMember to fetch.
     */
    where: FamilyMemberWhereUniqueInput
  }

  /**
   * FamilyMember findUniqueOrThrow
   */
  export type FamilyMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    /**
     * Filter, which FamilyMember to fetch.
     */
    where: FamilyMemberWhereUniqueInput
  }

  /**
   * FamilyMember findFirst
   */
  export type FamilyMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    /**
     * Filter, which FamilyMember to fetch.
     */
    where?: FamilyMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyMembers to fetch.
     */
    orderBy?: FamilyMemberOrderByWithRelationInput | FamilyMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FamilyMembers.
     */
    cursor?: FamilyMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FamilyMembers.
     */
    distinct?: FamilyMemberScalarFieldEnum | FamilyMemberScalarFieldEnum[]
  }

  /**
   * FamilyMember findFirstOrThrow
   */
  export type FamilyMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    /**
     * Filter, which FamilyMember to fetch.
     */
    where?: FamilyMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyMembers to fetch.
     */
    orderBy?: FamilyMemberOrderByWithRelationInput | FamilyMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FamilyMembers.
     */
    cursor?: FamilyMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FamilyMembers.
     */
    distinct?: FamilyMemberScalarFieldEnum | FamilyMemberScalarFieldEnum[]
  }

  /**
   * FamilyMember findMany
   */
  export type FamilyMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    /**
     * Filter, which FamilyMembers to fetch.
     */
    where?: FamilyMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyMembers to fetch.
     */
    orderBy?: FamilyMemberOrderByWithRelationInput | FamilyMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FamilyMembers.
     */
    cursor?: FamilyMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyMembers.
     */
    skip?: number
    distinct?: FamilyMemberScalarFieldEnum | FamilyMemberScalarFieldEnum[]
  }

  /**
   * FamilyMember create
   */
  export type FamilyMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a FamilyMember.
     */
    data: XOR<FamilyMemberCreateInput, FamilyMemberUncheckedCreateInput>
  }

  /**
   * FamilyMember createMany
   */
  export type FamilyMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FamilyMembers.
     */
    data: FamilyMemberCreateManyInput | FamilyMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FamilyMember createManyAndReturn
   */
  export type FamilyMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FamilyMembers.
     */
    data: FamilyMemberCreateManyInput | FamilyMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FamilyMember update
   */
  export type FamilyMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a FamilyMember.
     */
    data: XOR<FamilyMemberUpdateInput, FamilyMemberUncheckedUpdateInput>
    /**
     * Choose, which FamilyMember to update.
     */
    where: FamilyMemberWhereUniqueInput
  }

  /**
   * FamilyMember updateMany
   */
  export type FamilyMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FamilyMembers.
     */
    data: XOR<FamilyMemberUpdateManyMutationInput, FamilyMemberUncheckedUpdateManyInput>
    /**
     * Filter which FamilyMembers to update
     */
    where?: FamilyMemberWhereInput
  }

  /**
   * FamilyMember upsert
   */
  export type FamilyMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the FamilyMember to update in case it exists.
     */
    where: FamilyMemberWhereUniqueInput
    /**
     * In case the FamilyMember found by the `where` argument doesn't exist, create a new FamilyMember with this data.
     */
    create: XOR<FamilyMemberCreateInput, FamilyMemberUncheckedCreateInput>
    /**
     * In case the FamilyMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FamilyMemberUpdateInput, FamilyMemberUncheckedUpdateInput>
  }

  /**
   * FamilyMember delete
   */
  export type FamilyMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    /**
     * Filter which FamilyMember to delete.
     */
    where: FamilyMemberWhereUniqueInput
  }

  /**
   * FamilyMember deleteMany
   */
  export type FamilyMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FamilyMembers to delete
     */
    where?: FamilyMemberWhereInput
  }

  /**
   * FamilyMember without action
   */
  export type FamilyMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
  }


  /**
   * Model Referral
   */

  export type AggregateReferral = {
    _count: ReferralCountAggregateOutputType | null
    _avg: ReferralAvgAggregateOutputType | null
    _sum: ReferralSumAggregateOutputType | null
    _min: ReferralMinAggregateOutputType | null
    _max: ReferralMaxAggregateOutputType | null
  }

  export type ReferralAvgAggregateOutputType = {
    rewardAmount: number | null
  }

  export type ReferralSumAggregateOutputType = {
    rewardAmount: number | null
  }

  export type ReferralMinAggregateOutputType = {
    id: string | null
    referrerId: string | null
    referredId: string | null
    rewardAmount: number | null
    status: string | null
    completedAt: Date | null
    createdAt: Date | null
  }

  export type ReferralMaxAggregateOutputType = {
    id: string | null
    referrerId: string | null
    referredId: string | null
    rewardAmount: number | null
    status: string | null
    completedAt: Date | null
    createdAt: Date | null
  }

  export type ReferralCountAggregateOutputType = {
    id: number
    referrerId: number
    referredId: number
    rewardAmount: number
    status: number
    completedAt: number
    createdAt: number
    _all: number
  }


  export type ReferralAvgAggregateInputType = {
    rewardAmount?: true
  }

  export type ReferralSumAggregateInputType = {
    rewardAmount?: true
  }

  export type ReferralMinAggregateInputType = {
    id?: true
    referrerId?: true
    referredId?: true
    rewardAmount?: true
    status?: true
    completedAt?: true
    createdAt?: true
  }

  export type ReferralMaxAggregateInputType = {
    id?: true
    referrerId?: true
    referredId?: true
    rewardAmount?: true
    status?: true
    completedAt?: true
    createdAt?: true
  }

  export type ReferralCountAggregateInputType = {
    id?: true
    referrerId?: true
    referredId?: true
    rewardAmount?: true
    status?: true
    completedAt?: true
    createdAt?: true
    _all?: true
  }

  export type ReferralAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referral to aggregate.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Referrals
    **/
    _count?: true | ReferralCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReferralAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReferralSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferralMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferralMaxAggregateInputType
  }

  export type GetReferralAggregateType<T extends ReferralAggregateArgs> = {
        [P in keyof T & keyof AggregateReferral]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferral[P]>
      : GetScalarType<T[P], AggregateReferral[P]>
  }




  export type ReferralGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithAggregationInput | ReferralOrderByWithAggregationInput[]
    by: ReferralScalarFieldEnum[] | ReferralScalarFieldEnum
    having?: ReferralScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferralCountAggregateInputType | true
    _avg?: ReferralAvgAggregateInputType
    _sum?: ReferralSumAggregateInputType
    _min?: ReferralMinAggregateInputType
    _max?: ReferralMaxAggregateInputType
  }

  export type ReferralGroupByOutputType = {
    id: string
    referrerId: string
    referredId: string
    rewardAmount: number | null
    status: string
    completedAt: Date | null
    createdAt: Date
    _count: ReferralCountAggregateOutputType | null
    _avg: ReferralAvgAggregateOutputType | null
    _sum: ReferralSumAggregateOutputType | null
    _min: ReferralMinAggregateOutputType | null
    _max: ReferralMaxAggregateOutputType | null
  }

  type GetReferralGroupByPayload<T extends ReferralGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferralGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferralGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferralGroupByOutputType[P]>
            : GetScalarType<T[P], ReferralGroupByOutputType[P]>
        }
      >
    >


  export type ReferralSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referrerId?: boolean
    referredId?: boolean
    rewardAmount?: boolean
    status?: boolean
    completedAt?: boolean
    createdAt?: boolean
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referred?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referral"]>

  export type ReferralSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referrerId?: boolean
    referredId?: boolean
    rewardAmount?: boolean
    status?: boolean
    completedAt?: boolean
    createdAt?: boolean
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referred?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referral"]>

  export type ReferralSelectScalar = {
    id?: boolean
    referrerId?: boolean
    referredId?: boolean
    rewardAmount?: boolean
    status?: boolean
    completedAt?: boolean
    createdAt?: boolean
  }

  export type ReferralInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referred?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReferralIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referred?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReferralPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Referral"
    objects: {
      referrer: Prisma.$UserPayload<ExtArgs>
      referred: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      referrerId: string
      referredId: string
      rewardAmount: number | null
      status: string
      completedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["referral"]>
    composites: {}
  }

  type ReferralGetPayload<S extends boolean | null | undefined | ReferralDefaultArgs> = $Result.GetResult<Prisma.$ReferralPayload, S>

  type ReferralCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReferralFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReferralCountAggregateInputType | true
    }

  export interface ReferralDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Referral'], meta: { name: 'Referral' } }
    /**
     * Find zero or one Referral that matches the filter.
     * @param {ReferralFindUniqueArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferralFindUniqueArgs>(args: SelectSubset<T, ReferralFindUniqueArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Referral that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReferralFindUniqueOrThrowArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferralFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferralFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Referral that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindFirstArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferralFindFirstArgs>(args?: SelectSubset<T, ReferralFindFirstArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Referral that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindFirstOrThrowArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferralFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferralFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Referrals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Referrals
     * const referrals = await prisma.referral.findMany()
     * 
     * // Get first 10 Referrals
     * const referrals = await prisma.referral.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referralWithIdOnly = await prisma.referral.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReferralFindManyArgs>(args?: SelectSubset<T, ReferralFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Referral.
     * @param {ReferralCreateArgs} args - Arguments to create a Referral.
     * @example
     * // Create one Referral
     * const Referral = await prisma.referral.create({
     *   data: {
     *     // ... data to create a Referral
     *   }
     * })
     * 
     */
    create<T extends ReferralCreateArgs>(args: SelectSubset<T, ReferralCreateArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Referrals.
     * @param {ReferralCreateManyArgs} args - Arguments to create many Referrals.
     * @example
     * // Create many Referrals
     * const referral = await prisma.referral.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferralCreateManyArgs>(args?: SelectSubset<T, ReferralCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Referrals and returns the data saved in the database.
     * @param {ReferralCreateManyAndReturnArgs} args - Arguments to create many Referrals.
     * @example
     * // Create many Referrals
     * const referral = await prisma.referral.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Referrals and only return the `id`
     * const referralWithIdOnly = await prisma.referral.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReferralCreateManyAndReturnArgs>(args?: SelectSubset<T, ReferralCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Referral.
     * @param {ReferralDeleteArgs} args - Arguments to delete one Referral.
     * @example
     * // Delete one Referral
     * const Referral = await prisma.referral.delete({
     *   where: {
     *     // ... filter to delete one Referral
     *   }
     * })
     * 
     */
    delete<T extends ReferralDeleteArgs>(args: SelectSubset<T, ReferralDeleteArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Referral.
     * @param {ReferralUpdateArgs} args - Arguments to update one Referral.
     * @example
     * // Update one Referral
     * const referral = await prisma.referral.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferralUpdateArgs>(args: SelectSubset<T, ReferralUpdateArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Referrals.
     * @param {ReferralDeleteManyArgs} args - Arguments to filter Referrals to delete.
     * @example
     * // Delete a few Referrals
     * const { count } = await prisma.referral.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferralDeleteManyArgs>(args?: SelectSubset<T, ReferralDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Referrals
     * const referral = await prisma.referral.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferralUpdateManyArgs>(args: SelectSubset<T, ReferralUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Referral.
     * @param {ReferralUpsertArgs} args - Arguments to update or create a Referral.
     * @example
     * // Update or create a Referral
     * const referral = await prisma.referral.upsert({
     *   create: {
     *     // ... data to create a Referral
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Referral we want to update
     *   }
     * })
     */
    upsert<T extends ReferralUpsertArgs>(args: SelectSubset<T, ReferralUpsertArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralCountArgs} args - Arguments to filter Referrals to count.
     * @example
     * // Count the number of Referrals
     * const count = await prisma.referral.count({
     *   where: {
     *     // ... the filter for the Referrals we want to count
     *   }
     * })
    **/
    count<T extends ReferralCountArgs>(
      args?: Subset<T, ReferralCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferralCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Referral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferralAggregateArgs>(args: Subset<T, ReferralAggregateArgs>): Prisma.PrismaPromise<GetReferralAggregateType<T>>

    /**
     * Group by Referral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferralGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferralGroupByArgs['orderBy'] }
        : { orderBy?: ReferralGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferralGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferralGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Referral model
   */
  readonly fields: ReferralFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Referral.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferralClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    referrer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    referred<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Referral model
   */ 
  interface ReferralFieldRefs {
    readonly id: FieldRef<"Referral", 'String'>
    readonly referrerId: FieldRef<"Referral", 'String'>
    readonly referredId: FieldRef<"Referral", 'String'>
    readonly rewardAmount: FieldRef<"Referral", 'Int'>
    readonly status: FieldRef<"Referral", 'String'>
    readonly completedAt: FieldRef<"Referral", 'DateTime'>
    readonly createdAt: FieldRef<"Referral", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Referral findUnique
   */
  export type ReferralFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral findUniqueOrThrow
   */
  export type ReferralFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral findFirst
   */
  export type ReferralFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrals.
     */
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral findFirstOrThrow
   */
  export type ReferralFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrals.
     */
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral findMany
   */
  export type ReferralFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referrals to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral create
   */
  export type ReferralCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The data needed to create a Referral.
     */
    data: XOR<ReferralCreateInput, ReferralUncheckedCreateInput>
  }

  /**
   * Referral createMany
   */
  export type ReferralCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Referrals.
     */
    data: ReferralCreateManyInput | ReferralCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Referral createManyAndReturn
   */
  export type ReferralCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Referrals.
     */
    data: ReferralCreateManyInput | ReferralCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Referral update
   */
  export type ReferralUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The data needed to update a Referral.
     */
    data: XOR<ReferralUpdateInput, ReferralUncheckedUpdateInput>
    /**
     * Choose, which Referral to update.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral updateMany
   */
  export type ReferralUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Referrals.
     */
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyInput>
    /**
     * Filter which Referrals to update
     */
    where?: ReferralWhereInput
  }

  /**
   * Referral upsert
   */
  export type ReferralUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The filter to search for the Referral to update in case it exists.
     */
    where: ReferralWhereUniqueInput
    /**
     * In case the Referral found by the `where` argument doesn't exist, create a new Referral with this data.
     */
    create: XOR<ReferralCreateInput, ReferralUncheckedCreateInput>
    /**
     * In case the Referral was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferralUpdateInput, ReferralUncheckedUpdateInput>
  }

  /**
   * Referral delete
   */
  export type ReferralDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter which Referral to delete.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral deleteMany
   */
  export type ReferralDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referrals to delete
     */
    where?: ReferralWhereInput
  }

  /**
   * Referral without action
   */
  export type ReferralDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
  }


  /**
   * Model Achievement
   */

  export type AggregateAchievement = {
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  export type AchievementAvgAggregateOutputType = {
    points: number | null
  }

  export type AchievementSumAggregateOutputType = {
    points: number | null
  }

  export type AchievementMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    description: string | null
    points: number | null
    icon: string | null
    unlockedAt: Date | null
  }

  export type AchievementMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    description: string | null
    points: number | null
    icon: string | null
    unlockedAt: Date | null
  }

  export type AchievementCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    description: number
    points: number
    icon: number
    unlockedAt: number
    _all: number
  }


  export type AchievementAvgAggregateInputType = {
    points?: true
  }

  export type AchievementSumAggregateInputType = {
    points?: true
  }

  export type AchievementMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    description?: true
    points?: true
    icon?: true
    unlockedAt?: true
  }

  export type AchievementMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    description?: true
    points?: true
    icon?: true
    unlockedAt?: true
  }

  export type AchievementCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    description?: true
    points?: true
    icon?: true
    unlockedAt?: true
    _all?: true
  }

  export type AchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievement to aggregate.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Achievements
    **/
    _count?: true | AchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AchievementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AchievementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AchievementMaxAggregateInputType
  }

  export type GetAchievementAggregateType<T extends AchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAchievement[P]>
      : GetScalarType<T[P], AggregateAchievement[P]>
  }




  export type AchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementWhereInput
    orderBy?: AchievementOrderByWithAggregationInput | AchievementOrderByWithAggregationInput[]
    by: AchievementScalarFieldEnum[] | AchievementScalarFieldEnum
    having?: AchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AchievementCountAggregateInputType | true
    _avg?: AchievementAvgAggregateInputType
    _sum?: AchievementSumAggregateInputType
    _min?: AchievementMinAggregateInputType
    _max?: AchievementMaxAggregateInputType
  }

  export type AchievementGroupByOutputType = {
    id: string
    userId: string
    type: string
    title: string
    description: string | null
    points: number
    icon: string | null
    unlockedAt: Date
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  type GetAchievementGroupByPayload<T extends AchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AchievementGroupByOutputType[P]>
            : GetScalarType<T[P], AchievementGroupByOutputType[P]>
        }
      >
    >


  export type AchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    points?: boolean
    icon?: boolean
    unlockedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    points?: boolean
    icon?: boolean
    unlockedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    points?: boolean
    icon?: boolean
    unlockedAt?: boolean
  }

  export type AchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Achievement"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      title: string
      description: string | null
      points: number
      icon: string | null
      unlockedAt: Date
    }, ExtArgs["result"]["achievement"]>
    composites: {}
  }

  type AchievementGetPayload<S extends boolean | null | undefined | AchievementDefaultArgs> = $Result.GetResult<Prisma.$AchievementPayload, S>

  type AchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AchievementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AchievementCountAggregateInputType | true
    }

  export interface AchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Achievement'], meta: { name: 'Achievement' } }
    /**
     * Find zero or one Achievement that matches the filter.
     * @param {AchievementFindUniqueArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AchievementFindUniqueArgs>(args: SelectSubset<T, AchievementFindUniqueArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Achievement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AchievementFindUniqueOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, AchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Achievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AchievementFindFirstArgs>(args?: SelectSubset<T, AchievementFindFirstArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Achievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, AchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Achievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Achievements
     * const achievements = await prisma.achievement.findMany()
     * 
     * // Get first 10 Achievements
     * const achievements = await prisma.achievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const achievementWithIdOnly = await prisma.achievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AchievementFindManyArgs>(args?: SelectSubset<T, AchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Achievement.
     * @param {AchievementCreateArgs} args - Arguments to create a Achievement.
     * @example
     * // Create one Achievement
     * const Achievement = await prisma.achievement.create({
     *   data: {
     *     // ... data to create a Achievement
     *   }
     * })
     * 
     */
    create<T extends AchievementCreateArgs>(args: SelectSubset<T, AchievementCreateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Achievements.
     * @param {AchievementCreateManyArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AchievementCreateManyArgs>(args?: SelectSubset<T, AchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Achievements and returns the data saved in the database.
     * @param {AchievementCreateManyAndReturnArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, AchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Achievement.
     * @param {AchievementDeleteArgs} args - Arguments to delete one Achievement.
     * @example
     * // Delete one Achievement
     * const Achievement = await prisma.achievement.delete({
     *   where: {
     *     // ... filter to delete one Achievement
     *   }
     * })
     * 
     */
    delete<T extends AchievementDeleteArgs>(args: SelectSubset<T, AchievementDeleteArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Achievement.
     * @param {AchievementUpdateArgs} args - Arguments to update one Achievement.
     * @example
     * // Update one Achievement
     * const achievement = await prisma.achievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AchievementUpdateArgs>(args: SelectSubset<T, AchievementUpdateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Achievements.
     * @param {AchievementDeleteManyArgs} args - Arguments to filter Achievements to delete.
     * @example
     * // Delete a few Achievements
     * const { count } = await prisma.achievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AchievementDeleteManyArgs>(args?: SelectSubset<T, AchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AchievementUpdateManyArgs>(args: SelectSubset<T, AchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Achievement.
     * @param {AchievementUpsertArgs} args - Arguments to update or create a Achievement.
     * @example
     * // Update or create a Achievement
     * const achievement = await prisma.achievement.upsert({
     *   create: {
     *     // ... data to create a Achievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Achievement we want to update
     *   }
     * })
     */
    upsert<T extends AchievementUpsertArgs>(args: SelectSubset<T, AchievementUpsertArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementCountArgs} args - Arguments to filter Achievements to count.
     * @example
     * // Count the number of Achievements
     * const count = await prisma.achievement.count({
     *   where: {
     *     // ... the filter for the Achievements we want to count
     *   }
     * })
    **/
    count<T extends AchievementCountArgs>(
      args?: Subset<T, AchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AchievementAggregateArgs>(args: Subset<T, AchievementAggregateArgs>): Prisma.PrismaPromise<GetAchievementAggregateType<T>>

    /**
     * Group by Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AchievementGroupByArgs['orderBy'] }
        : { orderBy?: AchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Achievement model
   */
  readonly fields: AchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Achievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Achievement model
   */ 
  interface AchievementFieldRefs {
    readonly id: FieldRef<"Achievement", 'String'>
    readonly userId: FieldRef<"Achievement", 'String'>
    readonly type: FieldRef<"Achievement", 'String'>
    readonly title: FieldRef<"Achievement", 'String'>
    readonly description: FieldRef<"Achievement", 'String'>
    readonly points: FieldRef<"Achievement", 'Int'>
    readonly icon: FieldRef<"Achievement", 'String'>
    readonly unlockedAt: FieldRef<"Achievement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Achievement findUnique
   */
  export type AchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findUniqueOrThrow
   */
  export type AchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findFirst
   */
  export type AchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findFirstOrThrow
   */
  export type AchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findMany
   */
  export type AchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievements to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement create
   */
  export type AchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a Achievement.
     */
    data: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
  }

  /**
   * Achievement createMany
   */
  export type AchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Achievement createManyAndReturn
   */
  export type AchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Achievement update
   */
  export type AchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a Achievement.
     */
    data: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
    /**
     * Choose, which Achievement to update.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement updateMany
   */
  export type AchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
  }

  /**
   * Achievement upsert
   */
  export type AchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the Achievement to update in case it exists.
     */
    where: AchievementWhereUniqueInput
    /**
     * In case the Achievement found by the `where` argument doesn't exist, create a new Achievement with this data.
     */
    create: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
    /**
     * In case the Achievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
  }

  /**
   * Achievement delete
   */
  export type AchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter which Achievement to delete.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement deleteMany
   */
  export type AchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievements to delete
     */
    where?: AchievementWhereInput
  }

  /**
   * Achievement without action
   */
  export type AchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    name: string | null
    url: string | null
    expiryDate: Date | null
    isVerified: boolean | null
    verifiedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    name: string | null
    url: string | null
    expiryDate: Date | null
    isVerified: boolean | null
    verifiedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    name: number
    url: number
    expiryDate: number
    isVerified: number
    verifiedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DocumentMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    name?: true
    url?: true
    expiryDate?: true
    isVerified?: true
    verifiedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    name?: true
    url?: true
    expiryDate?: true
    isVerified?: true
    verifiedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    name?: true
    url?: true
    expiryDate?: true
    isVerified?: true
    verifiedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    userId: string
    type: string
    name: string
    url: string
    expiryDate: Date | null
    isVerified: boolean
    verifiedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    name?: boolean
    url?: boolean
    expiryDate?: boolean
    isVerified?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    name?: boolean
    url?: boolean
    expiryDate?: boolean
    isVerified?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    name?: boolean
    url?: boolean
    expiryDate?: boolean
    isVerified?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      name: string
      url: string
      expiryDate: Date | null
      isVerified: boolean
      verifiedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */ 
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly userId: FieldRef<"Document", 'String'>
    readonly type: FieldRef<"Document", 'String'>
    readonly name: FieldRef<"Document", 'String'>
    readonly url: FieldRef<"Document", 'String'>
    readonly expiryDate: FieldRef<"Document", 'DateTime'>
    readonly isVerified: FieldRef<"Document", 'Boolean'>
    readonly verifiedAt: FieldRef<"Document", 'DateTime'>
    readonly createdAt: FieldRef<"Document", 'DateTime'>
    readonly updatedAt: FieldRef<"Document", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model VideoCall
   */

  export type AggregateVideoCall = {
    _count: VideoCallCountAggregateOutputType | null
    _avg: VideoCallAvgAggregateOutputType | null
    _sum: VideoCallSumAggregateOutputType | null
    _min: VideoCallMinAggregateOutputType | null
    _max: VideoCallMaxAggregateOutputType | null
  }

  export type VideoCallAvgAggregateOutputType = {
    duration: number | null
  }

  export type VideoCallSumAggregateOutputType = {
    duration: number | null
  }

  export type VideoCallMinAggregateOutputType = {
    id: string | null
    callerId: string | null
    participantId: string | null
    status: string | null
    scheduledAt: Date | null
    startedAt: Date | null
    endedAt: Date | null
    cancelledAt: Date | null
    duration: number | null
    roomId: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VideoCallMaxAggregateOutputType = {
    id: string | null
    callerId: string | null
    participantId: string | null
    status: string | null
    scheduledAt: Date | null
    startedAt: Date | null
    endedAt: Date | null
    cancelledAt: Date | null
    duration: number | null
    roomId: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VideoCallCountAggregateOutputType = {
    id: number
    callerId: number
    participantId: number
    status: number
    scheduledAt: number
    startedAt: number
    endedAt: number
    cancelledAt: number
    duration: number
    roomId: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VideoCallAvgAggregateInputType = {
    duration?: true
  }

  export type VideoCallSumAggregateInputType = {
    duration?: true
  }

  export type VideoCallMinAggregateInputType = {
    id?: true
    callerId?: true
    participantId?: true
    status?: true
    scheduledAt?: true
    startedAt?: true
    endedAt?: true
    cancelledAt?: true
    duration?: true
    roomId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VideoCallMaxAggregateInputType = {
    id?: true
    callerId?: true
    participantId?: true
    status?: true
    scheduledAt?: true
    startedAt?: true
    endedAt?: true
    cancelledAt?: true
    duration?: true
    roomId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VideoCallCountAggregateInputType = {
    id?: true
    callerId?: true
    participantId?: true
    status?: true
    scheduledAt?: true
    startedAt?: true
    endedAt?: true
    cancelledAt?: true
    duration?: true
    roomId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VideoCallAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoCall to aggregate.
     */
    where?: VideoCallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoCalls to fetch.
     */
    orderBy?: VideoCallOrderByWithRelationInput | VideoCallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideoCallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoCalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoCalls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VideoCalls
    **/
    _count?: true | VideoCallCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VideoCallAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VideoCallSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoCallMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoCallMaxAggregateInputType
  }

  export type GetVideoCallAggregateType<T extends VideoCallAggregateArgs> = {
        [P in keyof T & keyof AggregateVideoCall]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideoCall[P]>
      : GetScalarType<T[P], AggregateVideoCall[P]>
  }




  export type VideoCallGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoCallWhereInput
    orderBy?: VideoCallOrderByWithAggregationInput | VideoCallOrderByWithAggregationInput[]
    by: VideoCallScalarFieldEnum[] | VideoCallScalarFieldEnum
    having?: VideoCallScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoCallCountAggregateInputType | true
    _avg?: VideoCallAvgAggregateInputType
    _sum?: VideoCallSumAggregateInputType
    _min?: VideoCallMinAggregateInputType
    _max?: VideoCallMaxAggregateInputType
  }

  export type VideoCallGroupByOutputType = {
    id: string
    callerId: string
    participantId: string
    status: string
    scheduledAt: Date | null
    startedAt: Date | null
    endedAt: Date | null
    cancelledAt: Date | null
    duration: number | null
    roomId: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: VideoCallCountAggregateOutputType | null
    _avg: VideoCallAvgAggregateOutputType | null
    _sum: VideoCallSumAggregateOutputType | null
    _min: VideoCallMinAggregateOutputType | null
    _max: VideoCallMaxAggregateOutputType | null
  }

  type GetVideoCallGroupByPayload<T extends VideoCallGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideoCallGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoCallGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoCallGroupByOutputType[P]>
            : GetScalarType<T[P], VideoCallGroupByOutputType[P]>
        }
      >
    >


  export type VideoCallSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    callerId?: boolean
    participantId?: boolean
    status?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    endedAt?: boolean
    cancelledAt?: boolean
    duration?: boolean
    roomId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    caller?: boolean | UserDefaultArgs<ExtArgs>
    participant?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoCall"]>

  export type VideoCallSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    callerId?: boolean
    participantId?: boolean
    status?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    endedAt?: boolean
    cancelledAt?: boolean
    duration?: boolean
    roomId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    caller?: boolean | UserDefaultArgs<ExtArgs>
    participant?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoCall"]>

  export type VideoCallSelectScalar = {
    id?: boolean
    callerId?: boolean
    participantId?: boolean
    status?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    endedAt?: boolean
    cancelledAt?: boolean
    duration?: boolean
    roomId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VideoCallInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    caller?: boolean | UserDefaultArgs<ExtArgs>
    participant?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VideoCallIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    caller?: boolean | UserDefaultArgs<ExtArgs>
    participant?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VideoCallPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VideoCall"
    objects: {
      caller: Prisma.$UserPayload<ExtArgs>
      participant: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      callerId: string
      participantId: string
      status: string
      scheduledAt: Date | null
      startedAt: Date | null
      endedAt: Date | null
      cancelledAt: Date | null
      duration: number | null
      roomId: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["videoCall"]>
    composites: {}
  }

  type VideoCallGetPayload<S extends boolean | null | undefined | VideoCallDefaultArgs> = $Result.GetResult<Prisma.$VideoCallPayload, S>

  type VideoCallCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VideoCallFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VideoCallCountAggregateInputType | true
    }

  export interface VideoCallDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VideoCall'], meta: { name: 'VideoCall' } }
    /**
     * Find zero or one VideoCall that matches the filter.
     * @param {VideoCallFindUniqueArgs} args - Arguments to find a VideoCall
     * @example
     * // Get one VideoCall
     * const videoCall = await prisma.videoCall.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VideoCallFindUniqueArgs>(args: SelectSubset<T, VideoCallFindUniqueArgs<ExtArgs>>): Prisma__VideoCallClient<$Result.GetResult<Prisma.$VideoCallPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VideoCall that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VideoCallFindUniqueOrThrowArgs} args - Arguments to find a VideoCall
     * @example
     * // Get one VideoCall
     * const videoCall = await prisma.videoCall.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VideoCallFindUniqueOrThrowArgs>(args: SelectSubset<T, VideoCallFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VideoCallClient<$Result.GetResult<Prisma.$VideoCallPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VideoCall that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCallFindFirstArgs} args - Arguments to find a VideoCall
     * @example
     * // Get one VideoCall
     * const videoCall = await prisma.videoCall.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VideoCallFindFirstArgs>(args?: SelectSubset<T, VideoCallFindFirstArgs<ExtArgs>>): Prisma__VideoCallClient<$Result.GetResult<Prisma.$VideoCallPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VideoCall that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCallFindFirstOrThrowArgs} args - Arguments to find a VideoCall
     * @example
     * // Get one VideoCall
     * const videoCall = await prisma.videoCall.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VideoCallFindFirstOrThrowArgs>(args?: SelectSubset<T, VideoCallFindFirstOrThrowArgs<ExtArgs>>): Prisma__VideoCallClient<$Result.GetResult<Prisma.$VideoCallPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VideoCalls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCallFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VideoCalls
     * const videoCalls = await prisma.videoCall.findMany()
     * 
     * // Get first 10 VideoCalls
     * const videoCalls = await prisma.videoCall.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoCallWithIdOnly = await prisma.videoCall.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VideoCallFindManyArgs>(args?: SelectSubset<T, VideoCallFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoCallPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VideoCall.
     * @param {VideoCallCreateArgs} args - Arguments to create a VideoCall.
     * @example
     * // Create one VideoCall
     * const VideoCall = await prisma.videoCall.create({
     *   data: {
     *     // ... data to create a VideoCall
     *   }
     * })
     * 
     */
    create<T extends VideoCallCreateArgs>(args: SelectSubset<T, VideoCallCreateArgs<ExtArgs>>): Prisma__VideoCallClient<$Result.GetResult<Prisma.$VideoCallPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VideoCalls.
     * @param {VideoCallCreateManyArgs} args - Arguments to create many VideoCalls.
     * @example
     * // Create many VideoCalls
     * const videoCall = await prisma.videoCall.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VideoCallCreateManyArgs>(args?: SelectSubset<T, VideoCallCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VideoCalls and returns the data saved in the database.
     * @param {VideoCallCreateManyAndReturnArgs} args - Arguments to create many VideoCalls.
     * @example
     * // Create many VideoCalls
     * const videoCall = await prisma.videoCall.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VideoCalls and only return the `id`
     * const videoCallWithIdOnly = await prisma.videoCall.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VideoCallCreateManyAndReturnArgs>(args?: SelectSubset<T, VideoCallCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoCallPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VideoCall.
     * @param {VideoCallDeleteArgs} args - Arguments to delete one VideoCall.
     * @example
     * // Delete one VideoCall
     * const VideoCall = await prisma.videoCall.delete({
     *   where: {
     *     // ... filter to delete one VideoCall
     *   }
     * })
     * 
     */
    delete<T extends VideoCallDeleteArgs>(args: SelectSubset<T, VideoCallDeleteArgs<ExtArgs>>): Prisma__VideoCallClient<$Result.GetResult<Prisma.$VideoCallPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VideoCall.
     * @param {VideoCallUpdateArgs} args - Arguments to update one VideoCall.
     * @example
     * // Update one VideoCall
     * const videoCall = await prisma.videoCall.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VideoCallUpdateArgs>(args: SelectSubset<T, VideoCallUpdateArgs<ExtArgs>>): Prisma__VideoCallClient<$Result.GetResult<Prisma.$VideoCallPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VideoCalls.
     * @param {VideoCallDeleteManyArgs} args - Arguments to filter VideoCalls to delete.
     * @example
     * // Delete a few VideoCalls
     * const { count } = await prisma.videoCall.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VideoCallDeleteManyArgs>(args?: SelectSubset<T, VideoCallDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoCalls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCallUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VideoCalls
     * const videoCall = await prisma.videoCall.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VideoCallUpdateManyArgs>(args: SelectSubset<T, VideoCallUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VideoCall.
     * @param {VideoCallUpsertArgs} args - Arguments to update or create a VideoCall.
     * @example
     * // Update or create a VideoCall
     * const videoCall = await prisma.videoCall.upsert({
     *   create: {
     *     // ... data to create a VideoCall
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VideoCall we want to update
     *   }
     * })
     */
    upsert<T extends VideoCallUpsertArgs>(args: SelectSubset<T, VideoCallUpsertArgs<ExtArgs>>): Prisma__VideoCallClient<$Result.GetResult<Prisma.$VideoCallPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VideoCalls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCallCountArgs} args - Arguments to filter VideoCalls to count.
     * @example
     * // Count the number of VideoCalls
     * const count = await prisma.videoCall.count({
     *   where: {
     *     // ... the filter for the VideoCalls we want to count
     *   }
     * })
    **/
    count<T extends VideoCallCountArgs>(
      args?: Subset<T, VideoCallCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoCallCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VideoCall.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCallAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoCallAggregateArgs>(args: Subset<T, VideoCallAggregateArgs>): Prisma.PrismaPromise<GetVideoCallAggregateType<T>>

    /**
     * Group by VideoCall.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCallGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoCallGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoCallGroupByArgs['orderBy'] }
        : { orderBy?: VideoCallGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoCallGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoCallGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VideoCall model
   */
  readonly fields: VideoCallFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VideoCall.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VideoCallClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    caller<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    participant<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VideoCall model
   */ 
  interface VideoCallFieldRefs {
    readonly id: FieldRef<"VideoCall", 'String'>
    readonly callerId: FieldRef<"VideoCall", 'String'>
    readonly participantId: FieldRef<"VideoCall", 'String'>
    readonly status: FieldRef<"VideoCall", 'String'>
    readonly scheduledAt: FieldRef<"VideoCall", 'DateTime'>
    readonly startedAt: FieldRef<"VideoCall", 'DateTime'>
    readonly endedAt: FieldRef<"VideoCall", 'DateTime'>
    readonly cancelledAt: FieldRef<"VideoCall", 'DateTime'>
    readonly duration: FieldRef<"VideoCall", 'Int'>
    readonly roomId: FieldRef<"VideoCall", 'String'>
    readonly notes: FieldRef<"VideoCall", 'String'>
    readonly createdAt: FieldRef<"VideoCall", 'DateTime'>
    readonly updatedAt: FieldRef<"VideoCall", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VideoCall findUnique
   */
  export type VideoCallFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCall
     */
    select?: VideoCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoCallInclude<ExtArgs> | null
    /**
     * Filter, which VideoCall to fetch.
     */
    where: VideoCallWhereUniqueInput
  }

  /**
   * VideoCall findUniqueOrThrow
   */
  export type VideoCallFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCall
     */
    select?: VideoCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoCallInclude<ExtArgs> | null
    /**
     * Filter, which VideoCall to fetch.
     */
    where: VideoCallWhereUniqueInput
  }

  /**
   * VideoCall findFirst
   */
  export type VideoCallFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCall
     */
    select?: VideoCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoCallInclude<ExtArgs> | null
    /**
     * Filter, which VideoCall to fetch.
     */
    where?: VideoCallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoCalls to fetch.
     */
    orderBy?: VideoCallOrderByWithRelationInput | VideoCallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoCalls.
     */
    cursor?: VideoCallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoCalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoCalls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoCalls.
     */
    distinct?: VideoCallScalarFieldEnum | VideoCallScalarFieldEnum[]
  }

  /**
   * VideoCall findFirstOrThrow
   */
  export type VideoCallFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCall
     */
    select?: VideoCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoCallInclude<ExtArgs> | null
    /**
     * Filter, which VideoCall to fetch.
     */
    where?: VideoCallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoCalls to fetch.
     */
    orderBy?: VideoCallOrderByWithRelationInput | VideoCallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoCalls.
     */
    cursor?: VideoCallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoCalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoCalls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoCalls.
     */
    distinct?: VideoCallScalarFieldEnum | VideoCallScalarFieldEnum[]
  }

  /**
   * VideoCall findMany
   */
  export type VideoCallFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCall
     */
    select?: VideoCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoCallInclude<ExtArgs> | null
    /**
     * Filter, which VideoCalls to fetch.
     */
    where?: VideoCallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoCalls to fetch.
     */
    orderBy?: VideoCallOrderByWithRelationInput | VideoCallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VideoCalls.
     */
    cursor?: VideoCallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoCalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoCalls.
     */
    skip?: number
    distinct?: VideoCallScalarFieldEnum | VideoCallScalarFieldEnum[]
  }

  /**
   * VideoCall create
   */
  export type VideoCallCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCall
     */
    select?: VideoCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoCallInclude<ExtArgs> | null
    /**
     * The data needed to create a VideoCall.
     */
    data: XOR<VideoCallCreateInput, VideoCallUncheckedCreateInput>
  }

  /**
   * VideoCall createMany
   */
  export type VideoCallCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VideoCalls.
     */
    data: VideoCallCreateManyInput | VideoCallCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VideoCall createManyAndReturn
   */
  export type VideoCallCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCall
     */
    select?: VideoCallSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VideoCalls.
     */
    data: VideoCallCreateManyInput | VideoCallCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoCallIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VideoCall update
   */
  export type VideoCallUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCall
     */
    select?: VideoCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoCallInclude<ExtArgs> | null
    /**
     * The data needed to update a VideoCall.
     */
    data: XOR<VideoCallUpdateInput, VideoCallUncheckedUpdateInput>
    /**
     * Choose, which VideoCall to update.
     */
    where: VideoCallWhereUniqueInput
  }

  /**
   * VideoCall updateMany
   */
  export type VideoCallUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VideoCalls.
     */
    data: XOR<VideoCallUpdateManyMutationInput, VideoCallUncheckedUpdateManyInput>
    /**
     * Filter which VideoCalls to update
     */
    where?: VideoCallWhereInput
  }

  /**
   * VideoCall upsert
   */
  export type VideoCallUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCall
     */
    select?: VideoCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoCallInclude<ExtArgs> | null
    /**
     * The filter to search for the VideoCall to update in case it exists.
     */
    where: VideoCallWhereUniqueInput
    /**
     * In case the VideoCall found by the `where` argument doesn't exist, create a new VideoCall with this data.
     */
    create: XOR<VideoCallCreateInput, VideoCallUncheckedCreateInput>
    /**
     * In case the VideoCall was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideoCallUpdateInput, VideoCallUncheckedUpdateInput>
  }

  /**
   * VideoCall delete
   */
  export type VideoCallDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCall
     */
    select?: VideoCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoCallInclude<ExtArgs> | null
    /**
     * Filter which VideoCall to delete.
     */
    where: VideoCallWhereUniqueInput
  }

  /**
   * VideoCall deleteMany
   */
  export type VideoCallDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoCalls to delete
     */
    where?: VideoCallWhereInput
  }

  /**
   * VideoCall without action
   */
  export type VideoCallDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCall
     */
    select?: VideoCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoCallInclude<ExtArgs> | null
  }


  /**
   * Model ProfileComparison
   */

  export type AggregateProfileComparison = {
    _count: ProfileComparisonCountAggregateOutputType | null
    _min: ProfileComparisonMinAggregateOutputType | null
    _max: ProfileComparisonMaxAggregateOutputType | null
  }

  export type ProfileComparisonMinAggregateOutputType = {
    id: string | null
    userId: string | null
    profileId: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type ProfileComparisonMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    profileId: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type ProfileComparisonCountAggregateOutputType = {
    id: number
    userId: number
    profileId: number
    comparisonData: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type ProfileComparisonMinAggregateInputType = {
    id?: true
    userId?: true
    profileId?: true
    createdAt?: true
    expiresAt?: true
  }

  export type ProfileComparisonMaxAggregateInputType = {
    id?: true
    userId?: true
    profileId?: true
    createdAt?: true
    expiresAt?: true
  }

  export type ProfileComparisonCountAggregateInputType = {
    id?: true
    userId?: true
    profileId?: true
    comparisonData?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type ProfileComparisonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileComparison to aggregate.
     */
    where?: ProfileComparisonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileComparisons to fetch.
     */
    orderBy?: ProfileComparisonOrderByWithRelationInput | ProfileComparisonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileComparisonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileComparisons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileComparisons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProfileComparisons
    **/
    _count?: true | ProfileComparisonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileComparisonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileComparisonMaxAggregateInputType
  }

  export type GetProfileComparisonAggregateType<T extends ProfileComparisonAggregateArgs> = {
        [P in keyof T & keyof AggregateProfileComparison]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfileComparison[P]>
      : GetScalarType<T[P], AggregateProfileComparison[P]>
  }




  export type ProfileComparisonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileComparisonWhereInput
    orderBy?: ProfileComparisonOrderByWithAggregationInput | ProfileComparisonOrderByWithAggregationInput[]
    by: ProfileComparisonScalarFieldEnum[] | ProfileComparisonScalarFieldEnum
    having?: ProfileComparisonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileComparisonCountAggregateInputType | true
    _min?: ProfileComparisonMinAggregateInputType
    _max?: ProfileComparisonMaxAggregateInputType
  }

  export type ProfileComparisonGroupByOutputType = {
    id: string
    userId: string
    profileId: string
    comparisonData: JsonValue | null
    createdAt: Date
    expiresAt: Date | null
    _count: ProfileComparisonCountAggregateOutputType | null
    _min: ProfileComparisonMinAggregateOutputType | null
    _max: ProfileComparisonMaxAggregateOutputType | null
  }

  type GetProfileComparisonGroupByPayload<T extends ProfileComparisonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileComparisonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileComparisonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileComparisonGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileComparisonGroupByOutputType[P]>
        }
      >
    >


  export type ProfileComparisonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    profileId?: boolean
    comparisonData?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileComparison"]>

  export type ProfileComparisonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    profileId?: boolean
    comparisonData?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileComparison"]>

  export type ProfileComparisonSelectScalar = {
    id?: boolean
    userId?: boolean
    profileId?: boolean
    comparisonData?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type ProfileComparisonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type ProfileComparisonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $ProfileComparisonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProfileComparison"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      profileId: string
      comparisonData: Prisma.JsonValue | null
      createdAt: Date
      expiresAt: Date | null
    }, ExtArgs["result"]["profileComparison"]>
    composites: {}
  }

  type ProfileComparisonGetPayload<S extends boolean | null | undefined | ProfileComparisonDefaultArgs> = $Result.GetResult<Prisma.$ProfileComparisonPayload, S>

  type ProfileComparisonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfileComparisonFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfileComparisonCountAggregateInputType | true
    }

  export interface ProfileComparisonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProfileComparison'], meta: { name: 'ProfileComparison' } }
    /**
     * Find zero or one ProfileComparison that matches the filter.
     * @param {ProfileComparisonFindUniqueArgs} args - Arguments to find a ProfileComparison
     * @example
     * // Get one ProfileComparison
     * const profileComparison = await prisma.profileComparison.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileComparisonFindUniqueArgs>(args: SelectSubset<T, ProfileComparisonFindUniqueArgs<ExtArgs>>): Prisma__ProfileComparisonClient<$Result.GetResult<Prisma.$ProfileComparisonPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProfileComparison that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProfileComparisonFindUniqueOrThrowArgs} args - Arguments to find a ProfileComparison
     * @example
     * // Get one ProfileComparison
     * const profileComparison = await prisma.profileComparison.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileComparisonFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileComparisonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileComparisonClient<$Result.GetResult<Prisma.$ProfileComparisonPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProfileComparison that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileComparisonFindFirstArgs} args - Arguments to find a ProfileComparison
     * @example
     * // Get one ProfileComparison
     * const profileComparison = await prisma.profileComparison.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileComparisonFindFirstArgs>(args?: SelectSubset<T, ProfileComparisonFindFirstArgs<ExtArgs>>): Prisma__ProfileComparisonClient<$Result.GetResult<Prisma.$ProfileComparisonPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProfileComparison that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileComparisonFindFirstOrThrowArgs} args - Arguments to find a ProfileComparison
     * @example
     * // Get one ProfileComparison
     * const profileComparison = await prisma.profileComparison.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileComparisonFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileComparisonFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileComparisonClient<$Result.GetResult<Prisma.$ProfileComparisonPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProfileComparisons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileComparisonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProfileComparisons
     * const profileComparisons = await prisma.profileComparison.findMany()
     * 
     * // Get first 10 ProfileComparisons
     * const profileComparisons = await prisma.profileComparison.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileComparisonWithIdOnly = await prisma.profileComparison.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileComparisonFindManyArgs>(args?: SelectSubset<T, ProfileComparisonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileComparisonPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProfileComparison.
     * @param {ProfileComparisonCreateArgs} args - Arguments to create a ProfileComparison.
     * @example
     * // Create one ProfileComparison
     * const ProfileComparison = await prisma.profileComparison.create({
     *   data: {
     *     // ... data to create a ProfileComparison
     *   }
     * })
     * 
     */
    create<T extends ProfileComparisonCreateArgs>(args: SelectSubset<T, ProfileComparisonCreateArgs<ExtArgs>>): Prisma__ProfileComparisonClient<$Result.GetResult<Prisma.$ProfileComparisonPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProfileComparisons.
     * @param {ProfileComparisonCreateManyArgs} args - Arguments to create many ProfileComparisons.
     * @example
     * // Create many ProfileComparisons
     * const profileComparison = await prisma.profileComparison.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileComparisonCreateManyArgs>(args?: SelectSubset<T, ProfileComparisonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProfileComparisons and returns the data saved in the database.
     * @param {ProfileComparisonCreateManyAndReturnArgs} args - Arguments to create many ProfileComparisons.
     * @example
     * // Create many ProfileComparisons
     * const profileComparison = await prisma.profileComparison.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProfileComparisons and only return the `id`
     * const profileComparisonWithIdOnly = await prisma.profileComparison.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileComparisonCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileComparisonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileComparisonPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProfileComparison.
     * @param {ProfileComparisonDeleteArgs} args - Arguments to delete one ProfileComparison.
     * @example
     * // Delete one ProfileComparison
     * const ProfileComparison = await prisma.profileComparison.delete({
     *   where: {
     *     // ... filter to delete one ProfileComparison
     *   }
     * })
     * 
     */
    delete<T extends ProfileComparisonDeleteArgs>(args: SelectSubset<T, ProfileComparisonDeleteArgs<ExtArgs>>): Prisma__ProfileComparisonClient<$Result.GetResult<Prisma.$ProfileComparisonPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProfileComparison.
     * @param {ProfileComparisonUpdateArgs} args - Arguments to update one ProfileComparison.
     * @example
     * // Update one ProfileComparison
     * const profileComparison = await prisma.profileComparison.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileComparisonUpdateArgs>(args: SelectSubset<T, ProfileComparisonUpdateArgs<ExtArgs>>): Prisma__ProfileComparisonClient<$Result.GetResult<Prisma.$ProfileComparisonPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProfileComparisons.
     * @param {ProfileComparisonDeleteManyArgs} args - Arguments to filter ProfileComparisons to delete.
     * @example
     * // Delete a few ProfileComparisons
     * const { count } = await prisma.profileComparison.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileComparisonDeleteManyArgs>(args?: SelectSubset<T, ProfileComparisonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfileComparisons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileComparisonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProfileComparisons
     * const profileComparison = await prisma.profileComparison.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileComparisonUpdateManyArgs>(args: SelectSubset<T, ProfileComparisonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProfileComparison.
     * @param {ProfileComparisonUpsertArgs} args - Arguments to update or create a ProfileComparison.
     * @example
     * // Update or create a ProfileComparison
     * const profileComparison = await prisma.profileComparison.upsert({
     *   create: {
     *     // ... data to create a ProfileComparison
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProfileComparison we want to update
     *   }
     * })
     */
    upsert<T extends ProfileComparisonUpsertArgs>(args: SelectSubset<T, ProfileComparisonUpsertArgs<ExtArgs>>): Prisma__ProfileComparisonClient<$Result.GetResult<Prisma.$ProfileComparisonPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProfileComparisons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileComparisonCountArgs} args - Arguments to filter ProfileComparisons to count.
     * @example
     * // Count the number of ProfileComparisons
     * const count = await prisma.profileComparison.count({
     *   where: {
     *     // ... the filter for the ProfileComparisons we want to count
     *   }
     * })
    **/
    count<T extends ProfileComparisonCountArgs>(
      args?: Subset<T, ProfileComparisonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileComparisonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProfileComparison.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileComparisonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileComparisonAggregateArgs>(args: Subset<T, ProfileComparisonAggregateArgs>): Prisma.PrismaPromise<GetProfileComparisonAggregateType<T>>

    /**
     * Group by ProfileComparison.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileComparisonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileComparisonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileComparisonGroupByArgs['orderBy'] }
        : { orderBy?: ProfileComparisonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileComparisonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileComparisonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProfileComparison model
   */
  readonly fields: ProfileComparisonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProfileComparison.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileComparisonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProfileComparison model
   */ 
  interface ProfileComparisonFieldRefs {
    readonly id: FieldRef<"ProfileComparison", 'String'>
    readonly userId: FieldRef<"ProfileComparison", 'String'>
    readonly profileId: FieldRef<"ProfileComparison", 'String'>
    readonly comparisonData: FieldRef<"ProfileComparison", 'Json'>
    readonly createdAt: FieldRef<"ProfileComparison", 'DateTime'>
    readonly expiresAt: FieldRef<"ProfileComparison", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProfileComparison findUnique
   */
  export type ProfileComparisonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileComparison
     */
    select?: ProfileComparisonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileComparisonInclude<ExtArgs> | null
    /**
     * Filter, which ProfileComparison to fetch.
     */
    where: ProfileComparisonWhereUniqueInput
  }

  /**
   * ProfileComparison findUniqueOrThrow
   */
  export type ProfileComparisonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileComparison
     */
    select?: ProfileComparisonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileComparisonInclude<ExtArgs> | null
    /**
     * Filter, which ProfileComparison to fetch.
     */
    where: ProfileComparisonWhereUniqueInput
  }

  /**
   * ProfileComparison findFirst
   */
  export type ProfileComparisonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileComparison
     */
    select?: ProfileComparisonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileComparisonInclude<ExtArgs> | null
    /**
     * Filter, which ProfileComparison to fetch.
     */
    where?: ProfileComparisonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileComparisons to fetch.
     */
    orderBy?: ProfileComparisonOrderByWithRelationInput | ProfileComparisonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileComparisons.
     */
    cursor?: ProfileComparisonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileComparisons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileComparisons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileComparisons.
     */
    distinct?: ProfileComparisonScalarFieldEnum | ProfileComparisonScalarFieldEnum[]
  }

  /**
   * ProfileComparison findFirstOrThrow
   */
  export type ProfileComparisonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileComparison
     */
    select?: ProfileComparisonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileComparisonInclude<ExtArgs> | null
    /**
     * Filter, which ProfileComparison to fetch.
     */
    where?: ProfileComparisonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileComparisons to fetch.
     */
    orderBy?: ProfileComparisonOrderByWithRelationInput | ProfileComparisonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileComparisons.
     */
    cursor?: ProfileComparisonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileComparisons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileComparisons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileComparisons.
     */
    distinct?: ProfileComparisonScalarFieldEnum | ProfileComparisonScalarFieldEnum[]
  }

  /**
   * ProfileComparison findMany
   */
  export type ProfileComparisonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileComparison
     */
    select?: ProfileComparisonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileComparisonInclude<ExtArgs> | null
    /**
     * Filter, which ProfileComparisons to fetch.
     */
    where?: ProfileComparisonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileComparisons to fetch.
     */
    orderBy?: ProfileComparisonOrderByWithRelationInput | ProfileComparisonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProfileComparisons.
     */
    cursor?: ProfileComparisonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileComparisons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileComparisons.
     */
    skip?: number
    distinct?: ProfileComparisonScalarFieldEnum | ProfileComparisonScalarFieldEnum[]
  }

  /**
   * ProfileComparison create
   */
  export type ProfileComparisonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileComparison
     */
    select?: ProfileComparisonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileComparisonInclude<ExtArgs> | null
    /**
     * The data needed to create a ProfileComparison.
     */
    data: XOR<ProfileComparisonCreateInput, ProfileComparisonUncheckedCreateInput>
  }

  /**
   * ProfileComparison createMany
   */
  export type ProfileComparisonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProfileComparisons.
     */
    data: ProfileComparisonCreateManyInput | ProfileComparisonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProfileComparison createManyAndReturn
   */
  export type ProfileComparisonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileComparison
     */
    select?: ProfileComparisonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProfileComparisons.
     */
    data: ProfileComparisonCreateManyInput | ProfileComparisonCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileComparisonIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProfileComparison update
   */
  export type ProfileComparisonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileComparison
     */
    select?: ProfileComparisonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileComparisonInclude<ExtArgs> | null
    /**
     * The data needed to update a ProfileComparison.
     */
    data: XOR<ProfileComparisonUpdateInput, ProfileComparisonUncheckedUpdateInput>
    /**
     * Choose, which ProfileComparison to update.
     */
    where: ProfileComparisonWhereUniqueInput
  }

  /**
   * ProfileComparison updateMany
   */
  export type ProfileComparisonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProfileComparisons.
     */
    data: XOR<ProfileComparisonUpdateManyMutationInput, ProfileComparisonUncheckedUpdateManyInput>
    /**
     * Filter which ProfileComparisons to update
     */
    where?: ProfileComparisonWhereInput
  }

  /**
   * ProfileComparison upsert
   */
  export type ProfileComparisonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileComparison
     */
    select?: ProfileComparisonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileComparisonInclude<ExtArgs> | null
    /**
     * The filter to search for the ProfileComparison to update in case it exists.
     */
    where: ProfileComparisonWhereUniqueInput
    /**
     * In case the ProfileComparison found by the `where` argument doesn't exist, create a new ProfileComparison with this data.
     */
    create: XOR<ProfileComparisonCreateInput, ProfileComparisonUncheckedCreateInput>
    /**
     * In case the ProfileComparison was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileComparisonUpdateInput, ProfileComparisonUncheckedUpdateInput>
  }

  /**
   * ProfileComparison delete
   */
  export type ProfileComparisonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileComparison
     */
    select?: ProfileComparisonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileComparisonInclude<ExtArgs> | null
    /**
     * Filter which ProfileComparison to delete.
     */
    where: ProfileComparisonWhereUniqueInput
  }

  /**
   * ProfileComparison deleteMany
   */
  export type ProfileComparisonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileComparisons to delete
     */
    where?: ProfileComparisonWhereInput
  }

  /**
   * ProfileComparison without action
   */
  export type ProfileComparisonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileComparison
     */
    select?: ProfileComparisonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileComparisonInclude<ExtArgs> | null
  }


  /**
   * Model ForumPost
   */

  export type AggregateForumPost = {
    _count: ForumPostCountAggregateOutputType | null
    _avg: ForumPostAvgAggregateOutputType | null
    _sum: ForumPostSumAggregateOutputType | null
    _min: ForumPostMinAggregateOutputType | null
    _max: ForumPostMaxAggregateOutputType | null
  }

  export type ForumPostAvgAggregateOutputType = {
    likes: number | null
    views: number | null
  }

  export type ForumPostSumAggregateOutputType = {
    likes: number | null
    views: number | null
  }

  export type ForumPostMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    content: string | null
    category: string | null
    likes: number | null
    views: number | null
    isPinned: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ForumPostMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    content: string | null
    category: string | null
    likes: number | null
    views: number | null
    isPinned: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ForumPostCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    content: number
    category: number
    tags: number
    likes: number
    views: number
    isPinned: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ForumPostAvgAggregateInputType = {
    likes?: true
    views?: true
  }

  export type ForumPostSumAggregateInputType = {
    likes?: true
    views?: true
  }

  export type ForumPostMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    category?: true
    likes?: true
    views?: true
    isPinned?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ForumPostMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    category?: true
    likes?: true
    views?: true
    isPinned?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ForumPostCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    category?: true
    tags?: true
    likes?: true
    views?: true
    isPinned?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ForumPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumPost to aggregate.
     */
    where?: ForumPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumPosts to fetch.
     */
    orderBy?: ForumPostOrderByWithRelationInput | ForumPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ForumPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ForumPosts
    **/
    _count?: true | ForumPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ForumPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ForumPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ForumPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ForumPostMaxAggregateInputType
  }

  export type GetForumPostAggregateType<T extends ForumPostAggregateArgs> = {
        [P in keyof T & keyof AggregateForumPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForumPost[P]>
      : GetScalarType<T[P], AggregateForumPost[P]>
  }




  export type ForumPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumPostWhereInput
    orderBy?: ForumPostOrderByWithAggregationInput | ForumPostOrderByWithAggregationInput[]
    by: ForumPostScalarFieldEnum[] | ForumPostScalarFieldEnum
    having?: ForumPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ForumPostCountAggregateInputType | true
    _avg?: ForumPostAvgAggregateInputType
    _sum?: ForumPostSumAggregateInputType
    _min?: ForumPostMinAggregateInputType
    _max?: ForumPostMaxAggregateInputType
  }

  export type ForumPostGroupByOutputType = {
    id: string
    userId: string
    title: string
    content: string
    category: string | null
    tags: string[]
    likes: number
    views: number
    isPinned: boolean
    createdAt: Date
    updatedAt: Date
    _count: ForumPostCountAggregateOutputType | null
    _avg: ForumPostAvgAggregateOutputType | null
    _sum: ForumPostSumAggregateOutputType | null
    _min: ForumPostMinAggregateOutputType | null
    _max: ForumPostMaxAggregateOutputType | null
  }

  type GetForumPostGroupByPayload<T extends ForumPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ForumPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ForumPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ForumPostGroupByOutputType[P]>
            : GetScalarType<T[P], ForumPostGroupByOutputType[P]>
        }
      >
    >


  export type ForumPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    category?: boolean
    tags?: boolean
    likes?: boolean
    views?: boolean
    isPinned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    comments?: boolean | ForumPost$commentsArgs<ExtArgs>
    _count?: boolean | ForumPostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumPost"]>

  export type ForumPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    category?: boolean
    tags?: boolean
    likes?: boolean
    views?: boolean
    isPinned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumPost"]>

  export type ForumPostSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    category?: boolean
    tags?: boolean
    likes?: boolean
    views?: boolean
    isPinned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ForumPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    comments?: boolean | ForumPost$commentsArgs<ExtArgs>
    _count?: boolean | ForumPostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ForumPostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ForumPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ForumPost"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      comments: Prisma.$ForumCommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      content: string
      category: string | null
      tags: string[]
      likes: number
      views: number
      isPinned: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["forumPost"]>
    composites: {}
  }

  type ForumPostGetPayload<S extends boolean | null | undefined | ForumPostDefaultArgs> = $Result.GetResult<Prisma.$ForumPostPayload, S>

  type ForumPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ForumPostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ForumPostCountAggregateInputType | true
    }

  export interface ForumPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ForumPost'], meta: { name: 'ForumPost' } }
    /**
     * Find zero or one ForumPost that matches the filter.
     * @param {ForumPostFindUniqueArgs} args - Arguments to find a ForumPost
     * @example
     * // Get one ForumPost
     * const forumPost = await prisma.forumPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ForumPostFindUniqueArgs>(args: SelectSubset<T, ForumPostFindUniqueArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ForumPost that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ForumPostFindUniqueOrThrowArgs} args - Arguments to find a ForumPost
     * @example
     * // Get one ForumPost
     * const forumPost = await prisma.forumPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ForumPostFindUniqueOrThrowArgs>(args: SelectSubset<T, ForumPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ForumPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostFindFirstArgs} args - Arguments to find a ForumPost
     * @example
     * // Get one ForumPost
     * const forumPost = await prisma.forumPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ForumPostFindFirstArgs>(args?: SelectSubset<T, ForumPostFindFirstArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ForumPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostFindFirstOrThrowArgs} args - Arguments to find a ForumPost
     * @example
     * // Get one ForumPost
     * const forumPost = await prisma.forumPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ForumPostFindFirstOrThrowArgs>(args?: SelectSubset<T, ForumPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ForumPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ForumPosts
     * const forumPosts = await prisma.forumPost.findMany()
     * 
     * // Get first 10 ForumPosts
     * const forumPosts = await prisma.forumPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const forumPostWithIdOnly = await prisma.forumPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ForumPostFindManyArgs>(args?: SelectSubset<T, ForumPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ForumPost.
     * @param {ForumPostCreateArgs} args - Arguments to create a ForumPost.
     * @example
     * // Create one ForumPost
     * const ForumPost = await prisma.forumPost.create({
     *   data: {
     *     // ... data to create a ForumPost
     *   }
     * })
     * 
     */
    create<T extends ForumPostCreateArgs>(args: SelectSubset<T, ForumPostCreateArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ForumPosts.
     * @param {ForumPostCreateManyArgs} args - Arguments to create many ForumPosts.
     * @example
     * // Create many ForumPosts
     * const forumPost = await prisma.forumPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ForumPostCreateManyArgs>(args?: SelectSubset<T, ForumPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ForumPosts and returns the data saved in the database.
     * @param {ForumPostCreateManyAndReturnArgs} args - Arguments to create many ForumPosts.
     * @example
     * // Create many ForumPosts
     * const forumPost = await prisma.forumPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ForumPosts and only return the `id`
     * const forumPostWithIdOnly = await prisma.forumPost.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ForumPostCreateManyAndReturnArgs>(args?: SelectSubset<T, ForumPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ForumPost.
     * @param {ForumPostDeleteArgs} args - Arguments to delete one ForumPost.
     * @example
     * // Delete one ForumPost
     * const ForumPost = await prisma.forumPost.delete({
     *   where: {
     *     // ... filter to delete one ForumPost
     *   }
     * })
     * 
     */
    delete<T extends ForumPostDeleteArgs>(args: SelectSubset<T, ForumPostDeleteArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ForumPost.
     * @param {ForumPostUpdateArgs} args - Arguments to update one ForumPost.
     * @example
     * // Update one ForumPost
     * const forumPost = await prisma.forumPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ForumPostUpdateArgs>(args: SelectSubset<T, ForumPostUpdateArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ForumPosts.
     * @param {ForumPostDeleteManyArgs} args - Arguments to filter ForumPosts to delete.
     * @example
     * // Delete a few ForumPosts
     * const { count } = await prisma.forumPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ForumPostDeleteManyArgs>(args?: SelectSubset<T, ForumPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForumPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ForumPosts
     * const forumPost = await prisma.forumPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ForumPostUpdateManyArgs>(args: SelectSubset<T, ForumPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ForumPost.
     * @param {ForumPostUpsertArgs} args - Arguments to update or create a ForumPost.
     * @example
     * // Update or create a ForumPost
     * const forumPost = await prisma.forumPost.upsert({
     *   create: {
     *     // ... data to create a ForumPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ForumPost we want to update
     *   }
     * })
     */
    upsert<T extends ForumPostUpsertArgs>(args: SelectSubset<T, ForumPostUpsertArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ForumPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostCountArgs} args - Arguments to filter ForumPosts to count.
     * @example
     * // Count the number of ForumPosts
     * const count = await prisma.forumPost.count({
     *   where: {
     *     // ... the filter for the ForumPosts we want to count
     *   }
     * })
    **/
    count<T extends ForumPostCountArgs>(
      args?: Subset<T, ForumPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ForumPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ForumPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ForumPostAggregateArgs>(args: Subset<T, ForumPostAggregateArgs>): Prisma.PrismaPromise<GetForumPostAggregateType<T>>

    /**
     * Group by ForumPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ForumPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ForumPostGroupByArgs['orderBy'] }
        : { orderBy?: ForumPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ForumPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetForumPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ForumPost model
   */
  readonly fields: ForumPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ForumPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ForumPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    comments<T extends ForumPost$commentsArgs<ExtArgs> = {}>(args?: Subset<T, ForumPost$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumCommentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ForumPost model
   */ 
  interface ForumPostFieldRefs {
    readonly id: FieldRef<"ForumPost", 'String'>
    readonly userId: FieldRef<"ForumPost", 'String'>
    readonly title: FieldRef<"ForumPost", 'String'>
    readonly content: FieldRef<"ForumPost", 'String'>
    readonly category: FieldRef<"ForumPost", 'String'>
    readonly tags: FieldRef<"ForumPost", 'String[]'>
    readonly likes: FieldRef<"ForumPost", 'Int'>
    readonly views: FieldRef<"ForumPost", 'Int'>
    readonly isPinned: FieldRef<"ForumPost", 'Boolean'>
    readonly createdAt: FieldRef<"ForumPost", 'DateTime'>
    readonly updatedAt: FieldRef<"ForumPost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ForumPost findUnique
   */
  export type ForumPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * Filter, which ForumPost to fetch.
     */
    where: ForumPostWhereUniqueInput
  }

  /**
   * ForumPost findUniqueOrThrow
   */
  export type ForumPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * Filter, which ForumPost to fetch.
     */
    where: ForumPostWhereUniqueInput
  }

  /**
   * ForumPost findFirst
   */
  export type ForumPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * Filter, which ForumPost to fetch.
     */
    where?: ForumPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumPosts to fetch.
     */
    orderBy?: ForumPostOrderByWithRelationInput | ForumPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumPosts.
     */
    cursor?: ForumPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumPosts.
     */
    distinct?: ForumPostScalarFieldEnum | ForumPostScalarFieldEnum[]
  }

  /**
   * ForumPost findFirstOrThrow
   */
  export type ForumPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * Filter, which ForumPost to fetch.
     */
    where?: ForumPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumPosts to fetch.
     */
    orderBy?: ForumPostOrderByWithRelationInput | ForumPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumPosts.
     */
    cursor?: ForumPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumPosts.
     */
    distinct?: ForumPostScalarFieldEnum | ForumPostScalarFieldEnum[]
  }

  /**
   * ForumPost findMany
   */
  export type ForumPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * Filter, which ForumPosts to fetch.
     */
    where?: ForumPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumPosts to fetch.
     */
    orderBy?: ForumPostOrderByWithRelationInput | ForumPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ForumPosts.
     */
    cursor?: ForumPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumPosts.
     */
    skip?: number
    distinct?: ForumPostScalarFieldEnum | ForumPostScalarFieldEnum[]
  }

  /**
   * ForumPost create
   */
  export type ForumPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * The data needed to create a ForumPost.
     */
    data: XOR<ForumPostCreateInput, ForumPostUncheckedCreateInput>
  }

  /**
   * ForumPost createMany
   */
  export type ForumPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ForumPosts.
     */
    data: ForumPostCreateManyInput | ForumPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ForumPost createManyAndReturn
   */
  export type ForumPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ForumPosts.
     */
    data: ForumPostCreateManyInput | ForumPostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ForumPost update
   */
  export type ForumPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * The data needed to update a ForumPost.
     */
    data: XOR<ForumPostUpdateInput, ForumPostUncheckedUpdateInput>
    /**
     * Choose, which ForumPost to update.
     */
    where: ForumPostWhereUniqueInput
  }

  /**
   * ForumPost updateMany
   */
  export type ForumPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ForumPosts.
     */
    data: XOR<ForumPostUpdateManyMutationInput, ForumPostUncheckedUpdateManyInput>
    /**
     * Filter which ForumPosts to update
     */
    where?: ForumPostWhereInput
  }

  /**
   * ForumPost upsert
   */
  export type ForumPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * The filter to search for the ForumPost to update in case it exists.
     */
    where: ForumPostWhereUniqueInput
    /**
     * In case the ForumPost found by the `where` argument doesn't exist, create a new ForumPost with this data.
     */
    create: XOR<ForumPostCreateInput, ForumPostUncheckedCreateInput>
    /**
     * In case the ForumPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ForumPostUpdateInput, ForumPostUncheckedUpdateInput>
  }

  /**
   * ForumPost delete
   */
  export type ForumPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * Filter which ForumPost to delete.
     */
    where: ForumPostWhereUniqueInput
  }

  /**
   * ForumPost deleteMany
   */
  export type ForumPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumPosts to delete
     */
    where?: ForumPostWhereInput
  }

  /**
   * ForumPost.comments
   */
  export type ForumPost$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentInclude<ExtArgs> | null
    where?: ForumCommentWhereInput
    orderBy?: ForumCommentOrderByWithRelationInput | ForumCommentOrderByWithRelationInput[]
    cursor?: ForumCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForumCommentScalarFieldEnum | ForumCommentScalarFieldEnum[]
  }

  /**
   * ForumPost without action
   */
  export type ForumPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
  }


  /**
   * Model ForumComment
   */

  export type AggregateForumComment = {
    _count: ForumCommentCountAggregateOutputType | null
    _min: ForumCommentMinAggregateOutputType | null
    _max: ForumCommentMaxAggregateOutputType | null
  }

  export type ForumCommentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    postId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ForumCommentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    postId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ForumCommentCountAggregateOutputType = {
    id: number
    userId: number
    postId: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ForumCommentMinAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ForumCommentMaxAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ForumCommentCountAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ForumCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumComment to aggregate.
     */
    where?: ForumCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumComments to fetch.
     */
    orderBy?: ForumCommentOrderByWithRelationInput | ForumCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ForumCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ForumComments
    **/
    _count?: true | ForumCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ForumCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ForumCommentMaxAggregateInputType
  }

  export type GetForumCommentAggregateType<T extends ForumCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateForumComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForumComment[P]>
      : GetScalarType<T[P], AggregateForumComment[P]>
  }




  export type ForumCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumCommentWhereInput
    orderBy?: ForumCommentOrderByWithAggregationInput | ForumCommentOrderByWithAggregationInput[]
    by: ForumCommentScalarFieldEnum[] | ForumCommentScalarFieldEnum
    having?: ForumCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ForumCommentCountAggregateInputType | true
    _min?: ForumCommentMinAggregateInputType
    _max?: ForumCommentMaxAggregateInputType
  }

  export type ForumCommentGroupByOutputType = {
    id: string
    userId: string
    postId: string
    content: string
    createdAt: Date
    updatedAt: Date
    _count: ForumCommentCountAggregateOutputType | null
    _min: ForumCommentMinAggregateOutputType | null
    _max: ForumCommentMaxAggregateOutputType | null
  }

  type GetForumCommentGroupByPayload<T extends ForumCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ForumCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ForumCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ForumCommentGroupByOutputType[P]>
            : GetScalarType<T[P], ForumCommentGroupByOutputType[P]>
        }
      >
    >


  export type ForumCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    postId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    post?: boolean | ForumPostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumComment"]>

  export type ForumCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    postId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    post?: boolean | ForumPostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumComment"]>

  export type ForumCommentSelectScalar = {
    id?: boolean
    userId?: boolean
    postId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ForumCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    post?: boolean | ForumPostDefaultArgs<ExtArgs>
  }
  export type ForumCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    post?: boolean | ForumPostDefaultArgs<ExtArgs>
  }

  export type $ForumCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ForumComment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      post: Prisma.$ForumPostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      postId: string
      content: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["forumComment"]>
    composites: {}
  }

  type ForumCommentGetPayload<S extends boolean | null | undefined | ForumCommentDefaultArgs> = $Result.GetResult<Prisma.$ForumCommentPayload, S>

  type ForumCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ForumCommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ForumCommentCountAggregateInputType | true
    }

  export interface ForumCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ForumComment'], meta: { name: 'ForumComment' } }
    /**
     * Find zero or one ForumComment that matches the filter.
     * @param {ForumCommentFindUniqueArgs} args - Arguments to find a ForumComment
     * @example
     * // Get one ForumComment
     * const forumComment = await prisma.forumComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ForumCommentFindUniqueArgs>(args: SelectSubset<T, ForumCommentFindUniqueArgs<ExtArgs>>): Prisma__ForumCommentClient<$Result.GetResult<Prisma.$ForumCommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ForumComment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ForumCommentFindUniqueOrThrowArgs} args - Arguments to find a ForumComment
     * @example
     * // Get one ForumComment
     * const forumComment = await prisma.forumComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ForumCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, ForumCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ForumCommentClient<$Result.GetResult<Prisma.$ForumCommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ForumComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCommentFindFirstArgs} args - Arguments to find a ForumComment
     * @example
     * // Get one ForumComment
     * const forumComment = await prisma.forumComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ForumCommentFindFirstArgs>(args?: SelectSubset<T, ForumCommentFindFirstArgs<ExtArgs>>): Prisma__ForumCommentClient<$Result.GetResult<Prisma.$ForumCommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ForumComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCommentFindFirstOrThrowArgs} args - Arguments to find a ForumComment
     * @example
     * // Get one ForumComment
     * const forumComment = await prisma.forumComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ForumCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, ForumCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ForumCommentClient<$Result.GetResult<Prisma.$ForumCommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ForumComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ForumComments
     * const forumComments = await prisma.forumComment.findMany()
     * 
     * // Get first 10 ForumComments
     * const forumComments = await prisma.forumComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const forumCommentWithIdOnly = await prisma.forumComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ForumCommentFindManyArgs>(args?: SelectSubset<T, ForumCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumCommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ForumComment.
     * @param {ForumCommentCreateArgs} args - Arguments to create a ForumComment.
     * @example
     * // Create one ForumComment
     * const ForumComment = await prisma.forumComment.create({
     *   data: {
     *     // ... data to create a ForumComment
     *   }
     * })
     * 
     */
    create<T extends ForumCommentCreateArgs>(args: SelectSubset<T, ForumCommentCreateArgs<ExtArgs>>): Prisma__ForumCommentClient<$Result.GetResult<Prisma.$ForumCommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ForumComments.
     * @param {ForumCommentCreateManyArgs} args - Arguments to create many ForumComments.
     * @example
     * // Create many ForumComments
     * const forumComment = await prisma.forumComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ForumCommentCreateManyArgs>(args?: SelectSubset<T, ForumCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ForumComments and returns the data saved in the database.
     * @param {ForumCommentCreateManyAndReturnArgs} args - Arguments to create many ForumComments.
     * @example
     * // Create many ForumComments
     * const forumComment = await prisma.forumComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ForumComments and only return the `id`
     * const forumCommentWithIdOnly = await prisma.forumComment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ForumCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, ForumCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumCommentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ForumComment.
     * @param {ForumCommentDeleteArgs} args - Arguments to delete one ForumComment.
     * @example
     * // Delete one ForumComment
     * const ForumComment = await prisma.forumComment.delete({
     *   where: {
     *     // ... filter to delete one ForumComment
     *   }
     * })
     * 
     */
    delete<T extends ForumCommentDeleteArgs>(args: SelectSubset<T, ForumCommentDeleteArgs<ExtArgs>>): Prisma__ForumCommentClient<$Result.GetResult<Prisma.$ForumCommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ForumComment.
     * @param {ForumCommentUpdateArgs} args - Arguments to update one ForumComment.
     * @example
     * // Update one ForumComment
     * const forumComment = await prisma.forumComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ForumCommentUpdateArgs>(args: SelectSubset<T, ForumCommentUpdateArgs<ExtArgs>>): Prisma__ForumCommentClient<$Result.GetResult<Prisma.$ForumCommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ForumComments.
     * @param {ForumCommentDeleteManyArgs} args - Arguments to filter ForumComments to delete.
     * @example
     * // Delete a few ForumComments
     * const { count } = await prisma.forumComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ForumCommentDeleteManyArgs>(args?: SelectSubset<T, ForumCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForumComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ForumComments
     * const forumComment = await prisma.forumComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ForumCommentUpdateManyArgs>(args: SelectSubset<T, ForumCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ForumComment.
     * @param {ForumCommentUpsertArgs} args - Arguments to update or create a ForumComment.
     * @example
     * // Update or create a ForumComment
     * const forumComment = await prisma.forumComment.upsert({
     *   create: {
     *     // ... data to create a ForumComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ForumComment we want to update
     *   }
     * })
     */
    upsert<T extends ForumCommentUpsertArgs>(args: SelectSubset<T, ForumCommentUpsertArgs<ExtArgs>>): Prisma__ForumCommentClient<$Result.GetResult<Prisma.$ForumCommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ForumComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCommentCountArgs} args - Arguments to filter ForumComments to count.
     * @example
     * // Count the number of ForumComments
     * const count = await prisma.forumComment.count({
     *   where: {
     *     // ... the filter for the ForumComments we want to count
     *   }
     * })
    **/
    count<T extends ForumCommentCountArgs>(
      args?: Subset<T, ForumCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ForumCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ForumComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ForumCommentAggregateArgs>(args: Subset<T, ForumCommentAggregateArgs>): Prisma.PrismaPromise<GetForumCommentAggregateType<T>>

    /**
     * Group by ForumComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ForumCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ForumCommentGroupByArgs['orderBy'] }
        : { orderBy?: ForumCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ForumCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetForumCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ForumComment model
   */
  readonly fields: ForumCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ForumComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ForumCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    post<T extends ForumPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ForumPostDefaultArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ForumComment model
   */ 
  interface ForumCommentFieldRefs {
    readonly id: FieldRef<"ForumComment", 'String'>
    readonly userId: FieldRef<"ForumComment", 'String'>
    readonly postId: FieldRef<"ForumComment", 'String'>
    readonly content: FieldRef<"ForumComment", 'String'>
    readonly createdAt: FieldRef<"ForumComment", 'DateTime'>
    readonly updatedAt: FieldRef<"ForumComment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ForumComment findUnique
   */
  export type ForumCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentInclude<ExtArgs> | null
    /**
     * Filter, which ForumComment to fetch.
     */
    where: ForumCommentWhereUniqueInput
  }

  /**
   * ForumComment findUniqueOrThrow
   */
  export type ForumCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentInclude<ExtArgs> | null
    /**
     * Filter, which ForumComment to fetch.
     */
    where: ForumCommentWhereUniqueInput
  }

  /**
   * ForumComment findFirst
   */
  export type ForumCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentInclude<ExtArgs> | null
    /**
     * Filter, which ForumComment to fetch.
     */
    where?: ForumCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumComments to fetch.
     */
    orderBy?: ForumCommentOrderByWithRelationInput | ForumCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumComments.
     */
    cursor?: ForumCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumComments.
     */
    distinct?: ForumCommentScalarFieldEnum | ForumCommentScalarFieldEnum[]
  }

  /**
   * ForumComment findFirstOrThrow
   */
  export type ForumCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentInclude<ExtArgs> | null
    /**
     * Filter, which ForumComment to fetch.
     */
    where?: ForumCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumComments to fetch.
     */
    orderBy?: ForumCommentOrderByWithRelationInput | ForumCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumComments.
     */
    cursor?: ForumCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumComments.
     */
    distinct?: ForumCommentScalarFieldEnum | ForumCommentScalarFieldEnum[]
  }

  /**
   * ForumComment findMany
   */
  export type ForumCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentInclude<ExtArgs> | null
    /**
     * Filter, which ForumComments to fetch.
     */
    where?: ForumCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumComments to fetch.
     */
    orderBy?: ForumCommentOrderByWithRelationInput | ForumCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ForumComments.
     */
    cursor?: ForumCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumComments.
     */
    skip?: number
    distinct?: ForumCommentScalarFieldEnum | ForumCommentScalarFieldEnum[]
  }

  /**
   * ForumComment create
   */
  export type ForumCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a ForumComment.
     */
    data: XOR<ForumCommentCreateInput, ForumCommentUncheckedCreateInput>
  }

  /**
   * ForumComment createMany
   */
  export type ForumCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ForumComments.
     */
    data: ForumCommentCreateManyInput | ForumCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ForumComment createManyAndReturn
   */
  export type ForumCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ForumComments.
     */
    data: ForumCommentCreateManyInput | ForumCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ForumComment update
   */
  export type ForumCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a ForumComment.
     */
    data: XOR<ForumCommentUpdateInput, ForumCommentUncheckedUpdateInput>
    /**
     * Choose, which ForumComment to update.
     */
    where: ForumCommentWhereUniqueInput
  }

  /**
   * ForumComment updateMany
   */
  export type ForumCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ForumComments.
     */
    data: XOR<ForumCommentUpdateManyMutationInput, ForumCommentUncheckedUpdateManyInput>
    /**
     * Filter which ForumComments to update
     */
    where?: ForumCommentWhereInput
  }

  /**
   * ForumComment upsert
   */
  export type ForumCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the ForumComment to update in case it exists.
     */
    where: ForumCommentWhereUniqueInput
    /**
     * In case the ForumComment found by the `where` argument doesn't exist, create a new ForumComment with this data.
     */
    create: XOR<ForumCommentCreateInput, ForumCommentUncheckedCreateInput>
    /**
     * In case the ForumComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ForumCommentUpdateInput, ForumCommentUncheckedUpdateInput>
  }

  /**
   * ForumComment delete
   */
  export type ForumCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentInclude<ExtArgs> | null
    /**
     * Filter which ForumComment to delete.
     */
    where: ForumCommentWhereUniqueInput
  }

  /**
   * ForumComment deleteMany
   */
  export type ForumCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumComments to delete
     */
    where?: ForumCommentWhereInput
  }

  /**
   * ForumComment without action
   */
  export type ForumCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentInclude<ExtArgs> | null
  }


  /**
   * Model CommunityGroup
   */

  export type AggregateCommunityGroup = {
    _count: CommunityGroupCountAggregateOutputType | null
    _min: CommunityGroupMinAggregateOutputType | null
    _max: CommunityGroupMaxAggregateOutputType | null
  }

  export type CommunityGroupMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    photoUrl: string | null
    isPublic: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommunityGroupMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    photoUrl: string | null
    isPublic: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommunityGroupCountAggregateOutputType = {
    id: number
    name: number
    description: number
    photoUrl: number
    isPublic: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommunityGroupMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    photoUrl?: true
    isPublic?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommunityGroupMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    photoUrl?: true
    isPublic?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommunityGroupCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    photoUrl?: true
    isPublic?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommunityGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityGroup to aggregate.
     */
    where?: CommunityGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityGroups to fetch.
     */
    orderBy?: CommunityGroupOrderByWithRelationInput | CommunityGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommunityGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunityGroups
    **/
    _count?: true | CommunityGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommunityGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommunityGroupMaxAggregateInputType
  }

  export type GetCommunityGroupAggregateType<T extends CommunityGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateCommunityGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunityGroup[P]>
      : GetScalarType<T[P], AggregateCommunityGroup[P]>
  }




  export type CommunityGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityGroupWhereInput
    orderBy?: CommunityGroupOrderByWithAggregationInput | CommunityGroupOrderByWithAggregationInput[]
    by: CommunityGroupScalarFieldEnum[] | CommunityGroupScalarFieldEnum
    having?: CommunityGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommunityGroupCountAggregateInputType | true
    _min?: CommunityGroupMinAggregateInputType
    _max?: CommunityGroupMaxAggregateInputType
  }

  export type CommunityGroupGroupByOutputType = {
    id: string
    name: string
    description: string
    photoUrl: string | null
    isPublic: boolean
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: CommunityGroupCountAggregateOutputType | null
    _min: CommunityGroupMinAggregateOutputType | null
    _max: CommunityGroupMaxAggregateOutputType | null
  }

  type GetCommunityGroupGroupByPayload<T extends CommunityGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommunityGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommunityGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommunityGroupGroupByOutputType[P]>
            : GetScalarType<T[P], CommunityGroupGroupByOutputType[P]>
        }
      >
    >


  export type CommunityGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    photoUrl?: boolean
    isPublic?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    members?: boolean | CommunityGroup$membersArgs<ExtArgs>
    _count?: boolean | CommunityGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["communityGroup"]>

  export type CommunityGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    photoUrl?: boolean
    isPublic?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["communityGroup"]>

  export type CommunityGroupSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    photoUrl?: boolean
    isPublic?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommunityGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | CommunityGroup$membersArgs<ExtArgs>
    _count?: boolean | CommunityGroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommunityGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CommunityGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommunityGroup"
    objects: {
      members: Prisma.$GroupMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      photoUrl: string | null
      isPublic: boolean
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["communityGroup"]>
    composites: {}
  }

  type CommunityGroupGetPayload<S extends boolean | null | undefined | CommunityGroupDefaultArgs> = $Result.GetResult<Prisma.$CommunityGroupPayload, S>

  type CommunityGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommunityGroupFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommunityGroupCountAggregateInputType | true
    }

  export interface CommunityGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommunityGroup'], meta: { name: 'CommunityGroup' } }
    /**
     * Find zero or one CommunityGroup that matches the filter.
     * @param {CommunityGroupFindUniqueArgs} args - Arguments to find a CommunityGroup
     * @example
     * // Get one CommunityGroup
     * const communityGroup = await prisma.communityGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommunityGroupFindUniqueArgs>(args: SelectSubset<T, CommunityGroupFindUniqueArgs<ExtArgs>>): Prisma__CommunityGroupClient<$Result.GetResult<Prisma.$CommunityGroupPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CommunityGroup that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommunityGroupFindUniqueOrThrowArgs} args - Arguments to find a CommunityGroup
     * @example
     * // Get one CommunityGroup
     * const communityGroup = await prisma.communityGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommunityGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, CommunityGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommunityGroupClient<$Result.GetResult<Prisma.$CommunityGroupPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CommunityGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityGroupFindFirstArgs} args - Arguments to find a CommunityGroup
     * @example
     * // Get one CommunityGroup
     * const communityGroup = await prisma.communityGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommunityGroupFindFirstArgs>(args?: SelectSubset<T, CommunityGroupFindFirstArgs<ExtArgs>>): Prisma__CommunityGroupClient<$Result.GetResult<Prisma.$CommunityGroupPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CommunityGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityGroupFindFirstOrThrowArgs} args - Arguments to find a CommunityGroup
     * @example
     * // Get one CommunityGroup
     * const communityGroup = await prisma.communityGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommunityGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, CommunityGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommunityGroupClient<$Result.GetResult<Prisma.$CommunityGroupPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CommunityGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunityGroups
     * const communityGroups = await prisma.communityGroup.findMany()
     * 
     * // Get first 10 CommunityGroups
     * const communityGroups = await prisma.communityGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communityGroupWithIdOnly = await prisma.communityGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommunityGroupFindManyArgs>(args?: SelectSubset<T, CommunityGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityGroupPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CommunityGroup.
     * @param {CommunityGroupCreateArgs} args - Arguments to create a CommunityGroup.
     * @example
     * // Create one CommunityGroup
     * const CommunityGroup = await prisma.communityGroup.create({
     *   data: {
     *     // ... data to create a CommunityGroup
     *   }
     * })
     * 
     */
    create<T extends CommunityGroupCreateArgs>(args: SelectSubset<T, CommunityGroupCreateArgs<ExtArgs>>): Prisma__CommunityGroupClient<$Result.GetResult<Prisma.$CommunityGroupPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CommunityGroups.
     * @param {CommunityGroupCreateManyArgs} args - Arguments to create many CommunityGroups.
     * @example
     * // Create many CommunityGroups
     * const communityGroup = await prisma.communityGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommunityGroupCreateManyArgs>(args?: SelectSubset<T, CommunityGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CommunityGroups and returns the data saved in the database.
     * @param {CommunityGroupCreateManyAndReturnArgs} args - Arguments to create many CommunityGroups.
     * @example
     * // Create many CommunityGroups
     * const communityGroup = await prisma.communityGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CommunityGroups and only return the `id`
     * const communityGroupWithIdOnly = await prisma.communityGroup.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommunityGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, CommunityGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityGroupPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CommunityGroup.
     * @param {CommunityGroupDeleteArgs} args - Arguments to delete one CommunityGroup.
     * @example
     * // Delete one CommunityGroup
     * const CommunityGroup = await prisma.communityGroup.delete({
     *   where: {
     *     // ... filter to delete one CommunityGroup
     *   }
     * })
     * 
     */
    delete<T extends CommunityGroupDeleteArgs>(args: SelectSubset<T, CommunityGroupDeleteArgs<ExtArgs>>): Prisma__CommunityGroupClient<$Result.GetResult<Prisma.$CommunityGroupPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CommunityGroup.
     * @param {CommunityGroupUpdateArgs} args - Arguments to update one CommunityGroup.
     * @example
     * // Update one CommunityGroup
     * const communityGroup = await prisma.communityGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommunityGroupUpdateArgs>(args: SelectSubset<T, CommunityGroupUpdateArgs<ExtArgs>>): Prisma__CommunityGroupClient<$Result.GetResult<Prisma.$CommunityGroupPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CommunityGroups.
     * @param {CommunityGroupDeleteManyArgs} args - Arguments to filter CommunityGroups to delete.
     * @example
     * // Delete a few CommunityGroups
     * const { count } = await prisma.communityGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommunityGroupDeleteManyArgs>(args?: SelectSubset<T, CommunityGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommunityGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunityGroups
     * const communityGroup = await prisma.communityGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommunityGroupUpdateManyArgs>(args: SelectSubset<T, CommunityGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CommunityGroup.
     * @param {CommunityGroupUpsertArgs} args - Arguments to update or create a CommunityGroup.
     * @example
     * // Update or create a CommunityGroup
     * const communityGroup = await prisma.communityGroup.upsert({
     *   create: {
     *     // ... data to create a CommunityGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunityGroup we want to update
     *   }
     * })
     */
    upsert<T extends CommunityGroupUpsertArgs>(args: SelectSubset<T, CommunityGroupUpsertArgs<ExtArgs>>): Prisma__CommunityGroupClient<$Result.GetResult<Prisma.$CommunityGroupPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CommunityGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityGroupCountArgs} args - Arguments to filter CommunityGroups to count.
     * @example
     * // Count the number of CommunityGroups
     * const count = await prisma.communityGroup.count({
     *   where: {
     *     // ... the filter for the CommunityGroups we want to count
     *   }
     * })
    **/
    count<T extends CommunityGroupCountArgs>(
      args?: Subset<T, CommunityGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunityGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityGroupAggregateArgs>(args: Subset<T, CommunityGroupAggregateArgs>): Prisma.PrismaPromise<GetCommunityGroupAggregateType<T>>

    /**
     * Group by CommunityGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunityGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunityGroupGroupByArgs['orderBy'] }
        : { orderBy?: CommunityGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunityGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunityGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommunityGroup model
   */
  readonly fields: CommunityGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunityGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommunityGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends CommunityGroup$membersArgs<ExtArgs> = {}>(args?: Subset<T, CommunityGroup$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommunityGroup model
   */ 
  interface CommunityGroupFieldRefs {
    readonly id: FieldRef<"CommunityGroup", 'String'>
    readonly name: FieldRef<"CommunityGroup", 'String'>
    readonly description: FieldRef<"CommunityGroup", 'String'>
    readonly photoUrl: FieldRef<"CommunityGroup", 'String'>
    readonly isPublic: FieldRef<"CommunityGroup", 'Boolean'>
    readonly createdBy: FieldRef<"CommunityGroup", 'String'>
    readonly createdAt: FieldRef<"CommunityGroup", 'DateTime'>
    readonly updatedAt: FieldRef<"CommunityGroup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CommunityGroup findUnique
   */
  export type CommunityGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityGroup
     */
    select?: CommunityGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityGroupInclude<ExtArgs> | null
    /**
     * Filter, which CommunityGroup to fetch.
     */
    where: CommunityGroupWhereUniqueInput
  }

  /**
   * CommunityGroup findUniqueOrThrow
   */
  export type CommunityGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityGroup
     */
    select?: CommunityGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityGroupInclude<ExtArgs> | null
    /**
     * Filter, which CommunityGroup to fetch.
     */
    where: CommunityGroupWhereUniqueInput
  }

  /**
   * CommunityGroup findFirst
   */
  export type CommunityGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityGroup
     */
    select?: CommunityGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityGroupInclude<ExtArgs> | null
    /**
     * Filter, which CommunityGroup to fetch.
     */
    where?: CommunityGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityGroups to fetch.
     */
    orderBy?: CommunityGroupOrderByWithRelationInput | CommunityGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityGroups.
     */
    cursor?: CommunityGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityGroups.
     */
    distinct?: CommunityGroupScalarFieldEnum | CommunityGroupScalarFieldEnum[]
  }

  /**
   * CommunityGroup findFirstOrThrow
   */
  export type CommunityGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityGroup
     */
    select?: CommunityGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityGroupInclude<ExtArgs> | null
    /**
     * Filter, which CommunityGroup to fetch.
     */
    where?: CommunityGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityGroups to fetch.
     */
    orderBy?: CommunityGroupOrderByWithRelationInput | CommunityGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityGroups.
     */
    cursor?: CommunityGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityGroups.
     */
    distinct?: CommunityGroupScalarFieldEnum | CommunityGroupScalarFieldEnum[]
  }

  /**
   * CommunityGroup findMany
   */
  export type CommunityGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityGroup
     */
    select?: CommunityGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityGroupInclude<ExtArgs> | null
    /**
     * Filter, which CommunityGroups to fetch.
     */
    where?: CommunityGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityGroups to fetch.
     */
    orderBy?: CommunityGroupOrderByWithRelationInput | CommunityGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunityGroups.
     */
    cursor?: CommunityGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityGroups.
     */
    skip?: number
    distinct?: CommunityGroupScalarFieldEnum | CommunityGroupScalarFieldEnum[]
  }

  /**
   * CommunityGroup create
   */
  export type CommunityGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityGroup
     */
    select?: CommunityGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a CommunityGroup.
     */
    data: XOR<CommunityGroupCreateInput, CommunityGroupUncheckedCreateInput>
  }

  /**
   * CommunityGroup createMany
   */
  export type CommunityGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommunityGroups.
     */
    data: CommunityGroupCreateManyInput | CommunityGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommunityGroup createManyAndReturn
   */
  export type CommunityGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityGroup
     */
    select?: CommunityGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CommunityGroups.
     */
    data: CommunityGroupCreateManyInput | CommunityGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommunityGroup update
   */
  export type CommunityGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityGroup
     */
    select?: CommunityGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a CommunityGroup.
     */
    data: XOR<CommunityGroupUpdateInput, CommunityGroupUncheckedUpdateInput>
    /**
     * Choose, which CommunityGroup to update.
     */
    where: CommunityGroupWhereUniqueInput
  }

  /**
   * CommunityGroup updateMany
   */
  export type CommunityGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommunityGroups.
     */
    data: XOR<CommunityGroupUpdateManyMutationInput, CommunityGroupUncheckedUpdateManyInput>
    /**
     * Filter which CommunityGroups to update
     */
    where?: CommunityGroupWhereInput
  }

  /**
   * CommunityGroup upsert
   */
  export type CommunityGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityGroup
     */
    select?: CommunityGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the CommunityGroup to update in case it exists.
     */
    where: CommunityGroupWhereUniqueInput
    /**
     * In case the CommunityGroup found by the `where` argument doesn't exist, create a new CommunityGroup with this data.
     */
    create: XOR<CommunityGroupCreateInput, CommunityGroupUncheckedCreateInput>
    /**
     * In case the CommunityGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommunityGroupUpdateInput, CommunityGroupUncheckedUpdateInput>
  }

  /**
   * CommunityGroup delete
   */
  export type CommunityGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityGroup
     */
    select?: CommunityGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityGroupInclude<ExtArgs> | null
    /**
     * Filter which CommunityGroup to delete.
     */
    where: CommunityGroupWhereUniqueInput
  }

  /**
   * CommunityGroup deleteMany
   */
  export type CommunityGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityGroups to delete
     */
    where?: CommunityGroupWhereInput
  }

  /**
   * CommunityGroup.members
   */
  export type CommunityGroup$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    where?: GroupMemberWhereInput
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    cursor?: GroupMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * CommunityGroup without action
   */
  export type CommunityGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityGroup
     */
    select?: CommunityGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityGroupInclude<ExtArgs> | null
  }


  /**
   * Model GroupMember
   */

  export type AggregateGroupMember = {
    _count: GroupMemberCountAggregateOutputType | null
    _min: GroupMemberMinAggregateOutputType | null
    _max: GroupMemberMaxAggregateOutputType | null
  }

  export type GroupMemberMinAggregateOutputType = {
    id: string | null
    groupId: string | null
    userId: string | null
    role: string | null
    joinedAt: Date | null
  }

  export type GroupMemberMaxAggregateOutputType = {
    id: string | null
    groupId: string | null
    userId: string | null
    role: string | null
    joinedAt: Date | null
  }

  export type GroupMemberCountAggregateOutputType = {
    id: number
    groupId: number
    userId: number
    role: number
    joinedAt: number
    _all: number
  }


  export type GroupMemberMinAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    role?: true
    joinedAt?: true
  }

  export type GroupMemberMaxAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    role?: true
    joinedAt?: true
  }

  export type GroupMemberCountAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    role?: true
    joinedAt?: true
    _all?: true
  }

  export type GroupMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupMember to aggregate.
     */
    where?: GroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMembers to fetch.
     */
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupMembers
    **/
    _count?: true | GroupMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMemberMaxAggregateInputType
  }

  export type GetGroupMemberAggregateType<T extends GroupMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupMember[P]>
      : GetScalarType<T[P], AggregateGroupMember[P]>
  }




  export type GroupMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMemberWhereInput
    orderBy?: GroupMemberOrderByWithAggregationInput | GroupMemberOrderByWithAggregationInput[]
    by: GroupMemberScalarFieldEnum[] | GroupMemberScalarFieldEnum
    having?: GroupMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupMemberCountAggregateInputType | true
    _min?: GroupMemberMinAggregateInputType
    _max?: GroupMemberMaxAggregateInputType
  }

  export type GroupMemberGroupByOutputType = {
    id: string
    groupId: string
    userId: string
    role: string
    joinedAt: Date
    _count: GroupMemberCountAggregateOutputType | null
    _min: GroupMemberMinAggregateOutputType | null
    _max: GroupMemberMaxAggregateOutputType | null
  }

  type GetGroupMemberGroupByPayload<T extends GroupMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupMemberGroupByOutputType[P]>
            : GetScalarType<T[P], GroupMemberGroupByOutputType[P]>
        }
      >
    >


  export type GroupMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    group?: boolean | CommunityGroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupMember"]>

  export type GroupMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    group?: boolean | CommunityGroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupMember"]>

  export type GroupMemberSelectScalar = {
    id?: boolean
    groupId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
  }

  export type GroupMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | CommunityGroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GroupMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | CommunityGroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GroupMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GroupMember"
    objects: {
      group: Prisma.$CommunityGroupPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      groupId: string
      userId: string
      role: string
      joinedAt: Date
    }, ExtArgs["result"]["groupMember"]>
    composites: {}
  }

  type GroupMemberGetPayload<S extends boolean | null | undefined | GroupMemberDefaultArgs> = $Result.GetResult<Prisma.$GroupMemberPayload, S>

  type GroupMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GroupMemberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GroupMemberCountAggregateInputType | true
    }

  export interface GroupMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GroupMember'], meta: { name: 'GroupMember' } }
    /**
     * Find zero or one GroupMember that matches the filter.
     * @param {GroupMemberFindUniqueArgs} args - Arguments to find a GroupMember
     * @example
     * // Get one GroupMember
     * const groupMember = await prisma.groupMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupMemberFindUniqueArgs>(args: SelectSubset<T, GroupMemberFindUniqueArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GroupMember that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GroupMemberFindUniqueOrThrowArgs} args - Arguments to find a GroupMember
     * @example
     * // Get one GroupMember
     * const groupMember = await prisma.groupMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GroupMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberFindFirstArgs} args - Arguments to find a GroupMember
     * @example
     * // Get one GroupMember
     * const groupMember = await prisma.groupMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupMemberFindFirstArgs>(args?: SelectSubset<T, GroupMemberFindFirstArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GroupMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberFindFirstOrThrowArgs} args - Arguments to find a GroupMember
     * @example
     * // Get one GroupMember
     * const groupMember = await prisma.groupMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GroupMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupMembers
     * const groupMembers = await prisma.groupMember.findMany()
     * 
     * // Get first 10 GroupMembers
     * const groupMembers = await prisma.groupMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupMemberWithIdOnly = await prisma.groupMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupMemberFindManyArgs>(args?: SelectSubset<T, GroupMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GroupMember.
     * @param {GroupMemberCreateArgs} args - Arguments to create a GroupMember.
     * @example
     * // Create one GroupMember
     * const GroupMember = await prisma.groupMember.create({
     *   data: {
     *     // ... data to create a GroupMember
     *   }
     * })
     * 
     */
    create<T extends GroupMemberCreateArgs>(args: SelectSubset<T, GroupMemberCreateArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GroupMembers.
     * @param {GroupMemberCreateManyArgs} args - Arguments to create many GroupMembers.
     * @example
     * // Create many GroupMembers
     * const groupMember = await prisma.groupMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupMemberCreateManyArgs>(args?: SelectSubset<T, GroupMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GroupMembers and returns the data saved in the database.
     * @param {GroupMemberCreateManyAndReturnArgs} args - Arguments to create many GroupMembers.
     * @example
     * // Create many GroupMembers
     * const groupMember = await prisma.groupMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GroupMembers and only return the `id`
     * const groupMemberWithIdOnly = await prisma.groupMember.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GroupMember.
     * @param {GroupMemberDeleteArgs} args - Arguments to delete one GroupMember.
     * @example
     * // Delete one GroupMember
     * const GroupMember = await prisma.groupMember.delete({
     *   where: {
     *     // ... filter to delete one GroupMember
     *   }
     * })
     * 
     */
    delete<T extends GroupMemberDeleteArgs>(args: SelectSubset<T, GroupMemberDeleteArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GroupMember.
     * @param {GroupMemberUpdateArgs} args - Arguments to update one GroupMember.
     * @example
     * // Update one GroupMember
     * const groupMember = await prisma.groupMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupMemberUpdateArgs>(args: SelectSubset<T, GroupMemberUpdateArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GroupMembers.
     * @param {GroupMemberDeleteManyArgs} args - Arguments to filter GroupMembers to delete.
     * @example
     * // Delete a few GroupMembers
     * const { count } = await prisma.groupMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupMemberDeleteManyArgs>(args?: SelectSubset<T, GroupMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupMembers
     * const groupMember = await prisma.groupMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupMemberUpdateManyArgs>(args: SelectSubset<T, GroupMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GroupMember.
     * @param {GroupMemberUpsertArgs} args - Arguments to update or create a GroupMember.
     * @example
     * // Update or create a GroupMember
     * const groupMember = await prisma.groupMember.upsert({
     *   create: {
     *     // ... data to create a GroupMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupMember we want to update
     *   }
     * })
     */
    upsert<T extends GroupMemberUpsertArgs>(args: SelectSubset<T, GroupMemberUpsertArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GroupMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberCountArgs} args - Arguments to filter GroupMembers to count.
     * @example
     * // Count the number of GroupMembers
     * const count = await prisma.groupMember.count({
     *   where: {
     *     // ... the filter for the GroupMembers we want to count
     *   }
     * })
    **/
    count<T extends GroupMemberCountArgs>(
      args?: Subset<T, GroupMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupMemberAggregateArgs>(args: Subset<T, GroupMemberAggregateArgs>): Prisma.PrismaPromise<GetGroupMemberAggregateType<T>>

    /**
     * Group by GroupMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupMemberGroupByArgs['orderBy'] }
        : { orderBy?: GroupMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GroupMember model
   */
  readonly fields: GroupMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group<T extends CommunityGroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommunityGroupDefaultArgs<ExtArgs>>): Prisma__CommunityGroupClient<$Result.GetResult<Prisma.$CommunityGroupPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GroupMember model
   */ 
  interface GroupMemberFieldRefs {
    readonly id: FieldRef<"GroupMember", 'String'>
    readonly groupId: FieldRef<"GroupMember", 'String'>
    readonly userId: FieldRef<"GroupMember", 'String'>
    readonly role: FieldRef<"GroupMember", 'String'>
    readonly joinedAt: FieldRef<"GroupMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GroupMember findUnique
   */
  export type GroupMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMember to fetch.
     */
    where: GroupMemberWhereUniqueInput
  }

  /**
   * GroupMember findUniqueOrThrow
   */
  export type GroupMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMember to fetch.
     */
    where: GroupMemberWhereUniqueInput
  }

  /**
   * GroupMember findFirst
   */
  export type GroupMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMember to fetch.
     */
    where?: GroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMembers to fetch.
     */
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupMembers.
     */
    cursor?: GroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupMembers.
     */
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * GroupMember findFirstOrThrow
   */
  export type GroupMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMember to fetch.
     */
    where?: GroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMembers to fetch.
     */
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupMembers.
     */
    cursor?: GroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupMembers.
     */
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * GroupMember findMany
   */
  export type GroupMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMembers to fetch.
     */
    where?: GroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMembers to fetch.
     */
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupMembers.
     */
    cursor?: GroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMembers.
     */
    skip?: number
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * GroupMember create
   */
  export type GroupMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a GroupMember.
     */
    data: XOR<GroupMemberCreateInput, GroupMemberUncheckedCreateInput>
  }

  /**
   * GroupMember createMany
   */
  export type GroupMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GroupMembers.
     */
    data: GroupMemberCreateManyInput | GroupMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GroupMember createManyAndReturn
   */
  export type GroupMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GroupMembers.
     */
    data: GroupMemberCreateManyInput | GroupMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupMember update
   */
  export type GroupMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a GroupMember.
     */
    data: XOR<GroupMemberUpdateInput, GroupMemberUncheckedUpdateInput>
    /**
     * Choose, which GroupMember to update.
     */
    where: GroupMemberWhereUniqueInput
  }

  /**
   * GroupMember updateMany
   */
  export type GroupMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GroupMembers.
     */
    data: XOR<GroupMemberUpdateManyMutationInput, GroupMemberUncheckedUpdateManyInput>
    /**
     * Filter which GroupMembers to update
     */
    where?: GroupMemberWhereInput
  }

  /**
   * GroupMember upsert
   */
  export type GroupMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the GroupMember to update in case it exists.
     */
    where: GroupMemberWhereUniqueInput
    /**
     * In case the GroupMember found by the `where` argument doesn't exist, create a new GroupMember with this data.
     */
    create: XOR<GroupMemberCreateInput, GroupMemberUncheckedCreateInput>
    /**
     * In case the GroupMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupMemberUpdateInput, GroupMemberUncheckedUpdateInput>
  }

  /**
   * GroupMember delete
   */
  export type GroupMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter which GroupMember to delete.
     */
    where: GroupMemberWhereUniqueInput
  }

  /**
   * GroupMember deleteMany
   */
  export type GroupMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupMembers to delete
     */
    where?: GroupMemberWhereInput
  }

  /**
   * GroupMember without action
   */
  export type GroupMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
  }


  /**
   * Model CommunityEvent
   */

  export type AggregateCommunityEvent = {
    _count: CommunityEventCountAggregateOutputType | null
    _avg: CommunityEventAvgAggregateOutputType | null
    _sum: CommunityEventSumAggregateOutputType | null
    _min: CommunityEventMinAggregateOutputType | null
    _max: CommunityEventMaxAggregateOutputType | null
  }

  export type CommunityEventAvgAggregateOutputType = {
    maxParticipants: number | null
  }

  export type CommunityEventSumAggregateOutputType = {
    maxParticipants: number | null
  }

  export type CommunityEventMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    eventDate: Date | null
    location: string | null
    photoUrl: string | null
    maxParticipants: number | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommunityEventMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    eventDate: Date | null
    location: string | null
    photoUrl: string | null
    maxParticipants: number | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommunityEventCountAggregateOutputType = {
    id: number
    title: number
    description: number
    eventDate: number
    location: number
    photoUrl: number
    maxParticipants: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommunityEventAvgAggregateInputType = {
    maxParticipants?: true
  }

  export type CommunityEventSumAggregateInputType = {
    maxParticipants?: true
  }

  export type CommunityEventMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    eventDate?: true
    location?: true
    photoUrl?: true
    maxParticipants?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommunityEventMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    eventDate?: true
    location?: true
    photoUrl?: true
    maxParticipants?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommunityEventCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    eventDate?: true
    location?: true
    photoUrl?: true
    maxParticipants?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommunityEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityEvent to aggregate.
     */
    where?: CommunityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityEvents to fetch.
     */
    orderBy?: CommunityEventOrderByWithRelationInput | CommunityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommunityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunityEvents
    **/
    _count?: true | CommunityEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommunityEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommunityEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommunityEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommunityEventMaxAggregateInputType
  }

  export type GetCommunityEventAggregateType<T extends CommunityEventAggregateArgs> = {
        [P in keyof T & keyof AggregateCommunityEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunityEvent[P]>
      : GetScalarType<T[P], AggregateCommunityEvent[P]>
  }




  export type CommunityEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityEventWhereInput
    orderBy?: CommunityEventOrderByWithAggregationInput | CommunityEventOrderByWithAggregationInput[]
    by: CommunityEventScalarFieldEnum[] | CommunityEventScalarFieldEnum
    having?: CommunityEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommunityEventCountAggregateInputType | true
    _avg?: CommunityEventAvgAggregateInputType
    _sum?: CommunityEventSumAggregateInputType
    _min?: CommunityEventMinAggregateInputType
    _max?: CommunityEventMaxAggregateInputType
  }

  export type CommunityEventGroupByOutputType = {
    id: string
    title: string
    description: string
    eventDate: Date
    location: string
    photoUrl: string | null
    maxParticipants: number | null
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: CommunityEventCountAggregateOutputType | null
    _avg: CommunityEventAvgAggregateOutputType | null
    _sum: CommunityEventSumAggregateOutputType | null
    _min: CommunityEventMinAggregateOutputType | null
    _max: CommunityEventMaxAggregateOutputType | null
  }

  type GetCommunityEventGroupByPayload<T extends CommunityEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommunityEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommunityEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommunityEventGroupByOutputType[P]>
            : GetScalarType<T[P], CommunityEventGroupByOutputType[P]>
        }
      >
    >


  export type CommunityEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    eventDate?: boolean
    location?: boolean
    photoUrl?: boolean
    maxParticipants?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    participants?: boolean | CommunityEvent$participantsArgs<ExtArgs>
    _count?: boolean | CommunityEventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["communityEvent"]>

  export type CommunityEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    eventDate?: boolean
    location?: boolean
    photoUrl?: boolean
    maxParticipants?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["communityEvent"]>

  export type CommunityEventSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    eventDate?: boolean
    location?: boolean
    photoUrl?: boolean
    maxParticipants?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommunityEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | CommunityEvent$participantsArgs<ExtArgs>
    _count?: boolean | CommunityEventCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommunityEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CommunityEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommunityEvent"
    objects: {
      participants: Prisma.$EventParticipantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      eventDate: Date
      location: string
      photoUrl: string | null
      maxParticipants: number | null
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["communityEvent"]>
    composites: {}
  }

  type CommunityEventGetPayload<S extends boolean | null | undefined | CommunityEventDefaultArgs> = $Result.GetResult<Prisma.$CommunityEventPayload, S>

  type CommunityEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommunityEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommunityEventCountAggregateInputType | true
    }

  export interface CommunityEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommunityEvent'], meta: { name: 'CommunityEvent' } }
    /**
     * Find zero or one CommunityEvent that matches the filter.
     * @param {CommunityEventFindUniqueArgs} args - Arguments to find a CommunityEvent
     * @example
     * // Get one CommunityEvent
     * const communityEvent = await prisma.communityEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommunityEventFindUniqueArgs>(args: SelectSubset<T, CommunityEventFindUniqueArgs<ExtArgs>>): Prisma__CommunityEventClient<$Result.GetResult<Prisma.$CommunityEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CommunityEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommunityEventFindUniqueOrThrowArgs} args - Arguments to find a CommunityEvent
     * @example
     * // Get one CommunityEvent
     * const communityEvent = await prisma.communityEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommunityEventFindUniqueOrThrowArgs>(args: SelectSubset<T, CommunityEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommunityEventClient<$Result.GetResult<Prisma.$CommunityEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CommunityEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityEventFindFirstArgs} args - Arguments to find a CommunityEvent
     * @example
     * // Get one CommunityEvent
     * const communityEvent = await prisma.communityEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommunityEventFindFirstArgs>(args?: SelectSubset<T, CommunityEventFindFirstArgs<ExtArgs>>): Prisma__CommunityEventClient<$Result.GetResult<Prisma.$CommunityEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CommunityEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityEventFindFirstOrThrowArgs} args - Arguments to find a CommunityEvent
     * @example
     * // Get one CommunityEvent
     * const communityEvent = await prisma.communityEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommunityEventFindFirstOrThrowArgs>(args?: SelectSubset<T, CommunityEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommunityEventClient<$Result.GetResult<Prisma.$CommunityEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CommunityEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunityEvents
     * const communityEvents = await prisma.communityEvent.findMany()
     * 
     * // Get first 10 CommunityEvents
     * const communityEvents = await prisma.communityEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communityEventWithIdOnly = await prisma.communityEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommunityEventFindManyArgs>(args?: SelectSubset<T, CommunityEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CommunityEvent.
     * @param {CommunityEventCreateArgs} args - Arguments to create a CommunityEvent.
     * @example
     * // Create one CommunityEvent
     * const CommunityEvent = await prisma.communityEvent.create({
     *   data: {
     *     // ... data to create a CommunityEvent
     *   }
     * })
     * 
     */
    create<T extends CommunityEventCreateArgs>(args: SelectSubset<T, CommunityEventCreateArgs<ExtArgs>>): Prisma__CommunityEventClient<$Result.GetResult<Prisma.$CommunityEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CommunityEvents.
     * @param {CommunityEventCreateManyArgs} args - Arguments to create many CommunityEvents.
     * @example
     * // Create many CommunityEvents
     * const communityEvent = await prisma.communityEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommunityEventCreateManyArgs>(args?: SelectSubset<T, CommunityEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CommunityEvents and returns the data saved in the database.
     * @param {CommunityEventCreateManyAndReturnArgs} args - Arguments to create many CommunityEvents.
     * @example
     * // Create many CommunityEvents
     * const communityEvent = await prisma.communityEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CommunityEvents and only return the `id`
     * const communityEventWithIdOnly = await prisma.communityEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommunityEventCreateManyAndReturnArgs>(args?: SelectSubset<T, CommunityEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CommunityEvent.
     * @param {CommunityEventDeleteArgs} args - Arguments to delete one CommunityEvent.
     * @example
     * // Delete one CommunityEvent
     * const CommunityEvent = await prisma.communityEvent.delete({
     *   where: {
     *     // ... filter to delete one CommunityEvent
     *   }
     * })
     * 
     */
    delete<T extends CommunityEventDeleteArgs>(args: SelectSubset<T, CommunityEventDeleteArgs<ExtArgs>>): Prisma__CommunityEventClient<$Result.GetResult<Prisma.$CommunityEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CommunityEvent.
     * @param {CommunityEventUpdateArgs} args - Arguments to update one CommunityEvent.
     * @example
     * // Update one CommunityEvent
     * const communityEvent = await prisma.communityEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommunityEventUpdateArgs>(args: SelectSubset<T, CommunityEventUpdateArgs<ExtArgs>>): Prisma__CommunityEventClient<$Result.GetResult<Prisma.$CommunityEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CommunityEvents.
     * @param {CommunityEventDeleteManyArgs} args - Arguments to filter CommunityEvents to delete.
     * @example
     * // Delete a few CommunityEvents
     * const { count } = await prisma.communityEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommunityEventDeleteManyArgs>(args?: SelectSubset<T, CommunityEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommunityEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunityEvents
     * const communityEvent = await prisma.communityEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommunityEventUpdateManyArgs>(args: SelectSubset<T, CommunityEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CommunityEvent.
     * @param {CommunityEventUpsertArgs} args - Arguments to update or create a CommunityEvent.
     * @example
     * // Update or create a CommunityEvent
     * const communityEvent = await prisma.communityEvent.upsert({
     *   create: {
     *     // ... data to create a CommunityEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunityEvent we want to update
     *   }
     * })
     */
    upsert<T extends CommunityEventUpsertArgs>(args: SelectSubset<T, CommunityEventUpsertArgs<ExtArgs>>): Prisma__CommunityEventClient<$Result.GetResult<Prisma.$CommunityEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CommunityEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityEventCountArgs} args - Arguments to filter CommunityEvents to count.
     * @example
     * // Count the number of CommunityEvents
     * const count = await prisma.communityEvent.count({
     *   where: {
     *     // ... the filter for the CommunityEvents we want to count
     *   }
     * })
    **/
    count<T extends CommunityEventCountArgs>(
      args?: Subset<T, CommunityEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunityEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityEventAggregateArgs>(args: Subset<T, CommunityEventAggregateArgs>): Prisma.PrismaPromise<GetCommunityEventAggregateType<T>>

    /**
     * Group by CommunityEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunityEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunityEventGroupByArgs['orderBy'] }
        : { orderBy?: CommunityEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunityEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunityEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommunityEvent model
   */
  readonly fields: CommunityEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunityEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommunityEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    participants<T extends CommunityEvent$participantsArgs<ExtArgs> = {}>(args?: Subset<T, CommunityEvent$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventParticipantPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommunityEvent model
   */ 
  interface CommunityEventFieldRefs {
    readonly id: FieldRef<"CommunityEvent", 'String'>
    readonly title: FieldRef<"CommunityEvent", 'String'>
    readonly description: FieldRef<"CommunityEvent", 'String'>
    readonly eventDate: FieldRef<"CommunityEvent", 'DateTime'>
    readonly location: FieldRef<"CommunityEvent", 'String'>
    readonly photoUrl: FieldRef<"CommunityEvent", 'String'>
    readonly maxParticipants: FieldRef<"CommunityEvent", 'Int'>
    readonly createdBy: FieldRef<"CommunityEvent", 'String'>
    readonly createdAt: FieldRef<"CommunityEvent", 'DateTime'>
    readonly updatedAt: FieldRef<"CommunityEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CommunityEvent findUnique
   */
  export type CommunityEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityEvent
     */
    select?: CommunityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityEventInclude<ExtArgs> | null
    /**
     * Filter, which CommunityEvent to fetch.
     */
    where: CommunityEventWhereUniqueInput
  }

  /**
   * CommunityEvent findUniqueOrThrow
   */
  export type CommunityEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityEvent
     */
    select?: CommunityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityEventInclude<ExtArgs> | null
    /**
     * Filter, which CommunityEvent to fetch.
     */
    where: CommunityEventWhereUniqueInput
  }

  /**
   * CommunityEvent findFirst
   */
  export type CommunityEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityEvent
     */
    select?: CommunityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityEventInclude<ExtArgs> | null
    /**
     * Filter, which CommunityEvent to fetch.
     */
    where?: CommunityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityEvents to fetch.
     */
    orderBy?: CommunityEventOrderByWithRelationInput | CommunityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityEvents.
     */
    cursor?: CommunityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityEvents.
     */
    distinct?: CommunityEventScalarFieldEnum | CommunityEventScalarFieldEnum[]
  }

  /**
   * CommunityEvent findFirstOrThrow
   */
  export type CommunityEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityEvent
     */
    select?: CommunityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityEventInclude<ExtArgs> | null
    /**
     * Filter, which CommunityEvent to fetch.
     */
    where?: CommunityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityEvents to fetch.
     */
    orderBy?: CommunityEventOrderByWithRelationInput | CommunityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityEvents.
     */
    cursor?: CommunityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityEvents.
     */
    distinct?: CommunityEventScalarFieldEnum | CommunityEventScalarFieldEnum[]
  }

  /**
   * CommunityEvent findMany
   */
  export type CommunityEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityEvent
     */
    select?: CommunityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityEventInclude<ExtArgs> | null
    /**
     * Filter, which CommunityEvents to fetch.
     */
    where?: CommunityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityEvents to fetch.
     */
    orderBy?: CommunityEventOrderByWithRelationInput | CommunityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunityEvents.
     */
    cursor?: CommunityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityEvents.
     */
    skip?: number
    distinct?: CommunityEventScalarFieldEnum | CommunityEventScalarFieldEnum[]
  }

  /**
   * CommunityEvent create
   */
  export type CommunityEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityEvent
     */
    select?: CommunityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityEventInclude<ExtArgs> | null
    /**
     * The data needed to create a CommunityEvent.
     */
    data: XOR<CommunityEventCreateInput, CommunityEventUncheckedCreateInput>
  }

  /**
   * CommunityEvent createMany
   */
  export type CommunityEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommunityEvents.
     */
    data: CommunityEventCreateManyInput | CommunityEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommunityEvent createManyAndReturn
   */
  export type CommunityEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityEvent
     */
    select?: CommunityEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CommunityEvents.
     */
    data: CommunityEventCreateManyInput | CommunityEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommunityEvent update
   */
  export type CommunityEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityEvent
     */
    select?: CommunityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityEventInclude<ExtArgs> | null
    /**
     * The data needed to update a CommunityEvent.
     */
    data: XOR<CommunityEventUpdateInput, CommunityEventUncheckedUpdateInput>
    /**
     * Choose, which CommunityEvent to update.
     */
    where: CommunityEventWhereUniqueInput
  }

  /**
   * CommunityEvent updateMany
   */
  export type CommunityEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommunityEvents.
     */
    data: XOR<CommunityEventUpdateManyMutationInput, CommunityEventUncheckedUpdateManyInput>
    /**
     * Filter which CommunityEvents to update
     */
    where?: CommunityEventWhereInput
  }

  /**
   * CommunityEvent upsert
   */
  export type CommunityEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityEvent
     */
    select?: CommunityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityEventInclude<ExtArgs> | null
    /**
     * The filter to search for the CommunityEvent to update in case it exists.
     */
    where: CommunityEventWhereUniqueInput
    /**
     * In case the CommunityEvent found by the `where` argument doesn't exist, create a new CommunityEvent with this data.
     */
    create: XOR<CommunityEventCreateInput, CommunityEventUncheckedCreateInput>
    /**
     * In case the CommunityEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommunityEventUpdateInput, CommunityEventUncheckedUpdateInput>
  }

  /**
   * CommunityEvent delete
   */
  export type CommunityEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityEvent
     */
    select?: CommunityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityEventInclude<ExtArgs> | null
    /**
     * Filter which CommunityEvent to delete.
     */
    where: CommunityEventWhereUniqueInput
  }

  /**
   * CommunityEvent deleteMany
   */
  export type CommunityEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityEvents to delete
     */
    where?: CommunityEventWhereInput
  }

  /**
   * CommunityEvent.participants
   */
  export type CommunityEvent$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipant
     */
    select?: EventParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipantInclude<ExtArgs> | null
    where?: EventParticipantWhereInput
    orderBy?: EventParticipantOrderByWithRelationInput | EventParticipantOrderByWithRelationInput[]
    cursor?: EventParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventParticipantScalarFieldEnum | EventParticipantScalarFieldEnum[]
  }

  /**
   * CommunityEvent without action
   */
  export type CommunityEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityEvent
     */
    select?: CommunityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityEventInclude<ExtArgs> | null
  }


  /**
   * Model EventParticipant
   */

  export type AggregateEventParticipant = {
    _count: EventParticipantCountAggregateOutputType | null
    _min: EventParticipantMinAggregateOutputType | null
    _max: EventParticipantMaxAggregateOutputType | null
  }

  export type EventParticipantMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    userId: string | null
    joinedAt: Date | null
  }

  export type EventParticipantMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    userId: string | null
    joinedAt: Date | null
  }

  export type EventParticipantCountAggregateOutputType = {
    id: number
    eventId: number
    userId: number
    joinedAt: number
    _all: number
  }


  export type EventParticipantMinAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    joinedAt?: true
  }

  export type EventParticipantMaxAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    joinedAt?: true
  }

  export type EventParticipantCountAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    joinedAt?: true
    _all?: true
  }

  export type EventParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventParticipant to aggregate.
     */
    where?: EventParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventParticipants to fetch.
     */
    orderBy?: EventParticipantOrderByWithRelationInput | EventParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventParticipants
    **/
    _count?: true | EventParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventParticipantMaxAggregateInputType
  }

  export type GetEventParticipantAggregateType<T extends EventParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateEventParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventParticipant[P]>
      : GetScalarType<T[P], AggregateEventParticipant[P]>
  }




  export type EventParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventParticipantWhereInput
    orderBy?: EventParticipantOrderByWithAggregationInput | EventParticipantOrderByWithAggregationInput[]
    by: EventParticipantScalarFieldEnum[] | EventParticipantScalarFieldEnum
    having?: EventParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventParticipantCountAggregateInputType | true
    _min?: EventParticipantMinAggregateInputType
    _max?: EventParticipantMaxAggregateInputType
  }

  export type EventParticipantGroupByOutputType = {
    id: string
    eventId: string
    userId: string
    joinedAt: Date
    _count: EventParticipantCountAggregateOutputType | null
    _min: EventParticipantMinAggregateOutputType | null
    _max: EventParticipantMaxAggregateOutputType | null
  }

  type GetEventParticipantGroupByPayload<T extends EventParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], EventParticipantGroupByOutputType[P]>
        }
      >
    >


  export type EventParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    userId?: boolean
    joinedAt?: boolean
    event?: boolean | CommunityEventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventParticipant"]>

  export type EventParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    userId?: boolean
    joinedAt?: boolean
    event?: boolean | CommunityEventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventParticipant"]>

  export type EventParticipantSelectScalar = {
    id?: boolean
    eventId?: boolean
    userId?: boolean
    joinedAt?: boolean
  }

  export type EventParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | CommunityEventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EventParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | CommunityEventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EventParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventParticipant"
    objects: {
      event: Prisma.$CommunityEventPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      userId: string
      joinedAt: Date
    }, ExtArgs["result"]["eventParticipant"]>
    composites: {}
  }

  type EventParticipantGetPayload<S extends boolean | null | undefined | EventParticipantDefaultArgs> = $Result.GetResult<Prisma.$EventParticipantPayload, S>

  type EventParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventParticipantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventParticipantCountAggregateInputType | true
    }

  export interface EventParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventParticipant'], meta: { name: 'EventParticipant' } }
    /**
     * Find zero or one EventParticipant that matches the filter.
     * @param {EventParticipantFindUniqueArgs} args - Arguments to find a EventParticipant
     * @example
     * // Get one EventParticipant
     * const eventParticipant = await prisma.eventParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventParticipantFindUniqueArgs>(args: SelectSubset<T, EventParticipantFindUniqueArgs<ExtArgs>>): Prisma__EventParticipantClient<$Result.GetResult<Prisma.$EventParticipantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EventParticipant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventParticipantFindUniqueOrThrowArgs} args - Arguments to find a EventParticipant
     * @example
     * // Get one EventParticipant
     * const eventParticipant = await prisma.eventParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, EventParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventParticipantClient<$Result.GetResult<Prisma.$EventParticipantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EventParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventParticipantFindFirstArgs} args - Arguments to find a EventParticipant
     * @example
     * // Get one EventParticipant
     * const eventParticipant = await prisma.eventParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventParticipantFindFirstArgs>(args?: SelectSubset<T, EventParticipantFindFirstArgs<ExtArgs>>): Prisma__EventParticipantClient<$Result.GetResult<Prisma.$EventParticipantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EventParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventParticipantFindFirstOrThrowArgs} args - Arguments to find a EventParticipant
     * @example
     * // Get one EventParticipant
     * const eventParticipant = await prisma.eventParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, EventParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventParticipantClient<$Result.GetResult<Prisma.$EventParticipantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EventParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventParticipants
     * const eventParticipants = await prisma.eventParticipant.findMany()
     * 
     * // Get first 10 EventParticipants
     * const eventParticipants = await prisma.eventParticipant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventParticipantWithIdOnly = await prisma.eventParticipant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventParticipantFindManyArgs>(args?: SelectSubset<T, EventParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventParticipantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EventParticipant.
     * @param {EventParticipantCreateArgs} args - Arguments to create a EventParticipant.
     * @example
     * // Create one EventParticipant
     * const EventParticipant = await prisma.eventParticipant.create({
     *   data: {
     *     // ... data to create a EventParticipant
     *   }
     * })
     * 
     */
    create<T extends EventParticipantCreateArgs>(args: SelectSubset<T, EventParticipantCreateArgs<ExtArgs>>): Prisma__EventParticipantClient<$Result.GetResult<Prisma.$EventParticipantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EventParticipants.
     * @param {EventParticipantCreateManyArgs} args - Arguments to create many EventParticipants.
     * @example
     * // Create many EventParticipants
     * const eventParticipant = await prisma.eventParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventParticipantCreateManyArgs>(args?: SelectSubset<T, EventParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EventParticipants and returns the data saved in the database.
     * @param {EventParticipantCreateManyAndReturnArgs} args - Arguments to create many EventParticipants.
     * @example
     * // Create many EventParticipants
     * const eventParticipant = await prisma.eventParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EventParticipants and only return the `id`
     * const eventParticipantWithIdOnly = await prisma.eventParticipant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, EventParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventParticipantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EventParticipant.
     * @param {EventParticipantDeleteArgs} args - Arguments to delete one EventParticipant.
     * @example
     * // Delete one EventParticipant
     * const EventParticipant = await prisma.eventParticipant.delete({
     *   where: {
     *     // ... filter to delete one EventParticipant
     *   }
     * })
     * 
     */
    delete<T extends EventParticipantDeleteArgs>(args: SelectSubset<T, EventParticipantDeleteArgs<ExtArgs>>): Prisma__EventParticipantClient<$Result.GetResult<Prisma.$EventParticipantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EventParticipant.
     * @param {EventParticipantUpdateArgs} args - Arguments to update one EventParticipant.
     * @example
     * // Update one EventParticipant
     * const eventParticipant = await prisma.eventParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventParticipantUpdateArgs>(args: SelectSubset<T, EventParticipantUpdateArgs<ExtArgs>>): Prisma__EventParticipantClient<$Result.GetResult<Prisma.$EventParticipantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EventParticipants.
     * @param {EventParticipantDeleteManyArgs} args - Arguments to filter EventParticipants to delete.
     * @example
     * // Delete a few EventParticipants
     * const { count } = await prisma.eventParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventParticipantDeleteManyArgs>(args?: SelectSubset<T, EventParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventParticipants
     * const eventParticipant = await prisma.eventParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventParticipantUpdateManyArgs>(args: SelectSubset<T, EventParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EventParticipant.
     * @param {EventParticipantUpsertArgs} args - Arguments to update or create a EventParticipant.
     * @example
     * // Update or create a EventParticipant
     * const eventParticipant = await prisma.eventParticipant.upsert({
     *   create: {
     *     // ... data to create a EventParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventParticipant we want to update
     *   }
     * })
     */
    upsert<T extends EventParticipantUpsertArgs>(args: SelectSubset<T, EventParticipantUpsertArgs<ExtArgs>>): Prisma__EventParticipantClient<$Result.GetResult<Prisma.$EventParticipantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EventParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventParticipantCountArgs} args - Arguments to filter EventParticipants to count.
     * @example
     * // Count the number of EventParticipants
     * const count = await prisma.eventParticipant.count({
     *   where: {
     *     // ... the filter for the EventParticipants we want to count
     *   }
     * })
    **/
    count<T extends EventParticipantCountArgs>(
      args?: Subset<T, EventParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventParticipantAggregateArgs>(args: Subset<T, EventParticipantAggregateArgs>): Prisma.PrismaPromise<GetEventParticipantAggregateType<T>>

    /**
     * Group by EventParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventParticipantGroupByArgs['orderBy'] }
        : { orderBy?: EventParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventParticipant model
   */
  readonly fields: EventParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends CommunityEventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommunityEventDefaultArgs<ExtArgs>>): Prisma__CommunityEventClient<$Result.GetResult<Prisma.$CommunityEventPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventParticipant model
   */ 
  interface EventParticipantFieldRefs {
    readonly id: FieldRef<"EventParticipant", 'String'>
    readonly eventId: FieldRef<"EventParticipant", 'String'>
    readonly userId: FieldRef<"EventParticipant", 'String'>
    readonly joinedAt: FieldRef<"EventParticipant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EventParticipant findUnique
   */
  export type EventParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipant
     */
    select?: EventParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipantInclude<ExtArgs> | null
    /**
     * Filter, which EventParticipant to fetch.
     */
    where: EventParticipantWhereUniqueInput
  }

  /**
   * EventParticipant findUniqueOrThrow
   */
  export type EventParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipant
     */
    select?: EventParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipantInclude<ExtArgs> | null
    /**
     * Filter, which EventParticipant to fetch.
     */
    where: EventParticipantWhereUniqueInput
  }

  /**
   * EventParticipant findFirst
   */
  export type EventParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipant
     */
    select?: EventParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipantInclude<ExtArgs> | null
    /**
     * Filter, which EventParticipant to fetch.
     */
    where?: EventParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventParticipants to fetch.
     */
    orderBy?: EventParticipantOrderByWithRelationInput | EventParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventParticipants.
     */
    cursor?: EventParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventParticipants.
     */
    distinct?: EventParticipantScalarFieldEnum | EventParticipantScalarFieldEnum[]
  }

  /**
   * EventParticipant findFirstOrThrow
   */
  export type EventParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipant
     */
    select?: EventParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipantInclude<ExtArgs> | null
    /**
     * Filter, which EventParticipant to fetch.
     */
    where?: EventParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventParticipants to fetch.
     */
    orderBy?: EventParticipantOrderByWithRelationInput | EventParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventParticipants.
     */
    cursor?: EventParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventParticipants.
     */
    distinct?: EventParticipantScalarFieldEnum | EventParticipantScalarFieldEnum[]
  }

  /**
   * EventParticipant findMany
   */
  export type EventParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipant
     */
    select?: EventParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipantInclude<ExtArgs> | null
    /**
     * Filter, which EventParticipants to fetch.
     */
    where?: EventParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventParticipants to fetch.
     */
    orderBy?: EventParticipantOrderByWithRelationInput | EventParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventParticipants.
     */
    cursor?: EventParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventParticipants.
     */
    skip?: number
    distinct?: EventParticipantScalarFieldEnum | EventParticipantScalarFieldEnum[]
  }

  /**
   * EventParticipant create
   */
  export type EventParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipant
     */
    select?: EventParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a EventParticipant.
     */
    data: XOR<EventParticipantCreateInput, EventParticipantUncheckedCreateInput>
  }

  /**
   * EventParticipant createMany
   */
  export type EventParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventParticipants.
     */
    data: EventParticipantCreateManyInput | EventParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventParticipant createManyAndReturn
   */
  export type EventParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipant
     */
    select?: EventParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EventParticipants.
     */
    data: EventParticipantCreateManyInput | EventParticipantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventParticipant update
   */
  export type EventParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipant
     */
    select?: EventParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a EventParticipant.
     */
    data: XOR<EventParticipantUpdateInput, EventParticipantUncheckedUpdateInput>
    /**
     * Choose, which EventParticipant to update.
     */
    where: EventParticipantWhereUniqueInput
  }

  /**
   * EventParticipant updateMany
   */
  export type EventParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventParticipants.
     */
    data: XOR<EventParticipantUpdateManyMutationInput, EventParticipantUncheckedUpdateManyInput>
    /**
     * Filter which EventParticipants to update
     */
    where?: EventParticipantWhereInput
  }

  /**
   * EventParticipant upsert
   */
  export type EventParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipant
     */
    select?: EventParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the EventParticipant to update in case it exists.
     */
    where: EventParticipantWhereUniqueInput
    /**
     * In case the EventParticipant found by the `where` argument doesn't exist, create a new EventParticipant with this data.
     */
    create: XOR<EventParticipantCreateInput, EventParticipantUncheckedCreateInput>
    /**
     * In case the EventParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventParticipantUpdateInput, EventParticipantUncheckedUpdateInput>
  }

  /**
   * EventParticipant delete
   */
  export type EventParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipant
     */
    select?: EventParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipantInclude<ExtArgs> | null
    /**
     * Filter which EventParticipant to delete.
     */
    where: EventParticipantWhereUniqueInput
  }

  /**
   * EventParticipant deleteMany
   */
  export type EventParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventParticipants to delete
     */
    where?: EventParticipantWhereInput
  }

  /**
   * EventParticipant without action
   */
  export type EventParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipant
     */
    select?: EventParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipantInclude<ExtArgs> | null
  }


  /**
   * Model BlogPost
   */

  export type AggregateBlogPost = {
    _count: BlogPostCountAggregateOutputType | null
    _avg: BlogPostAvgAggregateOutputType | null
    _sum: BlogPostSumAggregateOutputType | null
    _min: BlogPostMinAggregateOutputType | null
    _max: BlogPostMaxAggregateOutputType | null
  }

  export type BlogPostAvgAggregateOutputType = {
    views: number | null
  }

  export type BlogPostSumAggregateOutputType = {
    views: number | null
  }

  export type BlogPostMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    content: string | null
    excerpt: string | null
    photoUrl: string | null
    isPublished: boolean | null
    views: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogPostMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    content: string | null
    excerpt: string | null
    photoUrl: string | null
    isPublished: boolean | null
    views: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogPostCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    content: number
    excerpt: number
    photoUrl: number
    tags: number
    isPublished: number
    views: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BlogPostAvgAggregateInputType = {
    views?: true
  }

  export type BlogPostSumAggregateInputType = {
    views?: true
  }

  export type BlogPostMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    excerpt?: true
    photoUrl?: true
    isPublished?: true
    views?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogPostMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    excerpt?: true
    photoUrl?: true
    isPublished?: true
    views?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogPostCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    excerpt?: true
    photoUrl?: true
    tags?: true
    isPublished?: true
    views?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BlogPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPost to aggregate.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlogPosts
    **/
    _count?: true | BlogPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlogPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlogPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogPostMaxAggregateInputType
  }

  export type GetBlogPostAggregateType<T extends BlogPostAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogPost[P]>
      : GetScalarType<T[P], AggregateBlogPost[P]>
  }




  export type BlogPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostWhereInput
    orderBy?: BlogPostOrderByWithAggregationInput | BlogPostOrderByWithAggregationInput[]
    by: BlogPostScalarFieldEnum[] | BlogPostScalarFieldEnum
    having?: BlogPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogPostCountAggregateInputType | true
    _avg?: BlogPostAvgAggregateInputType
    _sum?: BlogPostSumAggregateInputType
    _min?: BlogPostMinAggregateInputType
    _max?: BlogPostMaxAggregateInputType
  }

  export type BlogPostGroupByOutputType = {
    id: string
    userId: string
    title: string
    content: string
    excerpt: string | null
    photoUrl: string | null
    tags: string[]
    isPublished: boolean
    views: number
    createdAt: Date
    updatedAt: Date
    _count: BlogPostCountAggregateOutputType | null
    _avg: BlogPostAvgAggregateOutputType | null
    _sum: BlogPostSumAggregateOutputType | null
    _min: BlogPostMinAggregateOutputType | null
    _max: BlogPostMaxAggregateOutputType | null
  }

  type GetBlogPostGroupByPayload<T extends BlogPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogPostGroupByOutputType[P]>
            : GetScalarType<T[P], BlogPostGroupByOutputType[P]>
        }
      >
    >


  export type BlogPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    excerpt?: boolean
    photoUrl?: boolean
    tags?: boolean
    isPublished?: boolean
    views?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogPost"]>

  export type BlogPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    excerpt?: boolean
    photoUrl?: boolean
    tags?: boolean
    isPublished?: boolean
    views?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogPost"]>

  export type BlogPostSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    excerpt?: boolean
    photoUrl?: boolean
    tags?: boolean
    isPublished?: boolean
    views?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BlogPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BlogPostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BlogPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlogPost"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      content: string
      excerpt: string | null
      photoUrl: string | null
      tags: string[]
      isPublished: boolean
      views: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["blogPost"]>
    composites: {}
  }

  type BlogPostGetPayload<S extends boolean | null | undefined | BlogPostDefaultArgs> = $Result.GetResult<Prisma.$BlogPostPayload, S>

  type BlogPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BlogPostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BlogPostCountAggregateInputType | true
    }

  export interface BlogPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlogPost'], meta: { name: 'BlogPost' } }
    /**
     * Find zero or one BlogPost that matches the filter.
     * @param {BlogPostFindUniqueArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogPostFindUniqueArgs>(args: SelectSubset<T, BlogPostFindUniqueArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BlogPost that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BlogPostFindUniqueOrThrowArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogPostFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BlogPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindFirstArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogPostFindFirstArgs>(args?: SelectSubset<T, BlogPostFindFirstArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BlogPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindFirstOrThrowArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogPostFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BlogPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogPosts
     * const blogPosts = await prisma.blogPost.findMany()
     * 
     * // Get first 10 BlogPosts
     * const blogPosts = await prisma.blogPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogPostWithIdOnly = await prisma.blogPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlogPostFindManyArgs>(args?: SelectSubset<T, BlogPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BlogPost.
     * @param {BlogPostCreateArgs} args - Arguments to create a BlogPost.
     * @example
     * // Create one BlogPost
     * const BlogPost = await prisma.blogPost.create({
     *   data: {
     *     // ... data to create a BlogPost
     *   }
     * })
     * 
     */
    create<T extends BlogPostCreateArgs>(args: SelectSubset<T, BlogPostCreateArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BlogPosts.
     * @param {BlogPostCreateManyArgs} args - Arguments to create many BlogPosts.
     * @example
     * // Create many BlogPosts
     * const blogPost = await prisma.blogPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogPostCreateManyArgs>(args?: SelectSubset<T, BlogPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlogPosts and returns the data saved in the database.
     * @param {BlogPostCreateManyAndReturnArgs} args - Arguments to create many BlogPosts.
     * @example
     * // Create many BlogPosts
     * const blogPost = await prisma.blogPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlogPosts and only return the `id`
     * const blogPostWithIdOnly = await prisma.blogPost.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlogPostCreateManyAndReturnArgs>(args?: SelectSubset<T, BlogPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BlogPost.
     * @param {BlogPostDeleteArgs} args - Arguments to delete one BlogPost.
     * @example
     * // Delete one BlogPost
     * const BlogPost = await prisma.blogPost.delete({
     *   where: {
     *     // ... filter to delete one BlogPost
     *   }
     * })
     * 
     */
    delete<T extends BlogPostDeleteArgs>(args: SelectSubset<T, BlogPostDeleteArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BlogPost.
     * @param {BlogPostUpdateArgs} args - Arguments to update one BlogPost.
     * @example
     * // Update one BlogPost
     * const blogPost = await prisma.blogPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogPostUpdateArgs>(args: SelectSubset<T, BlogPostUpdateArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BlogPosts.
     * @param {BlogPostDeleteManyArgs} args - Arguments to filter BlogPosts to delete.
     * @example
     * // Delete a few BlogPosts
     * const { count } = await prisma.blogPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogPostDeleteManyArgs>(args?: SelectSubset<T, BlogPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogPosts
     * const blogPost = await prisma.blogPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogPostUpdateManyArgs>(args: SelectSubset<T, BlogPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BlogPost.
     * @param {BlogPostUpsertArgs} args - Arguments to update or create a BlogPost.
     * @example
     * // Update or create a BlogPost
     * const blogPost = await prisma.blogPost.upsert({
     *   create: {
     *     // ... data to create a BlogPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogPost we want to update
     *   }
     * })
     */
    upsert<T extends BlogPostUpsertArgs>(args: SelectSubset<T, BlogPostUpsertArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BlogPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostCountArgs} args - Arguments to filter BlogPosts to count.
     * @example
     * // Count the number of BlogPosts
     * const count = await prisma.blogPost.count({
     *   where: {
     *     // ... the filter for the BlogPosts we want to count
     *   }
     * })
    **/
    count<T extends BlogPostCountArgs>(
      args?: Subset<T, BlogPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlogPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogPostAggregateArgs>(args: Subset<T, BlogPostAggregateArgs>): Prisma.PrismaPromise<GetBlogPostAggregateType<T>>

    /**
     * Group by BlogPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogPostGroupByArgs['orderBy'] }
        : { orderBy?: BlogPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlogPost model
   */
  readonly fields: BlogPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlogPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlogPost model
   */ 
  interface BlogPostFieldRefs {
    readonly id: FieldRef<"BlogPost", 'String'>
    readonly userId: FieldRef<"BlogPost", 'String'>
    readonly title: FieldRef<"BlogPost", 'String'>
    readonly content: FieldRef<"BlogPost", 'String'>
    readonly excerpt: FieldRef<"BlogPost", 'String'>
    readonly photoUrl: FieldRef<"BlogPost", 'String'>
    readonly tags: FieldRef<"BlogPost", 'String[]'>
    readonly isPublished: FieldRef<"BlogPost", 'Boolean'>
    readonly views: FieldRef<"BlogPost", 'Int'>
    readonly createdAt: FieldRef<"BlogPost", 'DateTime'>
    readonly updatedAt: FieldRef<"BlogPost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlogPost findUnique
   */
  export type BlogPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost findUniqueOrThrow
   */
  export type BlogPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost findFirst
   */
  export type BlogPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPosts.
     */
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost findFirstOrThrow
   */
  export type BlogPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPosts.
     */
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost findMany
   */
  export type BlogPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPosts to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost create
   */
  export type BlogPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The data needed to create a BlogPost.
     */
    data: XOR<BlogPostCreateInput, BlogPostUncheckedCreateInput>
  }

  /**
   * BlogPost createMany
   */
  export type BlogPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlogPosts.
     */
    data: BlogPostCreateManyInput | BlogPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogPost createManyAndReturn
   */
  export type BlogPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BlogPosts.
     */
    data: BlogPostCreateManyInput | BlogPostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogPost update
   */
  export type BlogPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The data needed to update a BlogPost.
     */
    data: XOR<BlogPostUpdateInput, BlogPostUncheckedUpdateInput>
    /**
     * Choose, which BlogPost to update.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost updateMany
   */
  export type BlogPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlogPosts.
     */
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyInput>
    /**
     * Filter which BlogPosts to update
     */
    where?: BlogPostWhereInput
  }

  /**
   * BlogPost upsert
   */
  export type BlogPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The filter to search for the BlogPost to update in case it exists.
     */
    where: BlogPostWhereUniqueInput
    /**
     * In case the BlogPost found by the `where` argument doesn't exist, create a new BlogPost with this data.
     */
    create: XOR<BlogPostCreateInput, BlogPostUncheckedCreateInput>
    /**
     * In case the BlogPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogPostUpdateInput, BlogPostUncheckedUpdateInput>
  }

  /**
   * BlogPost delete
   */
  export type BlogPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter which BlogPost to delete.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost deleteMany
   */
  export type BlogPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPosts to delete
     */
    where?: BlogPostWhereInput
  }

  /**
   * BlogPost without action
   */
  export type BlogPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
  }


  /**
   * Model MatchScore
   */

  export type AggregateMatchScore = {
    _count: MatchScoreCountAggregateOutputType | null
    _avg: MatchScoreAvgAggregateOutputType | null
    _sum: MatchScoreSumAggregateOutputType | null
    _min: MatchScoreMinAggregateOutputType | null
    _max: MatchScoreMaxAggregateOutputType | null
  }

  export type MatchScoreAvgAggregateOutputType = {
    overallScore: number | null
    religionScore: number | null
    educationScore: number | null
    lifestyleScore: number | null
    locationScore: number | null
    familyScore: number | null
  }

  export type MatchScoreSumAggregateOutputType = {
    overallScore: number | null
    religionScore: number | null
    educationScore: number | null
    lifestyleScore: number | null
    locationScore: number | null
    familyScore: number | null
  }

  export type MatchScoreMinAggregateOutputType = {
    id: string | null
    userId: string | null
    matchedUserId: string | null
    overallScore: number | null
    religionScore: number | null
    educationScore: number | null
    lifestyleScore: number | null
    locationScore: number | null
    familyScore: number | null
    isReverseMatch: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatchScoreMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    matchedUserId: string | null
    overallScore: number | null
    religionScore: number | null
    educationScore: number | null
    lifestyleScore: number | null
    locationScore: number | null
    familyScore: number | null
    isReverseMatch: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatchScoreCountAggregateOutputType = {
    id: number
    userId: number
    matchedUserId: number
    overallScore: number
    religionScore: number
    educationScore: number
    lifestyleScore: number
    locationScore: number
    familyScore: number
    matchReasons: number
    isReverseMatch: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MatchScoreAvgAggregateInputType = {
    overallScore?: true
    religionScore?: true
    educationScore?: true
    lifestyleScore?: true
    locationScore?: true
    familyScore?: true
  }

  export type MatchScoreSumAggregateInputType = {
    overallScore?: true
    religionScore?: true
    educationScore?: true
    lifestyleScore?: true
    locationScore?: true
    familyScore?: true
  }

  export type MatchScoreMinAggregateInputType = {
    id?: true
    userId?: true
    matchedUserId?: true
    overallScore?: true
    religionScore?: true
    educationScore?: true
    lifestyleScore?: true
    locationScore?: true
    familyScore?: true
    isReverseMatch?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatchScoreMaxAggregateInputType = {
    id?: true
    userId?: true
    matchedUserId?: true
    overallScore?: true
    religionScore?: true
    educationScore?: true
    lifestyleScore?: true
    locationScore?: true
    familyScore?: true
    isReverseMatch?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatchScoreCountAggregateInputType = {
    id?: true
    userId?: true
    matchedUserId?: true
    overallScore?: true
    religionScore?: true
    educationScore?: true
    lifestyleScore?: true
    locationScore?: true
    familyScore?: true
    matchReasons?: true
    isReverseMatch?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MatchScoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchScore to aggregate.
     */
    where?: MatchScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchScores to fetch.
     */
    orderBy?: MatchScoreOrderByWithRelationInput | MatchScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatchScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MatchScores
    **/
    _count?: true | MatchScoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatchScoreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatchScoreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatchScoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatchScoreMaxAggregateInputType
  }

  export type GetMatchScoreAggregateType<T extends MatchScoreAggregateArgs> = {
        [P in keyof T & keyof AggregateMatchScore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatchScore[P]>
      : GetScalarType<T[P], AggregateMatchScore[P]>
  }




  export type MatchScoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchScoreWhereInput
    orderBy?: MatchScoreOrderByWithAggregationInput | MatchScoreOrderByWithAggregationInput[]
    by: MatchScoreScalarFieldEnum[] | MatchScoreScalarFieldEnum
    having?: MatchScoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatchScoreCountAggregateInputType | true
    _avg?: MatchScoreAvgAggregateInputType
    _sum?: MatchScoreSumAggregateInputType
    _min?: MatchScoreMinAggregateInputType
    _max?: MatchScoreMaxAggregateInputType
  }

  export type MatchScoreGroupByOutputType = {
    id: string
    userId: string
    matchedUserId: string
    overallScore: number
    religionScore: number | null
    educationScore: number | null
    lifestyleScore: number | null
    locationScore: number | null
    familyScore: number | null
    matchReasons: JsonValue | null
    isReverseMatch: boolean
    createdAt: Date
    updatedAt: Date
    _count: MatchScoreCountAggregateOutputType | null
    _avg: MatchScoreAvgAggregateOutputType | null
    _sum: MatchScoreSumAggregateOutputType | null
    _min: MatchScoreMinAggregateOutputType | null
    _max: MatchScoreMaxAggregateOutputType | null
  }

  type GetMatchScoreGroupByPayload<T extends MatchScoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatchScoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatchScoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatchScoreGroupByOutputType[P]>
            : GetScalarType<T[P], MatchScoreGroupByOutputType[P]>
        }
      >
    >


  export type MatchScoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    matchedUserId?: boolean
    overallScore?: boolean
    religionScore?: boolean
    educationScore?: boolean
    lifestyleScore?: boolean
    locationScore?: boolean
    familyScore?: boolean
    matchReasons?: boolean
    isReverseMatch?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    matchedUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matchScore"]>

  export type MatchScoreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    matchedUserId?: boolean
    overallScore?: boolean
    religionScore?: boolean
    educationScore?: boolean
    lifestyleScore?: boolean
    locationScore?: boolean
    familyScore?: boolean
    matchReasons?: boolean
    isReverseMatch?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    matchedUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matchScore"]>

  export type MatchScoreSelectScalar = {
    id?: boolean
    userId?: boolean
    matchedUserId?: boolean
    overallScore?: boolean
    religionScore?: boolean
    educationScore?: boolean
    lifestyleScore?: boolean
    locationScore?: boolean
    familyScore?: boolean
    matchReasons?: boolean
    isReverseMatch?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MatchScoreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    matchedUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MatchScoreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    matchedUser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MatchScorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MatchScore"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      matchedUser: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      matchedUserId: string
      overallScore: number
      religionScore: number | null
      educationScore: number | null
      lifestyleScore: number | null
      locationScore: number | null
      familyScore: number | null
      matchReasons: Prisma.JsonValue | null
      isReverseMatch: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["matchScore"]>
    composites: {}
  }

  type MatchScoreGetPayload<S extends boolean | null | undefined | MatchScoreDefaultArgs> = $Result.GetResult<Prisma.$MatchScorePayload, S>

  type MatchScoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MatchScoreFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MatchScoreCountAggregateInputType | true
    }

  export interface MatchScoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MatchScore'], meta: { name: 'MatchScore' } }
    /**
     * Find zero or one MatchScore that matches the filter.
     * @param {MatchScoreFindUniqueArgs} args - Arguments to find a MatchScore
     * @example
     * // Get one MatchScore
     * const matchScore = await prisma.matchScore.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatchScoreFindUniqueArgs>(args: SelectSubset<T, MatchScoreFindUniqueArgs<ExtArgs>>): Prisma__MatchScoreClient<$Result.GetResult<Prisma.$MatchScorePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MatchScore that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MatchScoreFindUniqueOrThrowArgs} args - Arguments to find a MatchScore
     * @example
     * // Get one MatchScore
     * const matchScore = await prisma.matchScore.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatchScoreFindUniqueOrThrowArgs>(args: SelectSubset<T, MatchScoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatchScoreClient<$Result.GetResult<Prisma.$MatchScorePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MatchScore that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchScoreFindFirstArgs} args - Arguments to find a MatchScore
     * @example
     * // Get one MatchScore
     * const matchScore = await prisma.matchScore.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatchScoreFindFirstArgs>(args?: SelectSubset<T, MatchScoreFindFirstArgs<ExtArgs>>): Prisma__MatchScoreClient<$Result.GetResult<Prisma.$MatchScorePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MatchScore that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchScoreFindFirstOrThrowArgs} args - Arguments to find a MatchScore
     * @example
     * // Get one MatchScore
     * const matchScore = await prisma.matchScore.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatchScoreFindFirstOrThrowArgs>(args?: SelectSubset<T, MatchScoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatchScoreClient<$Result.GetResult<Prisma.$MatchScorePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MatchScores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchScoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MatchScores
     * const matchScores = await prisma.matchScore.findMany()
     * 
     * // Get first 10 MatchScores
     * const matchScores = await prisma.matchScore.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matchScoreWithIdOnly = await prisma.matchScore.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MatchScoreFindManyArgs>(args?: SelectSubset<T, MatchScoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchScorePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MatchScore.
     * @param {MatchScoreCreateArgs} args - Arguments to create a MatchScore.
     * @example
     * // Create one MatchScore
     * const MatchScore = await prisma.matchScore.create({
     *   data: {
     *     // ... data to create a MatchScore
     *   }
     * })
     * 
     */
    create<T extends MatchScoreCreateArgs>(args: SelectSubset<T, MatchScoreCreateArgs<ExtArgs>>): Prisma__MatchScoreClient<$Result.GetResult<Prisma.$MatchScorePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MatchScores.
     * @param {MatchScoreCreateManyArgs} args - Arguments to create many MatchScores.
     * @example
     * // Create many MatchScores
     * const matchScore = await prisma.matchScore.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatchScoreCreateManyArgs>(args?: SelectSubset<T, MatchScoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MatchScores and returns the data saved in the database.
     * @param {MatchScoreCreateManyAndReturnArgs} args - Arguments to create many MatchScores.
     * @example
     * // Create many MatchScores
     * const matchScore = await prisma.matchScore.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MatchScores and only return the `id`
     * const matchScoreWithIdOnly = await prisma.matchScore.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MatchScoreCreateManyAndReturnArgs>(args?: SelectSubset<T, MatchScoreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchScorePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MatchScore.
     * @param {MatchScoreDeleteArgs} args - Arguments to delete one MatchScore.
     * @example
     * // Delete one MatchScore
     * const MatchScore = await prisma.matchScore.delete({
     *   where: {
     *     // ... filter to delete one MatchScore
     *   }
     * })
     * 
     */
    delete<T extends MatchScoreDeleteArgs>(args: SelectSubset<T, MatchScoreDeleteArgs<ExtArgs>>): Prisma__MatchScoreClient<$Result.GetResult<Prisma.$MatchScorePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MatchScore.
     * @param {MatchScoreUpdateArgs} args - Arguments to update one MatchScore.
     * @example
     * // Update one MatchScore
     * const matchScore = await prisma.matchScore.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatchScoreUpdateArgs>(args: SelectSubset<T, MatchScoreUpdateArgs<ExtArgs>>): Prisma__MatchScoreClient<$Result.GetResult<Prisma.$MatchScorePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MatchScores.
     * @param {MatchScoreDeleteManyArgs} args - Arguments to filter MatchScores to delete.
     * @example
     * // Delete a few MatchScores
     * const { count } = await prisma.matchScore.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatchScoreDeleteManyArgs>(args?: SelectSubset<T, MatchScoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatchScores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchScoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MatchScores
     * const matchScore = await prisma.matchScore.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatchScoreUpdateManyArgs>(args: SelectSubset<T, MatchScoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MatchScore.
     * @param {MatchScoreUpsertArgs} args - Arguments to update or create a MatchScore.
     * @example
     * // Update or create a MatchScore
     * const matchScore = await prisma.matchScore.upsert({
     *   create: {
     *     // ... data to create a MatchScore
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MatchScore we want to update
     *   }
     * })
     */
    upsert<T extends MatchScoreUpsertArgs>(args: SelectSubset<T, MatchScoreUpsertArgs<ExtArgs>>): Prisma__MatchScoreClient<$Result.GetResult<Prisma.$MatchScorePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MatchScores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchScoreCountArgs} args - Arguments to filter MatchScores to count.
     * @example
     * // Count the number of MatchScores
     * const count = await prisma.matchScore.count({
     *   where: {
     *     // ... the filter for the MatchScores we want to count
     *   }
     * })
    **/
    count<T extends MatchScoreCountArgs>(
      args?: Subset<T, MatchScoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatchScoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MatchScore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchScoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatchScoreAggregateArgs>(args: Subset<T, MatchScoreAggregateArgs>): Prisma.PrismaPromise<GetMatchScoreAggregateType<T>>

    /**
     * Group by MatchScore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchScoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatchScoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatchScoreGroupByArgs['orderBy'] }
        : { orderBy?: MatchScoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatchScoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatchScoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MatchScore model
   */
  readonly fields: MatchScoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MatchScore.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatchScoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    matchedUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MatchScore model
   */ 
  interface MatchScoreFieldRefs {
    readonly id: FieldRef<"MatchScore", 'String'>
    readonly userId: FieldRef<"MatchScore", 'String'>
    readonly matchedUserId: FieldRef<"MatchScore", 'String'>
    readonly overallScore: FieldRef<"MatchScore", 'Int'>
    readonly religionScore: FieldRef<"MatchScore", 'Int'>
    readonly educationScore: FieldRef<"MatchScore", 'Int'>
    readonly lifestyleScore: FieldRef<"MatchScore", 'Int'>
    readonly locationScore: FieldRef<"MatchScore", 'Int'>
    readonly familyScore: FieldRef<"MatchScore", 'Int'>
    readonly matchReasons: FieldRef<"MatchScore", 'Json'>
    readonly isReverseMatch: FieldRef<"MatchScore", 'Boolean'>
    readonly createdAt: FieldRef<"MatchScore", 'DateTime'>
    readonly updatedAt: FieldRef<"MatchScore", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MatchScore findUnique
   */
  export type MatchScoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchScore
     */
    select?: MatchScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchScoreInclude<ExtArgs> | null
    /**
     * Filter, which MatchScore to fetch.
     */
    where: MatchScoreWhereUniqueInput
  }

  /**
   * MatchScore findUniqueOrThrow
   */
  export type MatchScoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchScore
     */
    select?: MatchScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchScoreInclude<ExtArgs> | null
    /**
     * Filter, which MatchScore to fetch.
     */
    where: MatchScoreWhereUniqueInput
  }

  /**
   * MatchScore findFirst
   */
  export type MatchScoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchScore
     */
    select?: MatchScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchScoreInclude<ExtArgs> | null
    /**
     * Filter, which MatchScore to fetch.
     */
    where?: MatchScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchScores to fetch.
     */
    orderBy?: MatchScoreOrderByWithRelationInput | MatchScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchScores.
     */
    cursor?: MatchScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchScores.
     */
    distinct?: MatchScoreScalarFieldEnum | MatchScoreScalarFieldEnum[]
  }

  /**
   * MatchScore findFirstOrThrow
   */
  export type MatchScoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchScore
     */
    select?: MatchScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchScoreInclude<ExtArgs> | null
    /**
     * Filter, which MatchScore to fetch.
     */
    where?: MatchScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchScores to fetch.
     */
    orderBy?: MatchScoreOrderByWithRelationInput | MatchScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchScores.
     */
    cursor?: MatchScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchScores.
     */
    distinct?: MatchScoreScalarFieldEnum | MatchScoreScalarFieldEnum[]
  }

  /**
   * MatchScore findMany
   */
  export type MatchScoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchScore
     */
    select?: MatchScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchScoreInclude<ExtArgs> | null
    /**
     * Filter, which MatchScores to fetch.
     */
    where?: MatchScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchScores to fetch.
     */
    orderBy?: MatchScoreOrderByWithRelationInput | MatchScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MatchScores.
     */
    cursor?: MatchScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchScores.
     */
    skip?: number
    distinct?: MatchScoreScalarFieldEnum | MatchScoreScalarFieldEnum[]
  }

  /**
   * MatchScore create
   */
  export type MatchScoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchScore
     */
    select?: MatchScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchScoreInclude<ExtArgs> | null
    /**
     * The data needed to create a MatchScore.
     */
    data: XOR<MatchScoreCreateInput, MatchScoreUncheckedCreateInput>
  }

  /**
   * MatchScore createMany
   */
  export type MatchScoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MatchScores.
     */
    data: MatchScoreCreateManyInput | MatchScoreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MatchScore createManyAndReturn
   */
  export type MatchScoreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchScore
     */
    select?: MatchScoreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MatchScores.
     */
    data: MatchScoreCreateManyInput | MatchScoreCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchScoreIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MatchScore update
   */
  export type MatchScoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchScore
     */
    select?: MatchScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchScoreInclude<ExtArgs> | null
    /**
     * The data needed to update a MatchScore.
     */
    data: XOR<MatchScoreUpdateInput, MatchScoreUncheckedUpdateInput>
    /**
     * Choose, which MatchScore to update.
     */
    where: MatchScoreWhereUniqueInput
  }

  /**
   * MatchScore updateMany
   */
  export type MatchScoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MatchScores.
     */
    data: XOR<MatchScoreUpdateManyMutationInput, MatchScoreUncheckedUpdateManyInput>
    /**
     * Filter which MatchScores to update
     */
    where?: MatchScoreWhereInput
  }

  /**
   * MatchScore upsert
   */
  export type MatchScoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchScore
     */
    select?: MatchScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchScoreInclude<ExtArgs> | null
    /**
     * The filter to search for the MatchScore to update in case it exists.
     */
    where: MatchScoreWhereUniqueInput
    /**
     * In case the MatchScore found by the `where` argument doesn't exist, create a new MatchScore with this data.
     */
    create: XOR<MatchScoreCreateInput, MatchScoreUncheckedCreateInput>
    /**
     * In case the MatchScore was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatchScoreUpdateInput, MatchScoreUncheckedUpdateInput>
  }

  /**
   * MatchScore delete
   */
  export type MatchScoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchScore
     */
    select?: MatchScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchScoreInclude<ExtArgs> | null
    /**
     * Filter which MatchScore to delete.
     */
    where: MatchScoreWhereUniqueInput
  }

  /**
   * MatchScore deleteMany
   */
  export type MatchScoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchScores to delete
     */
    where?: MatchScoreWhereInput
  }

  /**
   * MatchScore without action
   */
  export type MatchScoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchScore
     */
    select?: MatchScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchScoreInclude<ExtArgs> | null
  }


  /**
   * Model SearchHistory
   */

  export type AggregateSearchHistory = {
    _count: SearchHistoryCountAggregateOutputType | null
    _min: SearchHistoryMinAggregateOutputType | null
    _max: SearchHistoryMaxAggregateOutputType | null
  }

  export type SearchHistoryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    profileId: string | null
    searchQuery: string | null
    createdAt: Date | null
  }

  export type SearchHistoryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    profileId: string | null
    searchQuery: string | null
    createdAt: Date | null
  }

  export type SearchHistoryCountAggregateOutputType = {
    id: number
    userId: number
    profileId: number
    searchQuery: number
    filters: number
    createdAt: number
    _all: number
  }


  export type SearchHistoryMinAggregateInputType = {
    id?: true
    userId?: true
    profileId?: true
    searchQuery?: true
    createdAt?: true
  }

  export type SearchHistoryMaxAggregateInputType = {
    id?: true
    userId?: true
    profileId?: true
    searchQuery?: true
    createdAt?: true
  }

  export type SearchHistoryCountAggregateInputType = {
    id?: true
    userId?: true
    profileId?: true
    searchQuery?: true
    filters?: true
    createdAt?: true
    _all?: true
  }

  export type SearchHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchHistory to aggregate.
     */
    where?: SearchHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchHistories to fetch.
     */
    orderBy?: SearchHistoryOrderByWithRelationInput | SearchHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SearchHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SearchHistories
    **/
    _count?: true | SearchHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SearchHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SearchHistoryMaxAggregateInputType
  }

  export type GetSearchHistoryAggregateType<T extends SearchHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateSearchHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSearchHistory[P]>
      : GetScalarType<T[P], AggregateSearchHistory[P]>
  }




  export type SearchHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchHistoryWhereInput
    orderBy?: SearchHistoryOrderByWithAggregationInput | SearchHistoryOrderByWithAggregationInput[]
    by: SearchHistoryScalarFieldEnum[] | SearchHistoryScalarFieldEnum
    having?: SearchHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SearchHistoryCountAggregateInputType | true
    _min?: SearchHistoryMinAggregateInputType
    _max?: SearchHistoryMaxAggregateInputType
  }

  export type SearchHistoryGroupByOutputType = {
    id: string
    userId: string
    profileId: string | null
    searchQuery: string | null
    filters: JsonValue | null
    createdAt: Date
    _count: SearchHistoryCountAggregateOutputType | null
    _min: SearchHistoryMinAggregateOutputType | null
    _max: SearchHistoryMaxAggregateOutputType | null
  }

  type GetSearchHistoryGroupByPayload<T extends SearchHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SearchHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SearchHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SearchHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], SearchHistoryGroupByOutputType[P]>
        }
      >
    >


  export type SearchHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    profileId?: boolean
    searchQuery?: boolean
    filters?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["searchHistory"]>

  export type SearchHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    profileId?: boolean
    searchQuery?: boolean
    filters?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["searchHistory"]>

  export type SearchHistorySelectScalar = {
    id?: boolean
    userId?: boolean
    profileId?: boolean
    searchQuery?: boolean
    filters?: boolean
    createdAt?: boolean
  }

  export type SearchHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SearchHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SearchHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SearchHistory"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      profileId: string | null
      searchQuery: string | null
      filters: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["searchHistory"]>
    composites: {}
  }

  type SearchHistoryGetPayload<S extends boolean | null | undefined | SearchHistoryDefaultArgs> = $Result.GetResult<Prisma.$SearchHistoryPayload, S>

  type SearchHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SearchHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SearchHistoryCountAggregateInputType | true
    }

  export interface SearchHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SearchHistory'], meta: { name: 'SearchHistory' } }
    /**
     * Find zero or one SearchHistory that matches the filter.
     * @param {SearchHistoryFindUniqueArgs} args - Arguments to find a SearchHistory
     * @example
     * // Get one SearchHistory
     * const searchHistory = await prisma.searchHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SearchHistoryFindUniqueArgs>(args: SelectSubset<T, SearchHistoryFindUniqueArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SearchHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SearchHistoryFindUniqueOrThrowArgs} args - Arguments to find a SearchHistory
     * @example
     * // Get one SearchHistory
     * const searchHistory = await prisma.searchHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SearchHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, SearchHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SearchHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryFindFirstArgs} args - Arguments to find a SearchHistory
     * @example
     * // Get one SearchHistory
     * const searchHistory = await prisma.searchHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SearchHistoryFindFirstArgs>(args?: SelectSubset<T, SearchHistoryFindFirstArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SearchHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryFindFirstOrThrowArgs} args - Arguments to find a SearchHistory
     * @example
     * // Get one SearchHistory
     * const searchHistory = await prisma.searchHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SearchHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, SearchHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SearchHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SearchHistories
     * const searchHistories = await prisma.searchHistory.findMany()
     * 
     * // Get first 10 SearchHistories
     * const searchHistories = await prisma.searchHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const searchHistoryWithIdOnly = await prisma.searchHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SearchHistoryFindManyArgs>(args?: SelectSubset<T, SearchHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SearchHistory.
     * @param {SearchHistoryCreateArgs} args - Arguments to create a SearchHistory.
     * @example
     * // Create one SearchHistory
     * const SearchHistory = await prisma.searchHistory.create({
     *   data: {
     *     // ... data to create a SearchHistory
     *   }
     * })
     * 
     */
    create<T extends SearchHistoryCreateArgs>(args: SelectSubset<T, SearchHistoryCreateArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SearchHistories.
     * @param {SearchHistoryCreateManyArgs} args - Arguments to create many SearchHistories.
     * @example
     * // Create many SearchHistories
     * const searchHistory = await prisma.searchHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SearchHistoryCreateManyArgs>(args?: SelectSubset<T, SearchHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SearchHistories and returns the data saved in the database.
     * @param {SearchHistoryCreateManyAndReturnArgs} args - Arguments to create many SearchHistories.
     * @example
     * // Create many SearchHistories
     * const searchHistory = await prisma.searchHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SearchHistories and only return the `id`
     * const searchHistoryWithIdOnly = await prisma.searchHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SearchHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, SearchHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SearchHistory.
     * @param {SearchHistoryDeleteArgs} args - Arguments to delete one SearchHistory.
     * @example
     * // Delete one SearchHistory
     * const SearchHistory = await prisma.searchHistory.delete({
     *   where: {
     *     // ... filter to delete one SearchHistory
     *   }
     * })
     * 
     */
    delete<T extends SearchHistoryDeleteArgs>(args: SelectSubset<T, SearchHistoryDeleteArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SearchHistory.
     * @param {SearchHistoryUpdateArgs} args - Arguments to update one SearchHistory.
     * @example
     * // Update one SearchHistory
     * const searchHistory = await prisma.searchHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SearchHistoryUpdateArgs>(args: SelectSubset<T, SearchHistoryUpdateArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SearchHistories.
     * @param {SearchHistoryDeleteManyArgs} args - Arguments to filter SearchHistories to delete.
     * @example
     * // Delete a few SearchHistories
     * const { count } = await prisma.searchHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SearchHistoryDeleteManyArgs>(args?: SelectSubset<T, SearchHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SearchHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SearchHistories
     * const searchHistory = await prisma.searchHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SearchHistoryUpdateManyArgs>(args: SelectSubset<T, SearchHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SearchHistory.
     * @param {SearchHistoryUpsertArgs} args - Arguments to update or create a SearchHistory.
     * @example
     * // Update or create a SearchHistory
     * const searchHistory = await prisma.searchHistory.upsert({
     *   create: {
     *     // ... data to create a SearchHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SearchHistory we want to update
     *   }
     * })
     */
    upsert<T extends SearchHistoryUpsertArgs>(args: SelectSubset<T, SearchHistoryUpsertArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SearchHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryCountArgs} args - Arguments to filter SearchHistories to count.
     * @example
     * // Count the number of SearchHistories
     * const count = await prisma.searchHistory.count({
     *   where: {
     *     // ... the filter for the SearchHistories we want to count
     *   }
     * })
    **/
    count<T extends SearchHistoryCountArgs>(
      args?: Subset<T, SearchHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SearchHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SearchHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SearchHistoryAggregateArgs>(args: Subset<T, SearchHistoryAggregateArgs>): Prisma.PrismaPromise<GetSearchHistoryAggregateType<T>>

    /**
     * Group by SearchHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SearchHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SearchHistoryGroupByArgs['orderBy'] }
        : { orderBy?: SearchHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SearchHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSearchHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SearchHistory model
   */
  readonly fields: SearchHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SearchHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SearchHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SearchHistory model
   */ 
  interface SearchHistoryFieldRefs {
    readonly id: FieldRef<"SearchHistory", 'String'>
    readonly userId: FieldRef<"SearchHistory", 'String'>
    readonly profileId: FieldRef<"SearchHistory", 'String'>
    readonly searchQuery: FieldRef<"SearchHistory", 'String'>
    readonly filters: FieldRef<"SearchHistory", 'Json'>
    readonly createdAt: FieldRef<"SearchHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SearchHistory findUnique
   */
  export type SearchHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SearchHistory to fetch.
     */
    where: SearchHistoryWhereUniqueInput
  }

  /**
   * SearchHistory findUniqueOrThrow
   */
  export type SearchHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SearchHistory to fetch.
     */
    where: SearchHistoryWhereUniqueInput
  }

  /**
   * SearchHistory findFirst
   */
  export type SearchHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SearchHistory to fetch.
     */
    where?: SearchHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchHistories to fetch.
     */
    orderBy?: SearchHistoryOrderByWithRelationInput | SearchHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchHistories.
     */
    cursor?: SearchHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchHistories.
     */
    distinct?: SearchHistoryScalarFieldEnum | SearchHistoryScalarFieldEnum[]
  }

  /**
   * SearchHistory findFirstOrThrow
   */
  export type SearchHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SearchHistory to fetch.
     */
    where?: SearchHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchHistories to fetch.
     */
    orderBy?: SearchHistoryOrderByWithRelationInput | SearchHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchHistories.
     */
    cursor?: SearchHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchHistories.
     */
    distinct?: SearchHistoryScalarFieldEnum | SearchHistoryScalarFieldEnum[]
  }

  /**
   * SearchHistory findMany
   */
  export type SearchHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SearchHistories to fetch.
     */
    where?: SearchHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchHistories to fetch.
     */
    orderBy?: SearchHistoryOrderByWithRelationInput | SearchHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SearchHistories.
     */
    cursor?: SearchHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchHistories.
     */
    skip?: number
    distinct?: SearchHistoryScalarFieldEnum | SearchHistoryScalarFieldEnum[]
  }

  /**
   * SearchHistory create
   */
  export type SearchHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a SearchHistory.
     */
    data: XOR<SearchHistoryCreateInput, SearchHistoryUncheckedCreateInput>
  }

  /**
   * SearchHistory createMany
   */
  export type SearchHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SearchHistories.
     */
    data: SearchHistoryCreateManyInput | SearchHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SearchHistory createManyAndReturn
   */
  export type SearchHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SearchHistories.
     */
    data: SearchHistoryCreateManyInput | SearchHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SearchHistory update
   */
  export type SearchHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a SearchHistory.
     */
    data: XOR<SearchHistoryUpdateInput, SearchHistoryUncheckedUpdateInput>
    /**
     * Choose, which SearchHistory to update.
     */
    where: SearchHistoryWhereUniqueInput
  }

  /**
   * SearchHistory updateMany
   */
  export type SearchHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SearchHistories.
     */
    data: XOR<SearchHistoryUpdateManyMutationInput, SearchHistoryUncheckedUpdateManyInput>
    /**
     * Filter which SearchHistories to update
     */
    where?: SearchHistoryWhereInput
  }

  /**
   * SearchHistory upsert
   */
  export type SearchHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the SearchHistory to update in case it exists.
     */
    where: SearchHistoryWhereUniqueInput
    /**
     * In case the SearchHistory found by the `where` argument doesn't exist, create a new SearchHistory with this data.
     */
    create: XOR<SearchHistoryCreateInput, SearchHistoryUncheckedCreateInput>
    /**
     * In case the SearchHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SearchHistoryUpdateInput, SearchHistoryUncheckedUpdateInput>
  }

  /**
   * SearchHistory delete
   */
  export type SearchHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter which SearchHistory to delete.
     */
    where: SearchHistoryWhereUniqueInput
  }

  /**
   * SearchHistory deleteMany
   */
  export type SearchHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchHistories to delete
     */
    where?: SearchHistoryWhereInput
  }

  /**
   * SearchHistory without action
   */
  export type SearchHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
  }


  /**
   * Model MessageTemplate
   */

  export type AggregateMessageTemplate = {
    _count: MessageTemplateCountAggregateOutputType | null
    _min: MessageTemplateMinAggregateOutputType | null
    _max: MessageTemplateMaxAggregateOutputType | null
  }

  export type MessageTemplateMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    content: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageTemplateMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    content: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageTemplateCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    content: number
    category: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MessageTemplateMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    content?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageTemplateMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    content?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageTemplateCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    content?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MessageTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageTemplate to aggregate.
     */
    where?: MessageTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageTemplates to fetch.
     */
    orderBy?: MessageTemplateOrderByWithRelationInput | MessageTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageTemplates
    **/
    _count?: true | MessageTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageTemplateMaxAggregateInputType
  }

  export type GetMessageTemplateAggregateType<T extends MessageTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageTemplate[P]>
      : GetScalarType<T[P], AggregateMessageTemplate[P]>
  }




  export type MessageTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageTemplateWhereInput
    orderBy?: MessageTemplateOrderByWithAggregationInput | MessageTemplateOrderByWithAggregationInput[]
    by: MessageTemplateScalarFieldEnum[] | MessageTemplateScalarFieldEnum
    having?: MessageTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageTemplateCountAggregateInputType | true
    _min?: MessageTemplateMinAggregateInputType
    _max?: MessageTemplateMaxAggregateInputType
  }

  export type MessageTemplateGroupByOutputType = {
    id: string
    userId: string
    name: string
    content: string
    category: string | null
    createdAt: Date
    updatedAt: Date
    _count: MessageTemplateCountAggregateOutputType | null
    _min: MessageTemplateMinAggregateOutputType | null
    _max: MessageTemplateMaxAggregateOutputType | null
  }

  type GetMessageTemplateGroupByPayload<T extends MessageTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], MessageTemplateGroupByOutputType[P]>
        }
      >
    >


  export type MessageTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    content?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageTemplate"]>

  export type MessageTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    content?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageTemplate"]>

  export type MessageTemplateSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    content?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MessageTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessageTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageTemplate"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      content: string
      category: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["messageTemplate"]>
    composites: {}
  }

  type MessageTemplateGetPayload<S extends boolean | null | undefined | MessageTemplateDefaultArgs> = $Result.GetResult<Prisma.$MessageTemplatePayload, S>

  type MessageTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageTemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageTemplateCountAggregateInputType | true
    }

  export interface MessageTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageTemplate'], meta: { name: 'MessageTemplate' } }
    /**
     * Find zero or one MessageTemplate that matches the filter.
     * @param {MessageTemplateFindUniqueArgs} args - Arguments to find a MessageTemplate
     * @example
     * // Get one MessageTemplate
     * const messageTemplate = await prisma.messageTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageTemplateFindUniqueArgs>(args: SelectSubset<T, MessageTemplateFindUniqueArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MessageTemplate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageTemplateFindUniqueOrThrowArgs} args - Arguments to find a MessageTemplate
     * @example
     * // Get one MessageTemplate
     * const messageTemplate = await prisma.messageTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MessageTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateFindFirstArgs} args - Arguments to find a MessageTemplate
     * @example
     * // Get one MessageTemplate
     * const messageTemplate = await prisma.messageTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageTemplateFindFirstArgs>(args?: SelectSubset<T, MessageTemplateFindFirstArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MessageTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateFindFirstOrThrowArgs} args - Arguments to find a MessageTemplate
     * @example
     * // Get one MessageTemplate
     * const messageTemplate = await prisma.messageTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MessageTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageTemplates
     * const messageTemplates = await prisma.messageTemplate.findMany()
     * 
     * // Get first 10 MessageTemplates
     * const messageTemplates = await prisma.messageTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageTemplateWithIdOnly = await prisma.messageTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageTemplateFindManyArgs>(args?: SelectSubset<T, MessageTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MessageTemplate.
     * @param {MessageTemplateCreateArgs} args - Arguments to create a MessageTemplate.
     * @example
     * // Create one MessageTemplate
     * const MessageTemplate = await prisma.messageTemplate.create({
     *   data: {
     *     // ... data to create a MessageTemplate
     *   }
     * })
     * 
     */
    create<T extends MessageTemplateCreateArgs>(args: SelectSubset<T, MessageTemplateCreateArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MessageTemplates.
     * @param {MessageTemplateCreateManyArgs} args - Arguments to create many MessageTemplates.
     * @example
     * // Create many MessageTemplates
     * const messageTemplate = await prisma.messageTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageTemplateCreateManyArgs>(args?: SelectSubset<T, MessageTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MessageTemplates and returns the data saved in the database.
     * @param {MessageTemplateCreateManyAndReturnArgs} args - Arguments to create many MessageTemplates.
     * @example
     * // Create many MessageTemplates
     * const messageTemplate = await prisma.messageTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MessageTemplates and only return the `id`
     * const messageTemplateWithIdOnly = await prisma.messageTemplate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MessageTemplate.
     * @param {MessageTemplateDeleteArgs} args - Arguments to delete one MessageTemplate.
     * @example
     * // Delete one MessageTemplate
     * const MessageTemplate = await prisma.messageTemplate.delete({
     *   where: {
     *     // ... filter to delete one MessageTemplate
     *   }
     * })
     * 
     */
    delete<T extends MessageTemplateDeleteArgs>(args: SelectSubset<T, MessageTemplateDeleteArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MessageTemplate.
     * @param {MessageTemplateUpdateArgs} args - Arguments to update one MessageTemplate.
     * @example
     * // Update one MessageTemplate
     * const messageTemplate = await prisma.messageTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageTemplateUpdateArgs>(args: SelectSubset<T, MessageTemplateUpdateArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MessageTemplates.
     * @param {MessageTemplateDeleteManyArgs} args - Arguments to filter MessageTemplates to delete.
     * @example
     * // Delete a few MessageTemplates
     * const { count } = await prisma.messageTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageTemplateDeleteManyArgs>(args?: SelectSubset<T, MessageTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageTemplates
     * const messageTemplate = await prisma.messageTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageTemplateUpdateManyArgs>(args: SelectSubset<T, MessageTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MessageTemplate.
     * @param {MessageTemplateUpsertArgs} args - Arguments to update or create a MessageTemplate.
     * @example
     * // Update or create a MessageTemplate
     * const messageTemplate = await prisma.messageTemplate.upsert({
     *   create: {
     *     // ... data to create a MessageTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageTemplate we want to update
     *   }
     * })
     */
    upsert<T extends MessageTemplateUpsertArgs>(args: SelectSubset<T, MessageTemplateUpsertArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MessageTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateCountArgs} args - Arguments to filter MessageTemplates to count.
     * @example
     * // Count the number of MessageTemplates
     * const count = await prisma.messageTemplate.count({
     *   where: {
     *     // ... the filter for the MessageTemplates we want to count
     *   }
     * })
    **/
    count<T extends MessageTemplateCountArgs>(
      args?: Subset<T, MessageTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageTemplateAggregateArgs>(args: Subset<T, MessageTemplateAggregateArgs>): Prisma.PrismaPromise<GetMessageTemplateAggregateType<T>>

    /**
     * Group by MessageTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageTemplateGroupByArgs['orderBy'] }
        : { orderBy?: MessageTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageTemplate model
   */
  readonly fields: MessageTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageTemplate model
   */ 
  interface MessageTemplateFieldRefs {
    readonly id: FieldRef<"MessageTemplate", 'String'>
    readonly userId: FieldRef<"MessageTemplate", 'String'>
    readonly name: FieldRef<"MessageTemplate", 'String'>
    readonly content: FieldRef<"MessageTemplate", 'String'>
    readonly category: FieldRef<"MessageTemplate", 'String'>
    readonly createdAt: FieldRef<"MessageTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"MessageTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MessageTemplate findUnique
   */
  export type MessageTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    /**
     * Filter, which MessageTemplate to fetch.
     */
    where: MessageTemplateWhereUniqueInput
  }

  /**
   * MessageTemplate findUniqueOrThrow
   */
  export type MessageTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    /**
     * Filter, which MessageTemplate to fetch.
     */
    where: MessageTemplateWhereUniqueInput
  }

  /**
   * MessageTemplate findFirst
   */
  export type MessageTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    /**
     * Filter, which MessageTemplate to fetch.
     */
    where?: MessageTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageTemplates to fetch.
     */
    orderBy?: MessageTemplateOrderByWithRelationInput | MessageTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageTemplates.
     */
    cursor?: MessageTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageTemplates.
     */
    distinct?: MessageTemplateScalarFieldEnum | MessageTemplateScalarFieldEnum[]
  }

  /**
   * MessageTemplate findFirstOrThrow
   */
  export type MessageTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    /**
     * Filter, which MessageTemplate to fetch.
     */
    where?: MessageTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageTemplates to fetch.
     */
    orderBy?: MessageTemplateOrderByWithRelationInput | MessageTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageTemplates.
     */
    cursor?: MessageTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageTemplates.
     */
    distinct?: MessageTemplateScalarFieldEnum | MessageTemplateScalarFieldEnum[]
  }

  /**
   * MessageTemplate findMany
   */
  export type MessageTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    /**
     * Filter, which MessageTemplates to fetch.
     */
    where?: MessageTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageTemplates to fetch.
     */
    orderBy?: MessageTemplateOrderByWithRelationInput | MessageTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageTemplates.
     */
    cursor?: MessageTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageTemplates.
     */
    skip?: number
    distinct?: MessageTemplateScalarFieldEnum | MessageTemplateScalarFieldEnum[]
  }

  /**
   * MessageTemplate create
   */
  export type MessageTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageTemplate.
     */
    data: XOR<MessageTemplateCreateInput, MessageTemplateUncheckedCreateInput>
  }

  /**
   * MessageTemplate createMany
   */
  export type MessageTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageTemplates.
     */
    data: MessageTemplateCreateManyInput | MessageTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageTemplate createManyAndReturn
   */
  export type MessageTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MessageTemplates.
     */
    data: MessageTemplateCreateManyInput | MessageTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageTemplate update
   */
  export type MessageTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageTemplate.
     */
    data: XOR<MessageTemplateUpdateInput, MessageTemplateUncheckedUpdateInput>
    /**
     * Choose, which MessageTemplate to update.
     */
    where: MessageTemplateWhereUniqueInput
  }

  /**
   * MessageTemplate updateMany
   */
  export type MessageTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageTemplates.
     */
    data: XOR<MessageTemplateUpdateManyMutationInput, MessageTemplateUncheckedUpdateManyInput>
    /**
     * Filter which MessageTemplates to update
     */
    where?: MessageTemplateWhereInput
  }

  /**
   * MessageTemplate upsert
   */
  export type MessageTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageTemplate to update in case it exists.
     */
    where: MessageTemplateWhereUniqueInput
    /**
     * In case the MessageTemplate found by the `where` argument doesn't exist, create a new MessageTemplate with this data.
     */
    create: XOR<MessageTemplateCreateInput, MessageTemplateUncheckedCreateInput>
    /**
     * In case the MessageTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageTemplateUpdateInput, MessageTemplateUncheckedUpdateInput>
  }

  /**
   * MessageTemplate delete
   */
  export type MessageTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    /**
     * Filter which MessageTemplate to delete.
     */
    where: MessageTemplateWhereUniqueInput
  }

  /**
   * MessageTemplate deleteMany
   */
  export type MessageTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageTemplates to delete
     */
    where?: MessageTemplateWhereInput
  }

  /**
   * MessageTemplate without action
   */
  export type MessageTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
  }


  /**
   * Model IceBreaker
   */

  export type AggregateIceBreaker = {
    _count: IceBreakerCountAggregateOutputType | null
    _min: IceBreakerMinAggregateOutputType | null
    _max: IceBreakerMaxAggregateOutputType | null
  }

  export type IceBreakerMinAggregateOutputType = {
    id: string | null
    userId: string | null
    profileId: string | null
    question: string | null
    answer: string | null
    createdAt: Date | null
  }

  export type IceBreakerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    profileId: string | null
    question: string | null
    answer: string | null
    createdAt: Date | null
  }

  export type IceBreakerCountAggregateOutputType = {
    id: number
    userId: number
    profileId: number
    question: number
    answer: number
    createdAt: number
    _all: number
  }


  export type IceBreakerMinAggregateInputType = {
    id?: true
    userId?: true
    profileId?: true
    question?: true
    answer?: true
    createdAt?: true
  }

  export type IceBreakerMaxAggregateInputType = {
    id?: true
    userId?: true
    profileId?: true
    question?: true
    answer?: true
    createdAt?: true
  }

  export type IceBreakerCountAggregateInputType = {
    id?: true
    userId?: true
    profileId?: true
    question?: true
    answer?: true
    createdAt?: true
    _all?: true
  }

  export type IceBreakerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IceBreaker to aggregate.
     */
    where?: IceBreakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IceBreakers to fetch.
     */
    orderBy?: IceBreakerOrderByWithRelationInput | IceBreakerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IceBreakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IceBreakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IceBreakers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IceBreakers
    **/
    _count?: true | IceBreakerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IceBreakerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IceBreakerMaxAggregateInputType
  }

  export type GetIceBreakerAggregateType<T extends IceBreakerAggregateArgs> = {
        [P in keyof T & keyof AggregateIceBreaker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIceBreaker[P]>
      : GetScalarType<T[P], AggregateIceBreaker[P]>
  }




  export type IceBreakerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IceBreakerWhereInput
    orderBy?: IceBreakerOrderByWithAggregationInput | IceBreakerOrderByWithAggregationInput[]
    by: IceBreakerScalarFieldEnum[] | IceBreakerScalarFieldEnum
    having?: IceBreakerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IceBreakerCountAggregateInputType | true
    _min?: IceBreakerMinAggregateInputType
    _max?: IceBreakerMaxAggregateInputType
  }

  export type IceBreakerGroupByOutputType = {
    id: string
    userId: string
    profileId: string
    question: string
    answer: string | null
    createdAt: Date
    _count: IceBreakerCountAggregateOutputType | null
    _min: IceBreakerMinAggregateOutputType | null
    _max: IceBreakerMaxAggregateOutputType | null
  }

  type GetIceBreakerGroupByPayload<T extends IceBreakerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IceBreakerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IceBreakerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IceBreakerGroupByOutputType[P]>
            : GetScalarType<T[P], IceBreakerGroupByOutputType[P]>
        }
      >
    >


  export type IceBreakerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    profileId?: boolean
    question?: boolean
    answer?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["iceBreaker"]>

  export type IceBreakerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    profileId?: boolean
    question?: boolean
    answer?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["iceBreaker"]>

  export type IceBreakerSelectScalar = {
    id?: boolean
    userId?: boolean
    profileId?: boolean
    question?: boolean
    answer?: boolean
    createdAt?: boolean
  }

  export type IceBreakerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type IceBreakerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $IceBreakerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IceBreaker"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      profileId: string
      question: string
      answer: string | null
      createdAt: Date
    }, ExtArgs["result"]["iceBreaker"]>
    composites: {}
  }

  type IceBreakerGetPayload<S extends boolean | null | undefined | IceBreakerDefaultArgs> = $Result.GetResult<Prisma.$IceBreakerPayload, S>

  type IceBreakerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IceBreakerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IceBreakerCountAggregateInputType | true
    }

  export interface IceBreakerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IceBreaker'], meta: { name: 'IceBreaker' } }
    /**
     * Find zero or one IceBreaker that matches the filter.
     * @param {IceBreakerFindUniqueArgs} args - Arguments to find a IceBreaker
     * @example
     * // Get one IceBreaker
     * const iceBreaker = await prisma.iceBreaker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IceBreakerFindUniqueArgs>(args: SelectSubset<T, IceBreakerFindUniqueArgs<ExtArgs>>): Prisma__IceBreakerClient<$Result.GetResult<Prisma.$IceBreakerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one IceBreaker that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IceBreakerFindUniqueOrThrowArgs} args - Arguments to find a IceBreaker
     * @example
     * // Get one IceBreaker
     * const iceBreaker = await prisma.iceBreaker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IceBreakerFindUniqueOrThrowArgs>(args: SelectSubset<T, IceBreakerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IceBreakerClient<$Result.GetResult<Prisma.$IceBreakerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first IceBreaker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IceBreakerFindFirstArgs} args - Arguments to find a IceBreaker
     * @example
     * // Get one IceBreaker
     * const iceBreaker = await prisma.iceBreaker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IceBreakerFindFirstArgs>(args?: SelectSubset<T, IceBreakerFindFirstArgs<ExtArgs>>): Prisma__IceBreakerClient<$Result.GetResult<Prisma.$IceBreakerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first IceBreaker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IceBreakerFindFirstOrThrowArgs} args - Arguments to find a IceBreaker
     * @example
     * // Get one IceBreaker
     * const iceBreaker = await prisma.iceBreaker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IceBreakerFindFirstOrThrowArgs>(args?: SelectSubset<T, IceBreakerFindFirstOrThrowArgs<ExtArgs>>): Prisma__IceBreakerClient<$Result.GetResult<Prisma.$IceBreakerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more IceBreakers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IceBreakerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IceBreakers
     * const iceBreakers = await prisma.iceBreaker.findMany()
     * 
     * // Get first 10 IceBreakers
     * const iceBreakers = await prisma.iceBreaker.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const iceBreakerWithIdOnly = await prisma.iceBreaker.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IceBreakerFindManyArgs>(args?: SelectSubset<T, IceBreakerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IceBreakerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a IceBreaker.
     * @param {IceBreakerCreateArgs} args - Arguments to create a IceBreaker.
     * @example
     * // Create one IceBreaker
     * const IceBreaker = await prisma.iceBreaker.create({
     *   data: {
     *     // ... data to create a IceBreaker
     *   }
     * })
     * 
     */
    create<T extends IceBreakerCreateArgs>(args: SelectSubset<T, IceBreakerCreateArgs<ExtArgs>>): Prisma__IceBreakerClient<$Result.GetResult<Prisma.$IceBreakerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many IceBreakers.
     * @param {IceBreakerCreateManyArgs} args - Arguments to create many IceBreakers.
     * @example
     * // Create many IceBreakers
     * const iceBreaker = await prisma.iceBreaker.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IceBreakerCreateManyArgs>(args?: SelectSubset<T, IceBreakerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IceBreakers and returns the data saved in the database.
     * @param {IceBreakerCreateManyAndReturnArgs} args - Arguments to create many IceBreakers.
     * @example
     * // Create many IceBreakers
     * const iceBreaker = await prisma.iceBreaker.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IceBreakers and only return the `id`
     * const iceBreakerWithIdOnly = await prisma.iceBreaker.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IceBreakerCreateManyAndReturnArgs>(args?: SelectSubset<T, IceBreakerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IceBreakerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a IceBreaker.
     * @param {IceBreakerDeleteArgs} args - Arguments to delete one IceBreaker.
     * @example
     * // Delete one IceBreaker
     * const IceBreaker = await prisma.iceBreaker.delete({
     *   where: {
     *     // ... filter to delete one IceBreaker
     *   }
     * })
     * 
     */
    delete<T extends IceBreakerDeleteArgs>(args: SelectSubset<T, IceBreakerDeleteArgs<ExtArgs>>): Prisma__IceBreakerClient<$Result.GetResult<Prisma.$IceBreakerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one IceBreaker.
     * @param {IceBreakerUpdateArgs} args - Arguments to update one IceBreaker.
     * @example
     * // Update one IceBreaker
     * const iceBreaker = await prisma.iceBreaker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IceBreakerUpdateArgs>(args: SelectSubset<T, IceBreakerUpdateArgs<ExtArgs>>): Prisma__IceBreakerClient<$Result.GetResult<Prisma.$IceBreakerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more IceBreakers.
     * @param {IceBreakerDeleteManyArgs} args - Arguments to filter IceBreakers to delete.
     * @example
     * // Delete a few IceBreakers
     * const { count } = await prisma.iceBreaker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IceBreakerDeleteManyArgs>(args?: SelectSubset<T, IceBreakerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IceBreakers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IceBreakerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IceBreakers
     * const iceBreaker = await prisma.iceBreaker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IceBreakerUpdateManyArgs>(args: SelectSubset<T, IceBreakerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IceBreaker.
     * @param {IceBreakerUpsertArgs} args - Arguments to update or create a IceBreaker.
     * @example
     * // Update or create a IceBreaker
     * const iceBreaker = await prisma.iceBreaker.upsert({
     *   create: {
     *     // ... data to create a IceBreaker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IceBreaker we want to update
     *   }
     * })
     */
    upsert<T extends IceBreakerUpsertArgs>(args: SelectSubset<T, IceBreakerUpsertArgs<ExtArgs>>): Prisma__IceBreakerClient<$Result.GetResult<Prisma.$IceBreakerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of IceBreakers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IceBreakerCountArgs} args - Arguments to filter IceBreakers to count.
     * @example
     * // Count the number of IceBreakers
     * const count = await prisma.iceBreaker.count({
     *   where: {
     *     // ... the filter for the IceBreakers we want to count
     *   }
     * })
    **/
    count<T extends IceBreakerCountArgs>(
      args?: Subset<T, IceBreakerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IceBreakerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IceBreaker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IceBreakerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IceBreakerAggregateArgs>(args: Subset<T, IceBreakerAggregateArgs>): Prisma.PrismaPromise<GetIceBreakerAggregateType<T>>

    /**
     * Group by IceBreaker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IceBreakerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IceBreakerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IceBreakerGroupByArgs['orderBy'] }
        : { orderBy?: IceBreakerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IceBreakerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIceBreakerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IceBreaker model
   */
  readonly fields: IceBreakerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IceBreaker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IceBreakerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IceBreaker model
   */ 
  interface IceBreakerFieldRefs {
    readonly id: FieldRef<"IceBreaker", 'String'>
    readonly userId: FieldRef<"IceBreaker", 'String'>
    readonly profileId: FieldRef<"IceBreaker", 'String'>
    readonly question: FieldRef<"IceBreaker", 'String'>
    readonly answer: FieldRef<"IceBreaker", 'String'>
    readonly createdAt: FieldRef<"IceBreaker", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IceBreaker findUnique
   */
  export type IceBreakerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IceBreaker
     */
    select?: IceBreakerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IceBreakerInclude<ExtArgs> | null
    /**
     * Filter, which IceBreaker to fetch.
     */
    where: IceBreakerWhereUniqueInput
  }

  /**
   * IceBreaker findUniqueOrThrow
   */
  export type IceBreakerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IceBreaker
     */
    select?: IceBreakerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IceBreakerInclude<ExtArgs> | null
    /**
     * Filter, which IceBreaker to fetch.
     */
    where: IceBreakerWhereUniqueInput
  }

  /**
   * IceBreaker findFirst
   */
  export type IceBreakerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IceBreaker
     */
    select?: IceBreakerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IceBreakerInclude<ExtArgs> | null
    /**
     * Filter, which IceBreaker to fetch.
     */
    where?: IceBreakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IceBreakers to fetch.
     */
    orderBy?: IceBreakerOrderByWithRelationInput | IceBreakerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IceBreakers.
     */
    cursor?: IceBreakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IceBreakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IceBreakers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IceBreakers.
     */
    distinct?: IceBreakerScalarFieldEnum | IceBreakerScalarFieldEnum[]
  }

  /**
   * IceBreaker findFirstOrThrow
   */
  export type IceBreakerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IceBreaker
     */
    select?: IceBreakerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IceBreakerInclude<ExtArgs> | null
    /**
     * Filter, which IceBreaker to fetch.
     */
    where?: IceBreakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IceBreakers to fetch.
     */
    orderBy?: IceBreakerOrderByWithRelationInput | IceBreakerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IceBreakers.
     */
    cursor?: IceBreakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IceBreakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IceBreakers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IceBreakers.
     */
    distinct?: IceBreakerScalarFieldEnum | IceBreakerScalarFieldEnum[]
  }

  /**
   * IceBreaker findMany
   */
  export type IceBreakerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IceBreaker
     */
    select?: IceBreakerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IceBreakerInclude<ExtArgs> | null
    /**
     * Filter, which IceBreakers to fetch.
     */
    where?: IceBreakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IceBreakers to fetch.
     */
    orderBy?: IceBreakerOrderByWithRelationInput | IceBreakerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IceBreakers.
     */
    cursor?: IceBreakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IceBreakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IceBreakers.
     */
    skip?: number
    distinct?: IceBreakerScalarFieldEnum | IceBreakerScalarFieldEnum[]
  }

  /**
   * IceBreaker create
   */
  export type IceBreakerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IceBreaker
     */
    select?: IceBreakerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IceBreakerInclude<ExtArgs> | null
    /**
     * The data needed to create a IceBreaker.
     */
    data: XOR<IceBreakerCreateInput, IceBreakerUncheckedCreateInput>
  }

  /**
   * IceBreaker createMany
   */
  export type IceBreakerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IceBreakers.
     */
    data: IceBreakerCreateManyInput | IceBreakerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IceBreaker createManyAndReturn
   */
  export type IceBreakerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IceBreaker
     */
    select?: IceBreakerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many IceBreakers.
     */
    data: IceBreakerCreateManyInput | IceBreakerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IceBreakerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IceBreaker update
   */
  export type IceBreakerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IceBreaker
     */
    select?: IceBreakerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IceBreakerInclude<ExtArgs> | null
    /**
     * The data needed to update a IceBreaker.
     */
    data: XOR<IceBreakerUpdateInput, IceBreakerUncheckedUpdateInput>
    /**
     * Choose, which IceBreaker to update.
     */
    where: IceBreakerWhereUniqueInput
  }

  /**
   * IceBreaker updateMany
   */
  export type IceBreakerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IceBreakers.
     */
    data: XOR<IceBreakerUpdateManyMutationInput, IceBreakerUncheckedUpdateManyInput>
    /**
     * Filter which IceBreakers to update
     */
    where?: IceBreakerWhereInput
  }

  /**
   * IceBreaker upsert
   */
  export type IceBreakerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IceBreaker
     */
    select?: IceBreakerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IceBreakerInclude<ExtArgs> | null
    /**
     * The filter to search for the IceBreaker to update in case it exists.
     */
    where: IceBreakerWhereUniqueInput
    /**
     * In case the IceBreaker found by the `where` argument doesn't exist, create a new IceBreaker with this data.
     */
    create: XOR<IceBreakerCreateInput, IceBreakerUncheckedCreateInput>
    /**
     * In case the IceBreaker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IceBreakerUpdateInput, IceBreakerUncheckedUpdateInput>
  }

  /**
   * IceBreaker delete
   */
  export type IceBreakerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IceBreaker
     */
    select?: IceBreakerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IceBreakerInclude<ExtArgs> | null
    /**
     * Filter which IceBreaker to delete.
     */
    where: IceBreakerWhereUniqueInput
  }

  /**
   * IceBreaker deleteMany
   */
  export type IceBreakerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IceBreakers to delete
     */
    where?: IceBreakerWhereInput
  }

  /**
   * IceBreaker without action
   */
  export type IceBreakerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IceBreaker
     */
    select?: IceBreakerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IceBreakerInclude<ExtArgs> | null
  }


  /**
   * Model Testimonial
   */

  export type AggregateTestimonial = {
    _count: TestimonialCountAggregateOutputType | null
    _avg: TestimonialAvgAggregateOutputType | null
    _sum: TestimonialSumAggregateOutputType | null
    _min: TestimonialMinAggregateOutputType | null
    _max: TestimonialMaxAggregateOutputType | null
  }

  export type TestimonialAvgAggregateOutputType = {
    rating: number | null
  }

  export type TestimonialSumAggregateOutputType = {
    rating: number | null
  }

  export type TestimonialMinAggregateOutputType = {
    id: string | null
    profileId: string | null
    authorName: string | null
    authorRelation: string | null
    authorEmail: string | null
    content: string | null
    rating: number | null
    isApproved: boolean | null
    createdAt: Date | null
  }

  export type TestimonialMaxAggregateOutputType = {
    id: string | null
    profileId: string | null
    authorName: string | null
    authorRelation: string | null
    authorEmail: string | null
    content: string | null
    rating: number | null
    isApproved: boolean | null
    createdAt: Date | null
  }

  export type TestimonialCountAggregateOutputType = {
    id: number
    profileId: number
    authorName: number
    authorRelation: number
    authorEmail: number
    content: number
    rating: number
    isApproved: number
    createdAt: number
    _all: number
  }


  export type TestimonialAvgAggregateInputType = {
    rating?: true
  }

  export type TestimonialSumAggregateInputType = {
    rating?: true
  }

  export type TestimonialMinAggregateInputType = {
    id?: true
    profileId?: true
    authorName?: true
    authorRelation?: true
    authorEmail?: true
    content?: true
    rating?: true
    isApproved?: true
    createdAt?: true
  }

  export type TestimonialMaxAggregateInputType = {
    id?: true
    profileId?: true
    authorName?: true
    authorRelation?: true
    authorEmail?: true
    content?: true
    rating?: true
    isApproved?: true
    createdAt?: true
  }

  export type TestimonialCountAggregateInputType = {
    id?: true
    profileId?: true
    authorName?: true
    authorRelation?: true
    authorEmail?: true
    content?: true
    rating?: true
    isApproved?: true
    createdAt?: true
    _all?: true
  }

  export type TestimonialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Testimonial to aggregate.
     */
    where?: TestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testimonials to fetch.
     */
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Testimonials
    **/
    _count?: true | TestimonialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestimonialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestimonialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestimonialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestimonialMaxAggregateInputType
  }

  export type GetTestimonialAggregateType<T extends TestimonialAggregateArgs> = {
        [P in keyof T & keyof AggregateTestimonial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestimonial[P]>
      : GetScalarType<T[P], AggregateTestimonial[P]>
  }




  export type TestimonialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestimonialWhereInput
    orderBy?: TestimonialOrderByWithAggregationInput | TestimonialOrderByWithAggregationInput[]
    by: TestimonialScalarFieldEnum[] | TestimonialScalarFieldEnum
    having?: TestimonialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestimonialCountAggregateInputType | true
    _avg?: TestimonialAvgAggregateInputType
    _sum?: TestimonialSumAggregateInputType
    _min?: TestimonialMinAggregateInputType
    _max?: TestimonialMaxAggregateInputType
  }

  export type TestimonialGroupByOutputType = {
    id: string
    profileId: string
    authorName: string
    authorRelation: string | null
    authorEmail: string | null
    content: string
    rating: number | null
    isApproved: boolean
    createdAt: Date
    _count: TestimonialCountAggregateOutputType | null
    _avg: TestimonialAvgAggregateOutputType | null
    _sum: TestimonialSumAggregateOutputType | null
    _min: TestimonialMinAggregateOutputType | null
    _max: TestimonialMaxAggregateOutputType | null
  }

  type GetTestimonialGroupByPayload<T extends TestimonialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestimonialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestimonialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestimonialGroupByOutputType[P]>
            : GetScalarType<T[P], TestimonialGroupByOutputType[P]>
        }
      >
    >


  export type TestimonialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    authorName?: boolean
    authorRelation?: boolean
    authorEmail?: boolean
    content?: boolean
    rating?: boolean
    isApproved?: boolean
    createdAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testimonial"]>

  export type TestimonialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    authorName?: boolean
    authorRelation?: boolean
    authorEmail?: boolean
    content?: boolean
    rating?: boolean
    isApproved?: boolean
    createdAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testimonial"]>

  export type TestimonialSelectScalar = {
    id?: boolean
    profileId?: boolean
    authorName?: boolean
    authorRelation?: boolean
    authorEmail?: boolean
    content?: boolean
    rating?: boolean
    isApproved?: boolean
    createdAt?: boolean
  }

  export type TestimonialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type TestimonialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $TestimonialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Testimonial"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profileId: string
      authorName: string
      authorRelation: string | null
      authorEmail: string | null
      content: string
      rating: number | null
      isApproved: boolean
      createdAt: Date
    }, ExtArgs["result"]["testimonial"]>
    composites: {}
  }

  type TestimonialGetPayload<S extends boolean | null | undefined | TestimonialDefaultArgs> = $Result.GetResult<Prisma.$TestimonialPayload, S>

  type TestimonialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TestimonialFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TestimonialCountAggregateInputType | true
    }

  export interface TestimonialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Testimonial'], meta: { name: 'Testimonial' } }
    /**
     * Find zero or one Testimonial that matches the filter.
     * @param {TestimonialFindUniqueArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestimonialFindUniqueArgs>(args: SelectSubset<T, TestimonialFindUniqueArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Testimonial that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TestimonialFindUniqueOrThrowArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestimonialFindUniqueOrThrowArgs>(args: SelectSubset<T, TestimonialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Testimonial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialFindFirstArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestimonialFindFirstArgs>(args?: SelectSubset<T, TestimonialFindFirstArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Testimonial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialFindFirstOrThrowArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestimonialFindFirstOrThrowArgs>(args?: SelectSubset<T, TestimonialFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Testimonials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Testimonials
     * const testimonials = await prisma.testimonial.findMany()
     * 
     * // Get first 10 Testimonials
     * const testimonials = await prisma.testimonial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testimonialWithIdOnly = await prisma.testimonial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestimonialFindManyArgs>(args?: SelectSubset<T, TestimonialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Testimonial.
     * @param {TestimonialCreateArgs} args - Arguments to create a Testimonial.
     * @example
     * // Create one Testimonial
     * const Testimonial = await prisma.testimonial.create({
     *   data: {
     *     // ... data to create a Testimonial
     *   }
     * })
     * 
     */
    create<T extends TestimonialCreateArgs>(args: SelectSubset<T, TestimonialCreateArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Testimonials.
     * @param {TestimonialCreateManyArgs} args - Arguments to create many Testimonials.
     * @example
     * // Create many Testimonials
     * const testimonial = await prisma.testimonial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestimonialCreateManyArgs>(args?: SelectSubset<T, TestimonialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Testimonials and returns the data saved in the database.
     * @param {TestimonialCreateManyAndReturnArgs} args - Arguments to create many Testimonials.
     * @example
     * // Create many Testimonials
     * const testimonial = await prisma.testimonial.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Testimonials and only return the `id`
     * const testimonialWithIdOnly = await prisma.testimonial.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TestimonialCreateManyAndReturnArgs>(args?: SelectSubset<T, TestimonialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Testimonial.
     * @param {TestimonialDeleteArgs} args - Arguments to delete one Testimonial.
     * @example
     * // Delete one Testimonial
     * const Testimonial = await prisma.testimonial.delete({
     *   where: {
     *     // ... filter to delete one Testimonial
     *   }
     * })
     * 
     */
    delete<T extends TestimonialDeleteArgs>(args: SelectSubset<T, TestimonialDeleteArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Testimonial.
     * @param {TestimonialUpdateArgs} args - Arguments to update one Testimonial.
     * @example
     * // Update one Testimonial
     * const testimonial = await prisma.testimonial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestimonialUpdateArgs>(args: SelectSubset<T, TestimonialUpdateArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Testimonials.
     * @param {TestimonialDeleteManyArgs} args - Arguments to filter Testimonials to delete.
     * @example
     * // Delete a few Testimonials
     * const { count } = await prisma.testimonial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestimonialDeleteManyArgs>(args?: SelectSubset<T, TestimonialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Testimonials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Testimonials
     * const testimonial = await prisma.testimonial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestimonialUpdateManyArgs>(args: SelectSubset<T, TestimonialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Testimonial.
     * @param {TestimonialUpsertArgs} args - Arguments to update or create a Testimonial.
     * @example
     * // Update or create a Testimonial
     * const testimonial = await prisma.testimonial.upsert({
     *   create: {
     *     // ... data to create a Testimonial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Testimonial we want to update
     *   }
     * })
     */
    upsert<T extends TestimonialUpsertArgs>(args: SelectSubset<T, TestimonialUpsertArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Testimonials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialCountArgs} args - Arguments to filter Testimonials to count.
     * @example
     * // Count the number of Testimonials
     * const count = await prisma.testimonial.count({
     *   where: {
     *     // ... the filter for the Testimonials we want to count
     *   }
     * })
    **/
    count<T extends TestimonialCountArgs>(
      args?: Subset<T, TestimonialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestimonialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Testimonial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestimonialAggregateArgs>(args: Subset<T, TestimonialAggregateArgs>): Prisma.PrismaPromise<GetTestimonialAggregateType<T>>

    /**
     * Group by Testimonial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestimonialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestimonialGroupByArgs['orderBy'] }
        : { orderBy?: TestimonialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestimonialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestimonialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Testimonial model
   */
  readonly fields: TestimonialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Testimonial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestimonialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Testimonial model
   */ 
  interface TestimonialFieldRefs {
    readonly id: FieldRef<"Testimonial", 'String'>
    readonly profileId: FieldRef<"Testimonial", 'String'>
    readonly authorName: FieldRef<"Testimonial", 'String'>
    readonly authorRelation: FieldRef<"Testimonial", 'String'>
    readonly authorEmail: FieldRef<"Testimonial", 'String'>
    readonly content: FieldRef<"Testimonial", 'String'>
    readonly rating: FieldRef<"Testimonial", 'Int'>
    readonly isApproved: FieldRef<"Testimonial", 'Boolean'>
    readonly createdAt: FieldRef<"Testimonial", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Testimonial findUnique
   */
  export type TestimonialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    /**
     * Filter, which Testimonial to fetch.
     */
    where: TestimonialWhereUniqueInput
  }

  /**
   * Testimonial findUniqueOrThrow
   */
  export type TestimonialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    /**
     * Filter, which Testimonial to fetch.
     */
    where: TestimonialWhereUniqueInput
  }

  /**
   * Testimonial findFirst
   */
  export type TestimonialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    /**
     * Filter, which Testimonial to fetch.
     */
    where?: TestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testimonials to fetch.
     */
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Testimonials.
     */
    cursor?: TestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Testimonials.
     */
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * Testimonial findFirstOrThrow
   */
  export type TestimonialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    /**
     * Filter, which Testimonial to fetch.
     */
    where?: TestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testimonials to fetch.
     */
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Testimonials.
     */
    cursor?: TestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Testimonials.
     */
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * Testimonial findMany
   */
  export type TestimonialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    /**
     * Filter, which Testimonials to fetch.
     */
    where?: TestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testimonials to fetch.
     */
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Testimonials.
     */
    cursor?: TestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testimonials.
     */
    skip?: number
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * Testimonial create
   */
  export type TestimonialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    /**
     * The data needed to create a Testimonial.
     */
    data: XOR<TestimonialCreateInput, TestimonialUncheckedCreateInput>
  }

  /**
   * Testimonial createMany
   */
  export type TestimonialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Testimonials.
     */
    data: TestimonialCreateManyInput | TestimonialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Testimonial createManyAndReturn
   */
  export type TestimonialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Testimonials.
     */
    data: TestimonialCreateManyInput | TestimonialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Testimonial update
   */
  export type TestimonialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    /**
     * The data needed to update a Testimonial.
     */
    data: XOR<TestimonialUpdateInput, TestimonialUncheckedUpdateInput>
    /**
     * Choose, which Testimonial to update.
     */
    where: TestimonialWhereUniqueInput
  }

  /**
   * Testimonial updateMany
   */
  export type TestimonialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Testimonials.
     */
    data: XOR<TestimonialUpdateManyMutationInput, TestimonialUncheckedUpdateManyInput>
    /**
     * Filter which Testimonials to update
     */
    where?: TestimonialWhereInput
  }

  /**
   * Testimonial upsert
   */
  export type TestimonialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    /**
     * The filter to search for the Testimonial to update in case it exists.
     */
    where: TestimonialWhereUniqueInput
    /**
     * In case the Testimonial found by the `where` argument doesn't exist, create a new Testimonial with this data.
     */
    create: XOR<TestimonialCreateInput, TestimonialUncheckedCreateInput>
    /**
     * In case the Testimonial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestimonialUpdateInput, TestimonialUncheckedUpdateInput>
  }

  /**
   * Testimonial delete
   */
  export type TestimonialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    /**
     * Filter which Testimonial to delete.
     */
    where: TestimonialWhereUniqueInput
  }

  /**
   * Testimonial deleteMany
   */
  export type TestimonialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Testimonials to delete
     */
    where?: TestimonialWhereInput
  }

  /**
   * Testimonial without action
   */
  export type TestimonialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
  }


  /**
   * Model Activity
   */

  export type AggregateActivity = {
    _count: ActivityCountAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  export type ActivityMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    description: string | null
    createdAt: Date | null
  }

  export type ActivityMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    description: string | null
    createdAt: Date | null
  }

  export type ActivityCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    description: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type ActivityMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    description?: true
    createdAt?: true
  }

  export type ActivityMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    description?: true
    createdAt?: true
  }

  export type ActivityCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    description?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type ActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activity to aggregate.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Activities
    **/
    _count?: true | ActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityMaxAggregateInputType
  }

  export type GetActivityAggregateType<T extends ActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivity[P]>
      : GetScalarType<T[P], AggregateActivity[P]>
  }




  export type ActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithAggregationInput | ActivityOrderByWithAggregationInput[]
    by: ActivityScalarFieldEnum[] | ActivityScalarFieldEnum
    having?: ActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityCountAggregateInputType | true
    _min?: ActivityMinAggregateInputType
    _max?: ActivityMaxAggregateInputType
  }

  export type ActivityGroupByOutputType = {
    id: string
    userId: string
    type: string
    title: string
    description: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: ActivityCountAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  type GetActivityGroupByPayload<T extends ActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityGroupByOutputType[P]>
        }
      >
    >


  export type ActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type ActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Activity"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      title: string
      description: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["activity"]>
    composites: {}
  }

  type ActivityGetPayload<S extends boolean | null | undefined | ActivityDefaultArgs> = $Result.GetResult<Prisma.$ActivityPayload, S>

  type ActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActivityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActivityCountAggregateInputType | true
    }

  export interface ActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Activity'], meta: { name: 'Activity' } }
    /**
     * Find zero or one Activity that matches the filter.
     * @param {ActivityFindUniqueArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityFindUniqueArgs>(args: SelectSubset<T, ActivityFindUniqueArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Activity that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ActivityFindUniqueOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Activity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityFindFirstArgs>(args?: SelectSubset<T, ActivityFindFirstArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Activity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activities
     * const activities = await prisma.activity.findMany()
     * 
     * // Get first 10 Activities
     * const activities = await prisma.activity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityWithIdOnly = await prisma.activity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityFindManyArgs>(args?: SelectSubset<T, ActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Activity.
     * @param {ActivityCreateArgs} args - Arguments to create a Activity.
     * @example
     * // Create one Activity
     * const Activity = await prisma.activity.create({
     *   data: {
     *     // ... data to create a Activity
     *   }
     * })
     * 
     */
    create<T extends ActivityCreateArgs>(args: SelectSubset<T, ActivityCreateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Activities.
     * @param {ActivityCreateManyArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityCreateManyArgs>(args?: SelectSubset<T, ActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Activities and returns the data saved in the database.
     * @param {ActivityCreateManyAndReturnArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Activity.
     * @param {ActivityDeleteArgs} args - Arguments to delete one Activity.
     * @example
     * // Delete one Activity
     * const Activity = await prisma.activity.delete({
     *   where: {
     *     // ... filter to delete one Activity
     *   }
     * })
     * 
     */
    delete<T extends ActivityDeleteArgs>(args: SelectSubset<T, ActivityDeleteArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Activity.
     * @param {ActivityUpdateArgs} args - Arguments to update one Activity.
     * @example
     * // Update one Activity
     * const activity = await prisma.activity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityUpdateArgs>(args: SelectSubset<T, ActivityUpdateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Activities.
     * @param {ActivityDeleteManyArgs} args - Arguments to filter Activities to delete.
     * @example
     * // Delete a few Activities
     * const { count } = await prisma.activity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityDeleteManyArgs>(args?: SelectSubset<T, ActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityUpdateManyArgs>(args: SelectSubset<T, ActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Activity.
     * @param {ActivityUpsertArgs} args - Arguments to update or create a Activity.
     * @example
     * // Update or create a Activity
     * const activity = await prisma.activity.upsert({
     *   create: {
     *     // ... data to create a Activity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activity we want to update
     *   }
     * })
     */
    upsert<T extends ActivityUpsertArgs>(args: SelectSubset<T, ActivityUpsertArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCountArgs} args - Arguments to filter Activities to count.
     * @example
     * // Count the number of Activities
     * const count = await prisma.activity.count({
     *   where: {
     *     // ... the filter for the Activities we want to count
     *   }
     * })
    **/
    count<T extends ActivityCountArgs>(
      args?: Subset<T, ActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityAggregateArgs>(args: Subset<T, ActivityAggregateArgs>): Prisma.PrismaPromise<GetActivityAggregateType<T>>

    /**
     * Group by Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityGroupByArgs['orderBy'] }
        : { orderBy?: ActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Activity model
   */
  readonly fields: ActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Activity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Activity model
   */ 
  interface ActivityFieldRefs {
    readonly id: FieldRef<"Activity", 'String'>
    readonly userId: FieldRef<"Activity", 'String'>
    readonly type: FieldRef<"Activity", 'String'>
    readonly title: FieldRef<"Activity", 'String'>
    readonly description: FieldRef<"Activity", 'String'>
    readonly metadata: FieldRef<"Activity", 'Json'>
    readonly createdAt: FieldRef<"Activity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Activity findUnique
   */
  export type ActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findUniqueOrThrow
   */
  export type ActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findFirst
   */
  export type ActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findFirstOrThrow
   */
  export type ActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findMany
   */
  export type ActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activities to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity create
   */
  export type ActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a Activity.
     */
    data: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
  }

  /**
   * Activity createMany
   */
  export type ActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Activity createManyAndReturn
   */
  export type ActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activity update
   */
  export type ActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a Activity.
     */
    data: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
    /**
     * Choose, which Activity to update.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity updateMany
   */
  export type ActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
  }

  /**
   * Activity upsert
   */
  export type ActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the Activity to update in case it exists.
     */
    where: ActivityWhereUniqueInput
    /**
     * In case the Activity found by the `where` argument doesn't exist, create a new Activity with this data.
     */
    create: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
    /**
     * In case the Activity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
  }

  /**
   * Activity delete
   */
  export type ActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter which Activity to delete.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity deleteMany
   */
  export type ActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activities to delete
     */
    where?: ActivityWhereInput
  }

  /**
   * Activity without action
   */
  export type ActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
  }


  /**
   * Model Leaderboard
   */

  export type AggregateLeaderboard = {
    _count: LeaderboardCountAggregateOutputType | null
    _avg: LeaderboardAvgAggregateOutputType | null
    _sum: LeaderboardSumAggregateOutputType | null
    _min: LeaderboardMinAggregateOutputType | null
    _max: LeaderboardMaxAggregateOutputType | null
  }

  export type LeaderboardAvgAggregateOutputType = {
    rank: number | null
    score: number | null
  }

  export type LeaderboardSumAggregateOutputType = {
    rank: number | null
    score: number | null
  }

  export type LeaderboardMinAggregateOutputType = {
    id: string | null
    userId: string | null
    category: string | null
    rank: number | null
    score: number | null
    period: string | null
    periodStart: Date | null
    periodEnd: Date | null
    createdAt: Date | null
  }

  export type LeaderboardMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    category: string | null
    rank: number | null
    score: number | null
    period: string | null
    periodStart: Date | null
    periodEnd: Date | null
    createdAt: Date | null
  }

  export type LeaderboardCountAggregateOutputType = {
    id: number
    userId: number
    category: number
    rank: number
    score: number
    period: number
    periodStart: number
    periodEnd: number
    createdAt: number
    _all: number
  }


  export type LeaderboardAvgAggregateInputType = {
    rank?: true
    score?: true
  }

  export type LeaderboardSumAggregateInputType = {
    rank?: true
    score?: true
  }

  export type LeaderboardMinAggregateInputType = {
    id?: true
    userId?: true
    category?: true
    rank?: true
    score?: true
    period?: true
    periodStart?: true
    periodEnd?: true
    createdAt?: true
  }

  export type LeaderboardMaxAggregateInputType = {
    id?: true
    userId?: true
    category?: true
    rank?: true
    score?: true
    period?: true
    periodStart?: true
    periodEnd?: true
    createdAt?: true
  }

  export type LeaderboardCountAggregateInputType = {
    id?: true
    userId?: true
    category?: true
    rank?: true
    score?: true
    period?: true
    periodStart?: true
    periodEnd?: true
    createdAt?: true
    _all?: true
  }

  export type LeaderboardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leaderboard to aggregate.
     */
    where?: LeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaderboards to fetch.
     */
    orderBy?: LeaderboardOrderByWithRelationInput | LeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leaderboards
    **/
    _count?: true | LeaderboardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaderboardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaderboardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaderboardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaderboardMaxAggregateInputType
  }

  export type GetLeaderboardAggregateType<T extends LeaderboardAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaderboard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaderboard[P]>
      : GetScalarType<T[P], AggregateLeaderboard[P]>
  }




  export type LeaderboardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaderboardWhereInput
    orderBy?: LeaderboardOrderByWithAggregationInput | LeaderboardOrderByWithAggregationInput[]
    by: LeaderboardScalarFieldEnum[] | LeaderboardScalarFieldEnum
    having?: LeaderboardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaderboardCountAggregateInputType | true
    _avg?: LeaderboardAvgAggregateInputType
    _sum?: LeaderboardSumAggregateInputType
    _min?: LeaderboardMinAggregateInputType
    _max?: LeaderboardMaxAggregateInputType
  }

  export type LeaderboardGroupByOutputType = {
    id: string
    userId: string
    category: string
    rank: number
    score: number
    period: string
    periodStart: Date
    periodEnd: Date | null
    createdAt: Date
    _count: LeaderboardCountAggregateOutputType | null
    _avg: LeaderboardAvgAggregateOutputType | null
    _sum: LeaderboardSumAggregateOutputType | null
    _min: LeaderboardMinAggregateOutputType | null
    _max: LeaderboardMaxAggregateOutputType | null
  }

  type GetLeaderboardGroupByPayload<T extends LeaderboardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaderboardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaderboardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaderboardGroupByOutputType[P]>
            : GetScalarType<T[P], LeaderboardGroupByOutputType[P]>
        }
      >
    >


  export type LeaderboardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    category?: boolean
    rank?: boolean
    score?: boolean
    period?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaderboard"]>

  export type LeaderboardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    category?: boolean
    rank?: boolean
    score?: boolean
    period?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaderboard"]>

  export type LeaderboardSelectScalar = {
    id?: boolean
    userId?: boolean
    category?: boolean
    rank?: boolean
    score?: boolean
    period?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    createdAt?: boolean
  }

  export type LeaderboardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LeaderboardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LeaderboardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Leaderboard"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      category: string
      rank: number
      score: number
      period: string
      periodStart: Date
      periodEnd: Date | null
      createdAt: Date
    }, ExtArgs["result"]["leaderboard"]>
    composites: {}
  }

  type LeaderboardGetPayload<S extends boolean | null | undefined | LeaderboardDefaultArgs> = $Result.GetResult<Prisma.$LeaderboardPayload, S>

  type LeaderboardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LeaderboardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LeaderboardCountAggregateInputType | true
    }

  export interface LeaderboardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Leaderboard'], meta: { name: 'Leaderboard' } }
    /**
     * Find zero or one Leaderboard that matches the filter.
     * @param {LeaderboardFindUniqueArgs} args - Arguments to find a Leaderboard
     * @example
     * // Get one Leaderboard
     * const leaderboard = await prisma.leaderboard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaderboardFindUniqueArgs>(args: SelectSubset<T, LeaderboardFindUniqueArgs<ExtArgs>>): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Leaderboard that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LeaderboardFindUniqueOrThrowArgs} args - Arguments to find a Leaderboard
     * @example
     * // Get one Leaderboard
     * const leaderboard = await prisma.leaderboard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaderboardFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaderboardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Leaderboard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardFindFirstArgs} args - Arguments to find a Leaderboard
     * @example
     * // Get one Leaderboard
     * const leaderboard = await prisma.leaderboard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaderboardFindFirstArgs>(args?: SelectSubset<T, LeaderboardFindFirstArgs<ExtArgs>>): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Leaderboard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardFindFirstOrThrowArgs} args - Arguments to find a Leaderboard
     * @example
     * // Get one Leaderboard
     * const leaderboard = await prisma.leaderboard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaderboardFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaderboardFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Leaderboards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leaderboards
     * const leaderboards = await prisma.leaderboard.findMany()
     * 
     * // Get first 10 Leaderboards
     * const leaderboards = await prisma.leaderboard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaderboardWithIdOnly = await prisma.leaderboard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaderboardFindManyArgs>(args?: SelectSubset<T, LeaderboardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Leaderboard.
     * @param {LeaderboardCreateArgs} args - Arguments to create a Leaderboard.
     * @example
     * // Create one Leaderboard
     * const Leaderboard = await prisma.leaderboard.create({
     *   data: {
     *     // ... data to create a Leaderboard
     *   }
     * })
     * 
     */
    create<T extends LeaderboardCreateArgs>(args: SelectSubset<T, LeaderboardCreateArgs<ExtArgs>>): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Leaderboards.
     * @param {LeaderboardCreateManyArgs} args - Arguments to create many Leaderboards.
     * @example
     * // Create many Leaderboards
     * const leaderboard = await prisma.leaderboard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaderboardCreateManyArgs>(args?: SelectSubset<T, LeaderboardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Leaderboards and returns the data saved in the database.
     * @param {LeaderboardCreateManyAndReturnArgs} args - Arguments to create many Leaderboards.
     * @example
     * // Create many Leaderboards
     * const leaderboard = await prisma.leaderboard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Leaderboards and only return the `id`
     * const leaderboardWithIdOnly = await prisma.leaderboard.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaderboardCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaderboardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Leaderboard.
     * @param {LeaderboardDeleteArgs} args - Arguments to delete one Leaderboard.
     * @example
     * // Delete one Leaderboard
     * const Leaderboard = await prisma.leaderboard.delete({
     *   where: {
     *     // ... filter to delete one Leaderboard
     *   }
     * })
     * 
     */
    delete<T extends LeaderboardDeleteArgs>(args: SelectSubset<T, LeaderboardDeleteArgs<ExtArgs>>): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Leaderboard.
     * @param {LeaderboardUpdateArgs} args - Arguments to update one Leaderboard.
     * @example
     * // Update one Leaderboard
     * const leaderboard = await prisma.leaderboard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaderboardUpdateArgs>(args: SelectSubset<T, LeaderboardUpdateArgs<ExtArgs>>): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Leaderboards.
     * @param {LeaderboardDeleteManyArgs} args - Arguments to filter Leaderboards to delete.
     * @example
     * // Delete a few Leaderboards
     * const { count } = await prisma.leaderboard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaderboardDeleteManyArgs>(args?: SelectSubset<T, LeaderboardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leaderboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leaderboards
     * const leaderboard = await prisma.leaderboard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaderboardUpdateManyArgs>(args: SelectSubset<T, LeaderboardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Leaderboard.
     * @param {LeaderboardUpsertArgs} args - Arguments to update or create a Leaderboard.
     * @example
     * // Update or create a Leaderboard
     * const leaderboard = await prisma.leaderboard.upsert({
     *   create: {
     *     // ... data to create a Leaderboard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Leaderboard we want to update
     *   }
     * })
     */
    upsert<T extends LeaderboardUpsertArgs>(args: SelectSubset<T, LeaderboardUpsertArgs<ExtArgs>>): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Leaderboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardCountArgs} args - Arguments to filter Leaderboards to count.
     * @example
     * // Count the number of Leaderboards
     * const count = await prisma.leaderboard.count({
     *   where: {
     *     // ... the filter for the Leaderboards we want to count
     *   }
     * })
    **/
    count<T extends LeaderboardCountArgs>(
      args?: Subset<T, LeaderboardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaderboardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Leaderboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaderboardAggregateArgs>(args: Subset<T, LeaderboardAggregateArgs>): Prisma.PrismaPromise<GetLeaderboardAggregateType<T>>

    /**
     * Group by Leaderboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaderboardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaderboardGroupByArgs['orderBy'] }
        : { orderBy?: LeaderboardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaderboardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaderboardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Leaderboard model
   */
  readonly fields: LeaderboardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Leaderboard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaderboardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Leaderboard model
   */ 
  interface LeaderboardFieldRefs {
    readonly id: FieldRef<"Leaderboard", 'String'>
    readonly userId: FieldRef<"Leaderboard", 'String'>
    readonly category: FieldRef<"Leaderboard", 'String'>
    readonly rank: FieldRef<"Leaderboard", 'Int'>
    readonly score: FieldRef<"Leaderboard", 'Int'>
    readonly period: FieldRef<"Leaderboard", 'String'>
    readonly periodStart: FieldRef<"Leaderboard", 'DateTime'>
    readonly periodEnd: FieldRef<"Leaderboard", 'DateTime'>
    readonly createdAt: FieldRef<"Leaderboard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Leaderboard findUnique
   */
  export type LeaderboardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which Leaderboard to fetch.
     */
    where: LeaderboardWhereUniqueInput
  }

  /**
   * Leaderboard findUniqueOrThrow
   */
  export type LeaderboardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which Leaderboard to fetch.
     */
    where: LeaderboardWhereUniqueInput
  }

  /**
   * Leaderboard findFirst
   */
  export type LeaderboardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which Leaderboard to fetch.
     */
    where?: LeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaderboards to fetch.
     */
    orderBy?: LeaderboardOrderByWithRelationInput | LeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leaderboards.
     */
    cursor?: LeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leaderboards.
     */
    distinct?: LeaderboardScalarFieldEnum | LeaderboardScalarFieldEnum[]
  }

  /**
   * Leaderboard findFirstOrThrow
   */
  export type LeaderboardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which Leaderboard to fetch.
     */
    where?: LeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaderboards to fetch.
     */
    orderBy?: LeaderboardOrderByWithRelationInput | LeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leaderboards.
     */
    cursor?: LeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leaderboards.
     */
    distinct?: LeaderboardScalarFieldEnum | LeaderboardScalarFieldEnum[]
  }

  /**
   * Leaderboard findMany
   */
  export type LeaderboardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which Leaderboards to fetch.
     */
    where?: LeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaderboards to fetch.
     */
    orderBy?: LeaderboardOrderByWithRelationInput | LeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leaderboards.
     */
    cursor?: LeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaderboards.
     */
    skip?: number
    distinct?: LeaderboardScalarFieldEnum | LeaderboardScalarFieldEnum[]
  }

  /**
   * Leaderboard create
   */
  export type LeaderboardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * The data needed to create a Leaderboard.
     */
    data: XOR<LeaderboardCreateInput, LeaderboardUncheckedCreateInput>
  }

  /**
   * Leaderboard createMany
   */
  export type LeaderboardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leaderboards.
     */
    data: LeaderboardCreateManyInput | LeaderboardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Leaderboard createManyAndReturn
   */
  export type LeaderboardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Leaderboards.
     */
    data: LeaderboardCreateManyInput | LeaderboardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Leaderboard update
   */
  export type LeaderboardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * The data needed to update a Leaderboard.
     */
    data: XOR<LeaderboardUpdateInput, LeaderboardUncheckedUpdateInput>
    /**
     * Choose, which Leaderboard to update.
     */
    where: LeaderboardWhereUniqueInput
  }

  /**
   * Leaderboard updateMany
   */
  export type LeaderboardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leaderboards.
     */
    data: XOR<LeaderboardUpdateManyMutationInput, LeaderboardUncheckedUpdateManyInput>
    /**
     * Filter which Leaderboards to update
     */
    where?: LeaderboardWhereInput
  }

  /**
   * Leaderboard upsert
   */
  export type LeaderboardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * The filter to search for the Leaderboard to update in case it exists.
     */
    where: LeaderboardWhereUniqueInput
    /**
     * In case the Leaderboard found by the `where` argument doesn't exist, create a new Leaderboard with this data.
     */
    create: XOR<LeaderboardCreateInput, LeaderboardUncheckedCreateInput>
    /**
     * In case the Leaderboard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaderboardUpdateInput, LeaderboardUncheckedUpdateInput>
  }

  /**
   * Leaderboard delete
   */
  export type LeaderboardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * Filter which Leaderboard to delete.
     */
    where: LeaderboardWhereUniqueInput
  }

  /**
   * Leaderboard deleteMany
   */
  export type LeaderboardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leaderboards to delete
     */
    where?: LeaderboardWhereInput
  }

  /**
   * Leaderboard without action
   */
  export type LeaderboardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
  }


  /**
   * Model Wishlist
   */

  export type AggregateWishlist = {
    _count: WishlistCountAggregateOutputType | null
    _min: WishlistMinAggregateOutputType | null
    _max: WishlistMaxAggregateOutputType | null
  }

  export type WishlistMinAggregateOutputType = {
    id: string | null
    userId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WishlistMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WishlistCountAggregateOutputType = {
    id: number
    userId: number
    criteria: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WishlistMinAggregateInputType = {
    id?: true
    userId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WishlistMaxAggregateInputType = {
    id?: true
    userId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WishlistCountAggregateInputType = {
    id?: true
    userId?: true
    criteria?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WishlistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wishlist to aggregate.
     */
    where?: WishlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wishlists to fetch.
     */
    orderBy?: WishlistOrderByWithRelationInput | WishlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WishlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wishlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wishlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Wishlists
    **/
    _count?: true | WishlistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WishlistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WishlistMaxAggregateInputType
  }

  export type GetWishlistAggregateType<T extends WishlistAggregateArgs> = {
        [P in keyof T & keyof AggregateWishlist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWishlist[P]>
      : GetScalarType<T[P], AggregateWishlist[P]>
  }




  export type WishlistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WishlistWhereInput
    orderBy?: WishlistOrderByWithAggregationInput | WishlistOrderByWithAggregationInput[]
    by: WishlistScalarFieldEnum[] | WishlistScalarFieldEnum
    having?: WishlistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WishlistCountAggregateInputType | true
    _min?: WishlistMinAggregateInputType
    _max?: WishlistMaxAggregateInputType
  }

  export type WishlistGroupByOutputType = {
    id: string
    userId: string
    criteria: JsonValue
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: WishlistCountAggregateOutputType | null
    _min: WishlistMinAggregateOutputType | null
    _max: WishlistMaxAggregateOutputType | null
  }

  type GetWishlistGroupByPayload<T extends WishlistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WishlistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WishlistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WishlistGroupByOutputType[P]>
            : GetScalarType<T[P], WishlistGroupByOutputType[P]>
        }
      >
    >


  export type WishlistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    criteria?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wishlist"]>

  export type WishlistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    criteria?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wishlist"]>

  export type WishlistSelectScalar = {
    id?: boolean
    userId?: boolean
    criteria?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WishlistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WishlistIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WishlistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Wishlist"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      criteria: Prisma.JsonValue
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["wishlist"]>
    composites: {}
  }

  type WishlistGetPayload<S extends boolean | null | undefined | WishlistDefaultArgs> = $Result.GetResult<Prisma.$WishlistPayload, S>

  type WishlistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WishlistFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WishlistCountAggregateInputType | true
    }

  export interface WishlistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Wishlist'], meta: { name: 'Wishlist' } }
    /**
     * Find zero or one Wishlist that matches the filter.
     * @param {WishlistFindUniqueArgs} args - Arguments to find a Wishlist
     * @example
     * // Get one Wishlist
     * const wishlist = await prisma.wishlist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WishlistFindUniqueArgs>(args: SelectSubset<T, WishlistFindUniqueArgs<ExtArgs>>): Prisma__WishlistClient<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Wishlist that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WishlistFindUniqueOrThrowArgs} args - Arguments to find a Wishlist
     * @example
     * // Get one Wishlist
     * const wishlist = await prisma.wishlist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WishlistFindUniqueOrThrowArgs>(args: SelectSubset<T, WishlistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WishlistClient<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Wishlist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistFindFirstArgs} args - Arguments to find a Wishlist
     * @example
     * // Get one Wishlist
     * const wishlist = await prisma.wishlist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WishlistFindFirstArgs>(args?: SelectSubset<T, WishlistFindFirstArgs<ExtArgs>>): Prisma__WishlistClient<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Wishlist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistFindFirstOrThrowArgs} args - Arguments to find a Wishlist
     * @example
     * // Get one Wishlist
     * const wishlist = await prisma.wishlist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WishlistFindFirstOrThrowArgs>(args?: SelectSubset<T, WishlistFindFirstOrThrowArgs<ExtArgs>>): Prisma__WishlistClient<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Wishlists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wishlists
     * const wishlists = await prisma.wishlist.findMany()
     * 
     * // Get first 10 Wishlists
     * const wishlists = await prisma.wishlist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wishlistWithIdOnly = await prisma.wishlist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WishlistFindManyArgs>(args?: SelectSubset<T, WishlistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Wishlist.
     * @param {WishlistCreateArgs} args - Arguments to create a Wishlist.
     * @example
     * // Create one Wishlist
     * const Wishlist = await prisma.wishlist.create({
     *   data: {
     *     // ... data to create a Wishlist
     *   }
     * })
     * 
     */
    create<T extends WishlistCreateArgs>(args: SelectSubset<T, WishlistCreateArgs<ExtArgs>>): Prisma__WishlistClient<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Wishlists.
     * @param {WishlistCreateManyArgs} args - Arguments to create many Wishlists.
     * @example
     * // Create many Wishlists
     * const wishlist = await prisma.wishlist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WishlistCreateManyArgs>(args?: SelectSubset<T, WishlistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Wishlists and returns the data saved in the database.
     * @param {WishlistCreateManyAndReturnArgs} args - Arguments to create many Wishlists.
     * @example
     * // Create many Wishlists
     * const wishlist = await prisma.wishlist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Wishlists and only return the `id`
     * const wishlistWithIdOnly = await prisma.wishlist.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WishlistCreateManyAndReturnArgs>(args?: SelectSubset<T, WishlistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Wishlist.
     * @param {WishlistDeleteArgs} args - Arguments to delete one Wishlist.
     * @example
     * // Delete one Wishlist
     * const Wishlist = await prisma.wishlist.delete({
     *   where: {
     *     // ... filter to delete one Wishlist
     *   }
     * })
     * 
     */
    delete<T extends WishlistDeleteArgs>(args: SelectSubset<T, WishlistDeleteArgs<ExtArgs>>): Prisma__WishlistClient<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Wishlist.
     * @param {WishlistUpdateArgs} args - Arguments to update one Wishlist.
     * @example
     * // Update one Wishlist
     * const wishlist = await prisma.wishlist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WishlistUpdateArgs>(args: SelectSubset<T, WishlistUpdateArgs<ExtArgs>>): Prisma__WishlistClient<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Wishlists.
     * @param {WishlistDeleteManyArgs} args - Arguments to filter Wishlists to delete.
     * @example
     * // Delete a few Wishlists
     * const { count } = await prisma.wishlist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WishlistDeleteManyArgs>(args?: SelectSubset<T, WishlistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wishlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wishlists
     * const wishlist = await prisma.wishlist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WishlistUpdateManyArgs>(args: SelectSubset<T, WishlistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Wishlist.
     * @param {WishlistUpsertArgs} args - Arguments to update or create a Wishlist.
     * @example
     * // Update or create a Wishlist
     * const wishlist = await prisma.wishlist.upsert({
     *   create: {
     *     // ... data to create a Wishlist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wishlist we want to update
     *   }
     * })
     */
    upsert<T extends WishlistUpsertArgs>(args: SelectSubset<T, WishlistUpsertArgs<ExtArgs>>): Prisma__WishlistClient<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Wishlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistCountArgs} args - Arguments to filter Wishlists to count.
     * @example
     * // Count the number of Wishlists
     * const count = await prisma.wishlist.count({
     *   where: {
     *     // ... the filter for the Wishlists we want to count
     *   }
     * })
    **/
    count<T extends WishlistCountArgs>(
      args?: Subset<T, WishlistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WishlistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wishlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WishlistAggregateArgs>(args: Subset<T, WishlistAggregateArgs>): Prisma.PrismaPromise<GetWishlistAggregateType<T>>

    /**
     * Group by Wishlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WishlistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WishlistGroupByArgs['orderBy'] }
        : { orderBy?: WishlistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WishlistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWishlistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Wishlist model
   */
  readonly fields: WishlistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Wishlist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WishlistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Wishlist model
   */ 
  interface WishlistFieldRefs {
    readonly id: FieldRef<"Wishlist", 'String'>
    readonly userId: FieldRef<"Wishlist", 'String'>
    readonly criteria: FieldRef<"Wishlist", 'Json'>
    readonly isActive: FieldRef<"Wishlist", 'Boolean'>
    readonly createdAt: FieldRef<"Wishlist", 'DateTime'>
    readonly updatedAt: FieldRef<"Wishlist", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Wishlist findUnique
   */
  export type WishlistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * Filter, which Wishlist to fetch.
     */
    where: WishlistWhereUniqueInput
  }

  /**
   * Wishlist findUniqueOrThrow
   */
  export type WishlistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * Filter, which Wishlist to fetch.
     */
    where: WishlistWhereUniqueInput
  }

  /**
   * Wishlist findFirst
   */
  export type WishlistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * Filter, which Wishlist to fetch.
     */
    where?: WishlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wishlists to fetch.
     */
    orderBy?: WishlistOrderByWithRelationInput | WishlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wishlists.
     */
    cursor?: WishlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wishlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wishlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wishlists.
     */
    distinct?: WishlistScalarFieldEnum | WishlistScalarFieldEnum[]
  }

  /**
   * Wishlist findFirstOrThrow
   */
  export type WishlistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * Filter, which Wishlist to fetch.
     */
    where?: WishlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wishlists to fetch.
     */
    orderBy?: WishlistOrderByWithRelationInput | WishlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wishlists.
     */
    cursor?: WishlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wishlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wishlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wishlists.
     */
    distinct?: WishlistScalarFieldEnum | WishlistScalarFieldEnum[]
  }

  /**
   * Wishlist findMany
   */
  export type WishlistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * Filter, which Wishlists to fetch.
     */
    where?: WishlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wishlists to fetch.
     */
    orderBy?: WishlistOrderByWithRelationInput | WishlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Wishlists.
     */
    cursor?: WishlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wishlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wishlists.
     */
    skip?: number
    distinct?: WishlistScalarFieldEnum | WishlistScalarFieldEnum[]
  }

  /**
   * Wishlist create
   */
  export type WishlistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * The data needed to create a Wishlist.
     */
    data: XOR<WishlistCreateInput, WishlistUncheckedCreateInput>
  }

  /**
   * Wishlist createMany
   */
  export type WishlistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Wishlists.
     */
    data: WishlistCreateManyInput | WishlistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Wishlist createManyAndReturn
   */
  export type WishlistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Wishlists.
     */
    data: WishlistCreateManyInput | WishlistCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Wishlist update
   */
  export type WishlistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * The data needed to update a Wishlist.
     */
    data: XOR<WishlistUpdateInput, WishlistUncheckedUpdateInput>
    /**
     * Choose, which Wishlist to update.
     */
    where: WishlistWhereUniqueInput
  }

  /**
   * Wishlist updateMany
   */
  export type WishlistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Wishlists.
     */
    data: XOR<WishlistUpdateManyMutationInput, WishlistUncheckedUpdateManyInput>
    /**
     * Filter which Wishlists to update
     */
    where?: WishlistWhereInput
  }

  /**
   * Wishlist upsert
   */
  export type WishlistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * The filter to search for the Wishlist to update in case it exists.
     */
    where: WishlistWhereUniqueInput
    /**
     * In case the Wishlist found by the `where` argument doesn't exist, create a new Wishlist with this data.
     */
    create: XOR<WishlistCreateInput, WishlistUncheckedCreateInput>
    /**
     * In case the Wishlist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WishlistUpdateInput, WishlistUncheckedUpdateInput>
  }

  /**
   * Wishlist delete
   */
  export type WishlistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * Filter which Wishlist to delete.
     */
    where: WishlistWhereUniqueInput
  }

  /**
   * Wishlist deleteMany
   */
  export type WishlistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wishlists to delete
     */
    where?: WishlistWhereInput
  }

  /**
   * Wishlist without action
   */
  export type WishlistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
  }


  /**
   * Model ProfileExport
   */

  export type AggregateProfileExport = {
    _count: ProfileExportCountAggregateOutputType | null
    _min: ProfileExportMinAggregateOutputType | null
    _max: ProfileExportMaxAggregateOutputType | null
  }

  export type ProfileExportMinAggregateOutputType = {
    id: string | null
    userId: string | null
    format: string | null
    url: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type ProfileExportMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    format: string | null
    url: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type ProfileExportCountAggregateOutputType = {
    id: number
    userId: number
    format: number
    url: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type ProfileExportMinAggregateInputType = {
    id?: true
    userId?: true
    format?: true
    url?: true
    expiresAt?: true
    createdAt?: true
  }

  export type ProfileExportMaxAggregateInputType = {
    id?: true
    userId?: true
    format?: true
    url?: true
    expiresAt?: true
    createdAt?: true
  }

  export type ProfileExportCountAggregateInputType = {
    id?: true
    userId?: true
    format?: true
    url?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type ProfileExportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileExport to aggregate.
     */
    where?: ProfileExportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileExports to fetch.
     */
    orderBy?: ProfileExportOrderByWithRelationInput | ProfileExportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileExportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileExports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileExports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProfileExports
    **/
    _count?: true | ProfileExportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileExportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileExportMaxAggregateInputType
  }

  export type GetProfileExportAggregateType<T extends ProfileExportAggregateArgs> = {
        [P in keyof T & keyof AggregateProfileExport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfileExport[P]>
      : GetScalarType<T[P], AggregateProfileExport[P]>
  }




  export type ProfileExportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileExportWhereInput
    orderBy?: ProfileExportOrderByWithAggregationInput | ProfileExportOrderByWithAggregationInput[]
    by: ProfileExportScalarFieldEnum[] | ProfileExportScalarFieldEnum
    having?: ProfileExportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileExportCountAggregateInputType | true
    _min?: ProfileExportMinAggregateInputType
    _max?: ProfileExportMaxAggregateInputType
  }

  export type ProfileExportGroupByOutputType = {
    id: string
    userId: string
    format: string
    url: string
    expiresAt: Date
    createdAt: Date
    _count: ProfileExportCountAggregateOutputType | null
    _min: ProfileExportMinAggregateOutputType | null
    _max: ProfileExportMaxAggregateOutputType | null
  }

  type GetProfileExportGroupByPayload<T extends ProfileExportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileExportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileExportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileExportGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileExportGroupByOutputType[P]>
        }
      >
    >


  export type ProfileExportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    format?: boolean
    url?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileExport"]>

  export type ProfileExportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    format?: boolean
    url?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileExport"]>

  export type ProfileExportSelectScalar = {
    id?: boolean
    userId?: boolean
    format?: boolean
    url?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type ProfileExportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProfileExportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProfileExportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProfileExport"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      format: string
      url: string
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["profileExport"]>
    composites: {}
  }

  type ProfileExportGetPayload<S extends boolean | null | undefined | ProfileExportDefaultArgs> = $Result.GetResult<Prisma.$ProfileExportPayload, S>

  type ProfileExportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfileExportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfileExportCountAggregateInputType | true
    }

  export interface ProfileExportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProfileExport'], meta: { name: 'ProfileExport' } }
    /**
     * Find zero or one ProfileExport that matches the filter.
     * @param {ProfileExportFindUniqueArgs} args - Arguments to find a ProfileExport
     * @example
     * // Get one ProfileExport
     * const profileExport = await prisma.profileExport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileExportFindUniqueArgs>(args: SelectSubset<T, ProfileExportFindUniqueArgs<ExtArgs>>): Prisma__ProfileExportClient<$Result.GetResult<Prisma.$ProfileExportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProfileExport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProfileExportFindUniqueOrThrowArgs} args - Arguments to find a ProfileExport
     * @example
     * // Get one ProfileExport
     * const profileExport = await prisma.profileExport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileExportFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileExportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileExportClient<$Result.GetResult<Prisma.$ProfileExportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProfileExport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileExportFindFirstArgs} args - Arguments to find a ProfileExport
     * @example
     * // Get one ProfileExport
     * const profileExport = await prisma.profileExport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileExportFindFirstArgs>(args?: SelectSubset<T, ProfileExportFindFirstArgs<ExtArgs>>): Prisma__ProfileExportClient<$Result.GetResult<Prisma.$ProfileExportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProfileExport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileExportFindFirstOrThrowArgs} args - Arguments to find a ProfileExport
     * @example
     * // Get one ProfileExport
     * const profileExport = await prisma.profileExport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileExportFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileExportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileExportClient<$Result.GetResult<Prisma.$ProfileExportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProfileExports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileExportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProfileExports
     * const profileExports = await prisma.profileExport.findMany()
     * 
     * // Get first 10 ProfileExports
     * const profileExports = await prisma.profileExport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileExportWithIdOnly = await prisma.profileExport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileExportFindManyArgs>(args?: SelectSubset<T, ProfileExportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileExportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProfileExport.
     * @param {ProfileExportCreateArgs} args - Arguments to create a ProfileExport.
     * @example
     * // Create one ProfileExport
     * const ProfileExport = await prisma.profileExport.create({
     *   data: {
     *     // ... data to create a ProfileExport
     *   }
     * })
     * 
     */
    create<T extends ProfileExportCreateArgs>(args: SelectSubset<T, ProfileExportCreateArgs<ExtArgs>>): Prisma__ProfileExportClient<$Result.GetResult<Prisma.$ProfileExportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProfileExports.
     * @param {ProfileExportCreateManyArgs} args - Arguments to create many ProfileExports.
     * @example
     * // Create many ProfileExports
     * const profileExport = await prisma.profileExport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileExportCreateManyArgs>(args?: SelectSubset<T, ProfileExportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProfileExports and returns the data saved in the database.
     * @param {ProfileExportCreateManyAndReturnArgs} args - Arguments to create many ProfileExports.
     * @example
     * // Create many ProfileExports
     * const profileExport = await prisma.profileExport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProfileExports and only return the `id`
     * const profileExportWithIdOnly = await prisma.profileExport.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileExportCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileExportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileExportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProfileExport.
     * @param {ProfileExportDeleteArgs} args - Arguments to delete one ProfileExport.
     * @example
     * // Delete one ProfileExport
     * const ProfileExport = await prisma.profileExport.delete({
     *   where: {
     *     // ... filter to delete one ProfileExport
     *   }
     * })
     * 
     */
    delete<T extends ProfileExportDeleteArgs>(args: SelectSubset<T, ProfileExportDeleteArgs<ExtArgs>>): Prisma__ProfileExportClient<$Result.GetResult<Prisma.$ProfileExportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProfileExport.
     * @param {ProfileExportUpdateArgs} args - Arguments to update one ProfileExport.
     * @example
     * // Update one ProfileExport
     * const profileExport = await prisma.profileExport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileExportUpdateArgs>(args: SelectSubset<T, ProfileExportUpdateArgs<ExtArgs>>): Prisma__ProfileExportClient<$Result.GetResult<Prisma.$ProfileExportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProfileExports.
     * @param {ProfileExportDeleteManyArgs} args - Arguments to filter ProfileExports to delete.
     * @example
     * // Delete a few ProfileExports
     * const { count } = await prisma.profileExport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileExportDeleteManyArgs>(args?: SelectSubset<T, ProfileExportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfileExports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileExportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProfileExports
     * const profileExport = await prisma.profileExport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileExportUpdateManyArgs>(args: SelectSubset<T, ProfileExportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProfileExport.
     * @param {ProfileExportUpsertArgs} args - Arguments to update or create a ProfileExport.
     * @example
     * // Update or create a ProfileExport
     * const profileExport = await prisma.profileExport.upsert({
     *   create: {
     *     // ... data to create a ProfileExport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProfileExport we want to update
     *   }
     * })
     */
    upsert<T extends ProfileExportUpsertArgs>(args: SelectSubset<T, ProfileExportUpsertArgs<ExtArgs>>): Prisma__ProfileExportClient<$Result.GetResult<Prisma.$ProfileExportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProfileExports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileExportCountArgs} args - Arguments to filter ProfileExports to count.
     * @example
     * // Count the number of ProfileExports
     * const count = await prisma.profileExport.count({
     *   where: {
     *     // ... the filter for the ProfileExports we want to count
     *   }
     * })
    **/
    count<T extends ProfileExportCountArgs>(
      args?: Subset<T, ProfileExportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileExportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProfileExport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileExportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileExportAggregateArgs>(args: Subset<T, ProfileExportAggregateArgs>): Prisma.PrismaPromise<GetProfileExportAggregateType<T>>

    /**
     * Group by ProfileExport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileExportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileExportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileExportGroupByArgs['orderBy'] }
        : { orderBy?: ProfileExportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileExportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileExportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProfileExport model
   */
  readonly fields: ProfileExportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProfileExport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileExportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProfileExport model
   */ 
  interface ProfileExportFieldRefs {
    readonly id: FieldRef<"ProfileExport", 'String'>
    readonly userId: FieldRef<"ProfileExport", 'String'>
    readonly format: FieldRef<"ProfileExport", 'String'>
    readonly url: FieldRef<"ProfileExport", 'String'>
    readonly expiresAt: FieldRef<"ProfileExport", 'DateTime'>
    readonly createdAt: FieldRef<"ProfileExport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProfileExport findUnique
   */
  export type ProfileExportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileExport
     */
    select?: ProfileExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileExportInclude<ExtArgs> | null
    /**
     * Filter, which ProfileExport to fetch.
     */
    where: ProfileExportWhereUniqueInput
  }

  /**
   * ProfileExport findUniqueOrThrow
   */
  export type ProfileExportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileExport
     */
    select?: ProfileExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileExportInclude<ExtArgs> | null
    /**
     * Filter, which ProfileExport to fetch.
     */
    where: ProfileExportWhereUniqueInput
  }

  /**
   * ProfileExport findFirst
   */
  export type ProfileExportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileExport
     */
    select?: ProfileExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileExportInclude<ExtArgs> | null
    /**
     * Filter, which ProfileExport to fetch.
     */
    where?: ProfileExportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileExports to fetch.
     */
    orderBy?: ProfileExportOrderByWithRelationInput | ProfileExportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileExports.
     */
    cursor?: ProfileExportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileExports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileExports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileExports.
     */
    distinct?: ProfileExportScalarFieldEnum | ProfileExportScalarFieldEnum[]
  }

  /**
   * ProfileExport findFirstOrThrow
   */
  export type ProfileExportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileExport
     */
    select?: ProfileExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileExportInclude<ExtArgs> | null
    /**
     * Filter, which ProfileExport to fetch.
     */
    where?: ProfileExportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileExports to fetch.
     */
    orderBy?: ProfileExportOrderByWithRelationInput | ProfileExportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileExports.
     */
    cursor?: ProfileExportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileExports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileExports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileExports.
     */
    distinct?: ProfileExportScalarFieldEnum | ProfileExportScalarFieldEnum[]
  }

  /**
   * ProfileExport findMany
   */
  export type ProfileExportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileExport
     */
    select?: ProfileExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileExportInclude<ExtArgs> | null
    /**
     * Filter, which ProfileExports to fetch.
     */
    where?: ProfileExportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileExports to fetch.
     */
    orderBy?: ProfileExportOrderByWithRelationInput | ProfileExportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProfileExports.
     */
    cursor?: ProfileExportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileExports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileExports.
     */
    skip?: number
    distinct?: ProfileExportScalarFieldEnum | ProfileExportScalarFieldEnum[]
  }

  /**
   * ProfileExport create
   */
  export type ProfileExportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileExport
     */
    select?: ProfileExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileExportInclude<ExtArgs> | null
    /**
     * The data needed to create a ProfileExport.
     */
    data: XOR<ProfileExportCreateInput, ProfileExportUncheckedCreateInput>
  }

  /**
   * ProfileExport createMany
   */
  export type ProfileExportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProfileExports.
     */
    data: ProfileExportCreateManyInput | ProfileExportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProfileExport createManyAndReturn
   */
  export type ProfileExportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileExport
     */
    select?: ProfileExportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProfileExports.
     */
    data: ProfileExportCreateManyInput | ProfileExportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileExportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProfileExport update
   */
  export type ProfileExportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileExport
     */
    select?: ProfileExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileExportInclude<ExtArgs> | null
    /**
     * The data needed to update a ProfileExport.
     */
    data: XOR<ProfileExportUpdateInput, ProfileExportUncheckedUpdateInput>
    /**
     * Choose, which ProfileExport to update.
     */
    where: ProfileExportWhereUniqueInput
  }

  /**
   * ProfileExport updateMany
   */
  export type ProfileExportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProfileExports.
     */
    data: XOR<ProfileExportUpdateManyMutationInput, ProfileExportUncheckedUpdateManyInput>
    /**
     * Filter which ProfileExports to update
     */
    where?: ProfileExportWhereInput
  }

  /**
   * ProfileExport upsert
   */
  export type ProfileExportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileExport
     */
    select?: ProfileExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileExportInclude<ExtArgs> | null
    /**
     * The filter to search for the ProfileExport to update in case it exists.
     */
    where: ProfileExportWhereUniqueInput
    /**
     * In case the ProfileExport found by the `where` argument doesn't exist, create a new ProfileExport with this data.
     */
    create: XOR<ProfileExportCreateInput, ProfileExportUncheckedCreateInput>
    /**
     * In case the ProfileExport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileExportUpdateInput, ProfileExportUncheckedUpdateInput>
  }

  /**
   * ProfileExport delete
   */
  export type ProfileExportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileExport
     */
    select?: ProfileExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileExportInclude<ExtArgs> | null
    /**
     * Filter which ProfileExport to delete.
     */
    where: ProfileExportWhereUniqueInput
  }

  /**
   * ProfileExport deleteMany
   */
  export type ProfileExportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileExports to delete
     */
    where?: ProfileExportWhereInput
  }

  /**
   * ProfileExport without action
   */
  export type ProfileExportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileExport
     */
    select?: ProfileExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileExportInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    mobile: 'mobile',
    password: 'password',
    role: 'role',
    isEmailVerified: 'isEmailVerified',
    isMobileVerified: 'isMobileVerified',
    googleId: 'googleId',
    appleId: 'appleId',
    fcmToken: 'fcmToken',
    referralCode: 'referralCode',
    referredBy: 'referredBy',
    points: 'points',
    lastActiveAt: 'lastActiveAt',
    isOnline: 'isOnline',
    lastLoginDate: 'lastLoginDate',
    loginStreak: 'loginStreak',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastLoginAt: 'lastLoginAt',
    gdprConsent: 'gdprConsent',
    gdprConsentAt: 'gdprConsentAt',
    deletedAt: 'deletedAt',
    preferredLanguage: 'preferredLanguage',
    notificationPreferences: 'notificationPreferences'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    status: 'status',
    firstName: 'firstName',
    lastName: 'lastName',
    gender: 'gender',
    dateOfBirth: 'dateOfBirth',
    height: 'height',
    maritalStatus: 'maritalStatus',
    religion: 'religion',
    caste: 'caste',
    motherTongue: 'motherTongue',
    manglik: 'manglik',
    gothra: 'gothra',
    country: 'country',
    state: 'state',
    city: 'city',
    citizenship: 'citizenship',
    education: 'education',
    college: 'college',
    occupation: 'occupation',
    income: 'income',
    incomeCurrency: 'incomeCurrency',
    fatherOccupation: 'fatherOccupation',
    motherOccupation: 'motherOccupation',
    siblings: 'siblings',
    familyType: 'familyType',
    diet: 'diet',
    smoking: 'smoking',
    drinking: 'drinking',
    hobbies: 'hobbies',
    partnerPreferences: 'partnerPreferences',
    videoIntroUrl: 'videoIntroUrl',
    biodataUrl: 'biodataUrl',
    aboutMe: 'aboutMe',
    highlights: 'highlights',
    latitude: 'latitude',
    longitude: 'longitude',
    privacySettings: 'privacySettings',
    isHiddenFromSearch: 'isHiddenFromSearch',
    isAnonymousViewing: 'isAnonymousViewing',
    contactPrivacyLevel: 'contactPrivacyLevel',
    photoPrivacyLevel: 'photoPrivacyLevel',
    isVerified: 'isVerified',
    verifiedAt: 'verifiedAt',
    trustScore: 'trustScore',
    completenessScore: 'completenessScore',
    isHighlighted: 'isHighlighted',
    slug: 'slug',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const PhotoScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    url: 'url',
    cloudinaryId: 'cloudinaryId',
    isPrimary: 'isPrimary',
    isBlurred: 'isBlurred',
    isApproved: 'isApproved',
    order: 'order',
    albumName: 'albumName',
    caption: 'caption',
    createdAt: 'createdAt'
  };

  export type PhotoScalarFieldEnum = (typeof PhotoScalarFieldEnum)[keyof typeof PhotoScalarFieldEnum]


  export const VerificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    idType: 'idType',
    idNumber: 'idNumber',
    idPhotoUrl: 'idPhotoUrl',
    selfieUrl: 'selfieUrl',
    status: 'status',
    reviewedBy: 'reviewedBy',
    reviewedAt: 'reviewedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const InterestScalarFieldEnum: {
    id: 'id',
    fromUserId: 'fromUserId',
    toUserId: 'toUserId',
    status: 'status',
    message: 'message',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InterestScalarFieldEnum = (typeof InterestScalarFieldEnum)[keyof typeof InterestScalarFieldEnum]


  export const ChatScalarFieldEnum: {
    id: 'id',
    user1Id: 'user1Id',
    user2Id: 'user2Id',
    lastMessageAt: 'lastMessageAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChatScalarFieldEnum = (typeof ChatScalarFieldEnum)[keyof typeof ChatScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    chatId: 'chatId',
    senderId: 'senderId',
    content: 'content',
    imageUrl: 'imageUrl',
    videoUrl: 'videoUrl',
    audioUrl: 'audioUrl',
    fileUrl: 'fileUrl',
    fileName: 'fileName',
    messageType: 'messageType',
    isRead: 'isRead',
    isDeleted: 'isDeleted',
    deletedBy: 'deletedBy',
    isReported: 'isReported',
    createdAt: 'createdAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const ProfileViewScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    viewedById: 'viewedById',
    createdAt: 'createdAt'
  };

  export type ProfileViewScalarFieldEnum = (typeof ProfileViewScalarFieldEnum)[keyof typeof ProfileViewScalarFieldEnum]


  export const ContactViewScalarFieldEnum: {
    id: 'id',
    subscriptionId: 'subscriptionId',
    profileId: 'profileId',
    viewedById: 'viewedById',
    createdAt: 'createdAt'
  };

  export type ContactViewScalarFieldEnum = (typeof ContactViewScalarFieldEnum)[keyof typeof ContactViewScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    plan: 'plan',
    razorpaySubscriptionId: 'razorpaySubscriptionId',
    razorpayPlanId: 'razorpayPlanId',
    status: 'status',
    startDate: 'startDate',
    endDate: 'endDate',
    contactViewsUsed: 'contactViewsUsed',
    contactViewsLimit: 'contactViewsLimit',
    profileBoostCredits: 'profileBoostCredits',
    verifiedBadgeIncluded: 'verifiedBadgeIncluded',
    horoscopeReportsIncluded: 'horoscopeReportsIncluded',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    razorpayOrderId: 'razorpayOrderId',
    razorpayPaymentId: 'razorpayPaymentId',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    type: 'type',
    addOnType: 'addOnType',
    subscriptionId: 'subscriptionId',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const AddOnScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    paymentId: 'paymentId',
    expiresAt: 'expiresAt',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type AddOnScalarFieldEnum = (typeof AddOnScalarFieldEnum)[keyof typeof AddOnScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    status: 'status',
    paymentId: 'paymentId',
    amount: 'amount',
    metadata: 'metadata',
    scheduledAt: 'scheduledAt',
    completedAt: 'completedAt',
    notes: 'notes',
    rating: 'rating',
    review: 'review',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const ServiceProviderScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    mobile: 'mobile',
    serviceType: 'serviceType',
    expertise: 'expertise',
    rating: 'rating',
    totalBookings: 'totalBookings',
    isActive: 'isActive',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceProviderScalarFieldEnum = (typeof ServiceProviderScalarFieldEnum)[keyof typeof ServiceProviderScalarFieldEnum]


  export const ServiceBookingScalarFieldEnum: {
    id: 'id',
    serviceId: 'serviceId',
    providerId: 'providerId',
    userId: 'userId',
    scheduledAt: 'scheduledAt',
    duration: 'duration',
    status: 'status',
    meetingLink: 'meetingLink',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceBookingScalarFieldEnum = (typeof ServiceBookingScalarFieldEnum)[keyof typeof ServiceBookingScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    message: 'message',
    isRead: 'isRead',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SavedSearchScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    filters: 'filters',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SavedSearchScalarFieldEnum = (typeof SavedSearchScalarFieldEnum)[keyof typeof SavedSearchScalarFieldEnum]


  export const OTPScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    code: 'code',
    type: 'type',
    expiresAt: 'expiresAt',
    isUsed: 'isUsed',
    createdAt: 'createdAt'
  };

  export type OTPScalarFieldEnum = (typeof OTPScalarFieldEnum)[keyof typeof OTPScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    reporterId: 'reporterId',
    reportedUserId: 'reportedUserId',
    type: 'type',
    reason: 'reason',
    description: 'description',
    status: 'status',
    reviewedBy: 'reviewedBy',
    reviewedAt: 'reviewedAt',
    createdAt: 'createdAt'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const ShortlistScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    profileId: 'profileId',
    folderName: 'folderName',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShortlistScalarFieldEnum = (typeof ShortlistScalarFieldEnum)[keyof typeof ShortlistScalarFieldEnum]


  export const BlockedUserScalarFieldEnum: {
    id: 'id',
    blockerId: 'blockerId',
    blockedId: 'blockedId',
    reason: 'reason',
    createdAt: 'createdAt'
  };

  export type BlockedUserScalarFieldEnum = (typeof BlockedUserScalarFieldEnum)[keyof typeof BlockedUserScalarFieldEnum]


  export const HoroscopeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    profileId: 'profileId',
    horoscopeUrl: 'horoscopeUrl',
    birthTime: 'birthTime',
    birthPlace: 'birthPlace',
    rashi: 'rashi',
    nakshatra: 'nakshatra',
    mangalDosha: 'mangalDosha',
    horoscopeData: 'horoscopeData',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HoroscopeScalarFieldEnum = (typeof HoroscopeScalarFieldEnum)[keyof typeof HoroscopeScalarFieldEnum]


  export const HoroscopeMatchScalarFieldEnum: {
    id: 'id',
    user1Id: 'user1Id',
    user2Id: 'user2Id',
    horoscope1Id: 'horoscope1Id',
    horoscope2Id: 'horoscope2Id',
    ashtakootScore: 'ashtakootScore',
    mangalDoshaMatch: 'mangalDoshaMatch',
    overallScore: 'overallScore',
    matchDetails: 'matchDetails',
    createdAt: 'createdAt'
  };

  export type HoroscopeMatchScalarFieldEnum = (typeof HoroscopeMatchScalarFieldEnum)[keyof typeof HoroscopeMatchScalarFieldEnum]


  export const SuccessStoryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    partnerId: 'partnerId',
    title: 'title',
    story: 'story',
    weddingDate: 'weddingDate',
    photos: 'photos',
    isApproved: 'isApproved',
    isFeatured: 'isFeatured',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SuccessStoryScalarFieldEnum = (typeof SuccessStoryScalarFieldEnum)[keyof typeof SuccessStoryScalarFieldEnum]


  export const FamilyMemberScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    relation: 'relation',
    email: 'email',
    mobile: 'mobile',
    password: 'password',
    canViewMatches: 'canViewMatches',
    canSendInterests: 'canSendInterests',
    canChat: 'canChat',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FamilyMemberScalarFieldEnum = (typeof FamilyMemberScalarFieldEnum)[keyof typeof FamilyMemberScalarFieldEnum]


  export const ReferralScalarFieldEnum: {
    id: 'id',
    referrerId: 'referrerId',
    referredId: 'referredId',
    rewardAmount: 'rewardAmount',
    status: 'status',
    completedAt: 'completedAt',
    createdAt: 'createdAt'
  };

  export type ReferralScalarFieldEnum = (typeof ReferralScalarFieldEnum)[keyof typeof ReferralScalarFieldEnum]


  export const AchievementScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    description: 'description',
    points: 'points',
    icon: 'icon',
    unlockedAt: 'unlockedAt'
  };

  export type AchievementScalarFieldEnum = (typeof AchievementScalarFieldEnum)[keyof typeof AchievementScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    name: 'name',
    url: 'url',
    expiryDate: 'expiryDate',
    isVerified: 'isVerified',
    verifiedAt: 'verifiedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const VideoCallScalarFieldEnum: {
    id: 'id',
    callerId: 'callerId',
    participantId: 'participantId',
    status: 'status',
    scheduledAt: 'scheduledAt',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    cancelledAt: 'cancelledAt',
    duration: 'duration',
    roomId: 'roomId',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VideoCallScalarFieldEnum = (typeof VideoCallScalarFieldEnum)[keyof typeof VideoCallScalarFieldEnum]


  export const ProfileComparisonScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    profileId: 'profileId',
    comparisonData: 'comparisonData',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type ProfileComparisonScalarFieldEnum = (typeof ProfileComparisonScalarFieldEnum)[keyof typeof ProfileComparisonScalarFieldEnum]


  export const ForumPostScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    content: 'content',
    category: 'category',
    tags: 'tags',
    likes: 'likes',
    views: 'views',
    isPinned: 'isPinned',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ForumPostScalarFieldEnum = (typeof ForumPostScalarFieldEnum)[keyof typeof ForumPostScalarFieldEnum]


  export const ForumCommentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    postId: 'postId',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ForumCommentScalarFieldEnum = (typeof ForumCommentScalarFieldEnum)[keyof typeof ForumCommentScalarFieldEnum]


  export const CommunityGroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    photoUrl: 'photoUrl',
    isPublic: 'isPublic',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommunityGroupScalarFieldEnum = (typeof CommunityGroupScalarFieldEnum)[keyof typeof CommunityGroupScalarFieldEnum]


  export const GroupMemberScalarFieldEnum: {
    id: 'id',
    groupId: 'groupId',
    userId: 'userId',
    role: 'role',
    joinedAt: 'joinedAt'
  };

  export type GroupMemberScalarFieldEnum = (typeof GroupMemberScalarFieldEnum)[keyof typeof GroupMemberScalarFieldEnum]


  export const CommunityEventScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    eventDate: 'eventDate',
    location: 'location',
    photoUrl: 'photoUrl',
    maxParticipants: 'maxParticipants',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommunityEventScalarFieldEnum = (typeof CommunityEventScalarFieldEnum)[keyof typeof CommunityEventScalarFieldEnum]


  export const EventParticipantScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    userId: 'userId',
    joinedAt: 'joinedAt'
  };

  export type EventParticipantScalarFieldEnum = (typeof EventParticipantScalarFieldEnum)[keyof typeof EventParticipantScalarFieldEnum]


  export const BlogPostScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    content: 'content',
    excerpt: 'excerpt',
    photoUrl: 'photoUrl',
    tags: 'tags',
    isPublished: 'isPublished',
    views: 'views',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BlogPostScalarFieldEnum = (typeof BlogPostScalarFieldEnum)[keyof typeof BlogPostScalarFieldEnum]


  export const MatchScoreScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    matchedUserId: 'matchedUserId',
    overallScore: 'overallScore',
    religionScore: 'religionScore',
    educationScore: 'educationScore',
    lifestyleScore: 'lifestyleScore',
    locationScore: 'locationScore',
    familyScore: 'familyScore',
    matchReasons: 'matchReasons',
    isReverseMatch: 'isReverseMatch',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MatchScoreScalarFieldEnum = (typeof MatchScoreScalarFieldEnum)[keyof typeof MatchScoreScalarFieldEnum]


  export const SearchHistoryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    profileId: 'profileId',
    searchQuery: 'searchQuery',
    filters: 'filters',
    createdAt: 'createdAt'
  };

  export type SearchHistoryScalarFieldEnum = (typeof SearchHistoryScalarFieldEnum)[keyof typeof SearchHistoryScalarFieldEnum]


  export const MessageTemplateScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    content: 'content',
    category: 'category',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MessageTemplateScalarFieldEnum = (typeof MessageTemplateScalarFieldEnum)[keyof typeof MessageTemplateScalarFieldEnum]


  export const IceBreakerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    profileId: 'profileId',
    question: 'question',
    answer: 'answer',
    createdAt: 'createdAt'
  };

  export type IceBreakerScalarFieldEnum = (typeof IceBreakerScalarFieldEnum)[keyof typeof IceBreakerScalarFieldEnum]


  export const TestimonialScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    authorName: 'authorName',
    authorRelation: 'authorRelation',
    authorEmail: 'authorEmail',
    content: 'content',
    rating: 'rating',
    isApproved: 'isApproved',
    createdAt: 'createdAt'
  };

  export type TestimonialScalarFieldEnum = (typeof TestimonialScalarFieldEnum)[keyof typeof TestimonialScalarFieldEnum]


  export const ActivityScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    description: 'description',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type ActivityScalarFieldEnum = (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum]


  export const LeaderboardScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    category: 'category',
    rank: 'rank',
    score: 'score',
    period: 'period',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    createdAt: 'createdAt'
  };

  export type LeaderboardScalarFieldEnum = (typeof LeaderboardScalarFieldEnum)[keyof typeof LeaderboardScalarFieldEnum]


  export const WishlistScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    criteria: 'criteria',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WishlistScalarFieldEnum = (typeof WishlistScalarFieldEnum)[keyof typeof WishlistScalarFieldEnum]


  export const ProfileExportScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    format: 'format',
    url: 'url',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type ProfileExportScalarFieldEnum = (typeof ProfileExportScalarFieldEnum)[keyof typeof ProfileExportScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'ProfileStatus'
   */
  export type EnumProfileStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProfileStatus'>
    


  /**
   * Reference to a field of type 'ProfileStatus[]'
   */
  export type ListEnumProfileStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProfileStatus[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'MaritalStatus'
   */
  export type EnumMaritalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaritalStatus'>
    


  /**
   * Reference to a field of type 'MaritalStatus[]'
   */
  export type ListEnumMaritalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaritalStatus[]'>
    


  /**
   * Reference to a field of type 'FamilyType'
   */
  export type EnumFamilyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FamilyType'>
    


  /**
   * Reference to a field of type 'FamilyType[]'
   */
  export type ListEnumFamilyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FamilyType[]'>
    


  /**
   * Reference to a field of type 'Diet'
   */
  export type EnumDietFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Diet'>
    


  /**
   * Reference to a field of type 'Diet[]'
   */
  export type ListEnumDietFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Diet[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'InterestStatus'
   */
  export type EnumInterestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InterestStatus'>
    


  /**
   * Reference to a field of type 'InterestStatus[]'
   */
  export type ListEnumInterestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InterestStatus[]'>
    


  /**
   * Reference to a field of type 'SubscriptionPlan'
   */
  export type EnumSubscriptionPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionPlan'>
    


  /**
   * Reference to a field of type 'SubscriptionPlan[]'
   */
  export type ListEnumSubscriptionPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionPlan[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'AddOnType'
   */
  export type EnumAddOnTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AddOnType'>
    


  /**
   * Reference to a field of type 'AddOnType[]'
   */
  export type ListEnumAddOnTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AddOnType[]'>
    


  /**
   * Reference to a field of type 'ServiceType'
   */
  export type EnumServiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceType'>
    


  /**
   * Reference to a field of type 'ServiceType[]'
   */
  export type ListEnumServiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceType[]'>
    


  /**
   * Reference to a field of type 'ServiceStatus'
   */
  export type EnumServiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceStatus'>
    


  /**
   * Reference to a field of type 'ServiceStatus[]'
   */
  export type ListEnumServiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    mobile?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isEmailVerified?: BoolFilter<"User"> | boolean
    isMobileVerified?: BoolFilter<"User"> | boolean
    googleId?: StringNullableFilter<"User"> | string | null
    appleId?: StringNullableFilter<"User"> | string | null
    fcmToken?: StringNullableFilter<"User"> | string | null
    referralCode?: StringNullableFilter<"User"> | string | null
    referredBy?: StringNullableFilter<"User"> | string | null
    points?: IntFilter<"User"> | number
    lastActiveAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isOnline?: BoolFilter<"User"> | boolean
    lastLoginDate?: DateTimeNullableFilter<"User"> | Date | string | null
    loginStreak?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    gdprConsent?: BoolFilter<"User"> | boolean
    gdprConsentAt?: DateTimeNullableFilter<"User"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    preferredLanguage?: StringNullableFilter<"User"> | string | null
    notificationPreferences?: JsonNullableFilter<"User">
    profile?: XOR<ProfileNullableRelationFilter, ProfileWhereInput> | null
    interests?: InterestListRelationFilter
    receivedInterests?: InterestListRelationFilter
    chats?: ChatListRelationFilter
    chats2?: ChatListRelationFilter
    messages?: MessageListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    payments?: PaymentListRelationFilter
    profileViews?: ProfileViewListRelationFilter
    sessions?: SessionListRelationFilter
    notifications?: NotificationListRelationFilter
    shortlists?: ShortlistListRelationFilter
    blockedUsers?: BlockedUserListRelationFilter
    blockedBy?: BlockedUserListRelationFilter
    referrals?: ReferralListRelationFilter
    referredByRef?: ReferralListRelationFilter
    referrer?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    referredUsers?: UserListRelationFilter
    achievements?: AchievementListRelationFilter
    horoscopes?: HoroscopeListRelationFilter
    familyMembers?: FamilyMemberListRelationFilter
    successStories?: SuccessStoryListRelationFilter
    documents?: DocumentListRelationFilter
    videoCallsAsCaller?: VideoCallListRelationFilter
    videoCallsAsParticipant?: VideoCallListRelationFilter
    forumPosts?: ForumPostListRelationFilter
    forumComments?: ForumCommentListRelationFilter
    groupMembers?: GroupMemberListRelationFilter
    eventParticipants?: EventParticipantListRelationFilter
    blogPosts?: BlogPostListRelationFilter
    matchScores?: MatchScoreListRelationFilter
    matchedBy?: MatchScoreListRelationFilter
    searchHistory?: SearchHistoryListRelationFilter
    messageTemplates?: MessageTemplateListRelationFilter
    iceBreakers?: IceBreakerListRelationFilter
    activities?: ActivityListRelationFilter
    leaderboard?: LeaderboardListRelationFilter
    wishlists?: WishlistListRelationFilter
    profileExports?: ProfileExportListRelationFilter
    services?: ServiceListRelationFilter
    serviceBookings?: ServiceBookingListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    mobile?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    role?: SortOrder
    isEmailVerified?: SortOrder
    isMobileVerified?: SortOrder
    googleId?: SortOrderInput | SortOrder
    appleId?: SortOrderInput | SortOrder
    fcmToken?: SortOrderInput | SortOrder
    referralCode?: SortOrderInput | SortOrder
    referredBy?: SortOrderInput | SortOrder
    points?: SortOrder
    lastActiveAt?: SortOrderInput | SortOrder
    isOnline?: SortOrder
    lastLoginDate?: SortOrderInput | SortOrder
    loginStreak?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    gdprConsent?: SortOrder
    gdprConsentAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    preferredLanguage?: SortOrderInput | SortOrder
    notificationPreferences?: SortOrderInput | SortOrder
    profile?: ProfileOrderByWithRelationInput
    interests?: InterestOrderByRelationAggregateInput
    receivedInterests?: InterestOrderByRelationAggregateInput
    chats?: ChatOrderByRelationAggregateInput
    chats2?: ChatOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
    subscriptions?: SubscriptionOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    profileViews?: ProfileViewOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    shortlists?: ShortlistOrderByRelationAggregateInput
    blockedUsers?: BlockedUserOrderByRelationAggregateInput
    blockedBy?: BlockedUserOrderByRelationAggregateInput
    referrals?: ReferralOrderByRelationAggregateInput
    referredByRef?: ReferralOrderByRelationAggregateInput
    referrer?: UserOrderByWithRelationInput
    referredUsers?: UserOrderByRelationAggregateInput
    achievements?: AchievementOrderByRelationAggregateInput
    horoscopes?: HoroscopeOrderByRelationAggregateInput
    familyMembers?: FamilyMemberOrderByRelationAggregateInput
    successStories?: SuccessStoryOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    videoCallsAsCaller?: VideoCallOrderByRelationAggregateInput
    videoCallsAsParticipant?: VideoCallOrderByRelationAggregateInput
    forumPosts?: ForumPostOrderByRelationAggregateInput
    forumComments?: ForumCommentOrderByRelationAggregateInput
    groupMembers?: GroupMemberOrderByRelationAggregateInput
    eventParticipants?: EventParticipantOrderByRelationAggregateInput
    blogPosts?: BlogPostOrderByRelationAggregateInput
    matchScores?: MatchScoreOrderByRelationAggregateInput
    matchedBy?: MatchScoreOrderByRelationAggregateInput
    searchHistory?: SearchHistoryOrderByRelationAggregateInput
    messageTemplates?: MessageTemplateOrderByRelationAggregateInput
    iceBreakers?: IceBreakerOrderByRelationAggregateInput
    activities?: ActivityOrderByRelationAggregateInput
    leaderboard?: LeaderboardOrderByRelationAggregateInput
    wishlists?: WishlistOrderByRelationAggregateInput
    profileExports?: ProfileExportOrderByRelationAggregateInput
    services?: ServiceOrderByRelationAggregateInput
    serviceBookings?: ServiceBookingOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    mobile?: string
    googleId?: string
    appleId?: string
    referralCode?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isEmailVerified?: BoolFilter<"User"> | boolean
    isMobileVerified?: BoolFilter<"User"> | boolean
    fcmToken?: StringNullableFilter<"User"> | string | null
    referredBy?: StringNullableFilter<"User"> | string | null
    points?: IntFilter<"User"> | number
    lastActiveAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isOnline?: BoolFilter<"User"> | boolean
    lastLoginDate?: DateTimeNullableFilter<"User"> | Date | string | null
    loginStreak?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    gdprConsent?: BoolFilter<"User"> | boolean
    gdprConsentAt?: DateTimeNullableFilter<"User"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    preferredLanguage?: StringNullableFilter<"User"> | string | null
    notificationPreferences?: JsonNullableFilter<"User">
    profile?: XOR<ProfileNullableRelationFilter, ProfileWhereInput> | null
    interests?: InterestListRelationFilter
    receivedInterests?: InterestListRelationFilter
    chats?: ChatListRelationFilter
    chats2?: ChatListRelationFilter
    messages?: MessageListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    payments?: PaymentListRelationFilter
    profileViews?: ProfileViewListRelationFilter
    sessions?: SessionListRelationFilter
    notifications?: NotificationListRelationFilter
    shortlists?: ShortlistListRelationFilter
    blockedUsers?: BlockedUserListRelationFilter
    blockedBy?: BlockedUserListRelationFilter
    referrals?: ReferralListRelationFilter
    referredByRef?: ReferralListRelationFilter
    referrer?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    referredUsers?: UserListRelationFilter
    achievements?: AchievementListRelationFilter
    horoscopes?: HoroscopeListRelationFilter
    familyMembers?: FamilyMemberListRelationFilter
    successStories?: SuccessStoryListRelationFilter
    documents?: DocumentListRelationFilter
    videoCallsAsCaller?: VideoCallListRelationFilter
    videoCallsAsParticipant?: VideoCallListRelationFilter
    forumPosts?: ForumPostListRelationFilter
    forumComments?: ForumCommentListRelationFilter
    groupMembers?: GroupMemberListRelationFilter
    eventParticipants?: EventParticipantListRelationFilter
    blogPosts?: BlogPostListRelationFilter
    matchScores?: MatchScoreListRelationFilter
    matchedBy?: MatchScoreListRelationFilter
    searchHistory?: SearchHistoryListRelationFilter
    messageTemplates?: MessageTemplateListRelationFilter
    iceBreakers?: IceBreakerListRelationFilter
    activities?: ActivityListRelationFilter
    leaderboard?: LeaderboardListRelationFilter
    wishlists?: WishlistListRelationFilter
    profileExports?: ProfileExportListRelationFilter
    services?: ServiceListRelationFilter
    serviceBookings?: ServiceBookingListRelationFilter
  }, "id" | "email" | "mobile" | "googleId" | "appleId" | "referralCode">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    mobile?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    role?: SortOrder
    isEmailVerified?: SortOrder
    isMobileVerified?: SortOrder
    googleId?: SortOrderInput | SortOrder
    appleId?: SortOrderInput | SortOrder
    fcmToken?: SortOrderInput | SortOrder
    referralCode?: SortOrderInput | SortOrder
    referredBy?: SortOrderInput | SortOrder
    points?: SortOrder
    lastActiveAt?: SortOrderInput | SortOrder
    isOnline?: SortOrder
    lastLoginDate?: SortOrderInput | SortOrder
    loginStreak?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    gdprConsent?: SortOrder
    gdprConsentAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    preferredLanguage?: SortOrderInput | SortOrder
    notificationPreferences?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    mobile?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isEmailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    isMobileVerified?: BoolWithAggregatesFilter<"User"> | boolean
    googleId?: StringNullableWithAggregatesFilter<"User"> | string | null
    appleId?: StringNullableWithAggregatesFilter<"User"> | string | null
    fcmToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    referralCode?: StringNullableWithAggregatesFilter<"User"> | string | null
    referredBy?: StringNullableWithAggregatesFilter<"User"> | string | null
    points?: IntWithAggregatesFilter<"User"> | number
    lastActiveAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    isOnline?: BoolWithAggregatesFilter<"User"> | boolean
    lastLoginDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    loginStreak?: IntWithAggregatesFilter<"User"> | number
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    gdprConsent?: BoolWithAggregatesFilter<"User"> | boolean
    gdprConsentAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    preferredLanguage?: StringNullableWithAggregatesFilter<"User"> | string | null
    notificationPreferences?: JsonNullableWithAggregatesFilter<"User">
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    token?: StringWithAggregatesFilter<"Session"> | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type ProfileWhereInput = {
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    id?: StringFilter<"Profile"> | string
    userId?: StringFilter<"Profile"> | string
    status?: EnumProfileStatusFilter<"Profile"> | $Enums.ProfileStatus
    firstName?: StringNullableFilter<"Profile"> | string | null
    lastName?: StringNullableFilter<"Profile"> | string | null
    gender?: EnumGenderNullableFilter<"Profile"> | $Enums.Gender | null
    dateOfBirth?: DateTimeNullableFilter<"Profile"> | Date | string | null
    height?: IntNullableFilter<"Profile"> | number | null
    maritalStatus?: EnumMaritalStatusNullableFilter<"Profile"> | $Enums.MaritalStatus | null
    religion?: StringNullableFilter<"Profile"> | string | null
    caste?: StringNullableFilter<"Profile"> | string | null
    motherTongue?: StringNullableFilter<"Profile"> | string | null
    manglik?: BoolNullableFilter<"Profile"> | boolean | null
    gothra?: StringNullableFilter<"Profile"> | string | null
    country?: StringNullableFilter<"Profile"> | string | null
    state?: StringNullableFilter<"Profile"> | string | null
    city?: StringNullableFilter<"Profile"> | string | null
    citizenship?: StringNullableFilter<"Profile"> | string | null
    education?: StringNullableFilter<"Profile"> | string | null
    college?: StringNullableFilter<"Profile"> | string | null
    occupation?: StringNullableFilter<"Profile"> | string | null
    income?: IntNullableFilter<"Profile"> | number | null
    incomeCurrency?: StringNullableFilter<"Profile"> | string | null
    fatherOccupation?: StringNullableFilter<"Profile"> | string | null
    motherOccupation?: StringNullableFilter<"Profile"> | string | null
    siblings?: IntNullableFilter<"Profile"> | number | null
    familyType?: EnumFamilyTypeNullableFilter<"Profile"> | $Enums.FamilyType | null
    diet?: EnumDietNullableFilter<"Profile"> | $Enums.Diet | null
    smoking?: BoolNullableFilter<"Profile"> | boolean | null
    drinking?: BoolNullableFilter<"Profile"> | boolean | null
    hobbies?: StringNullableFilter<"Profile"> | string | null
    partnerPreferences?: JsonNullableFilter<"Profile">
    videoIntroUrl?: StringNullableFilter<"Profile"> | string | null
    biodataUrl?: StringNullableFilter<"Profile"> | string | null
    aboutMe?: StringNullableFilter<"Profile"> | string | null
    highlights?: JsonNullableFilter<"Profile">
    latitude?: FloatNullableFilter<"Profile"> | number | null
    longitude?: FloatNullableFilter<"Profile"> | number | null
    privacySettings?: JsonNullableFilter<"Profile">
    isHiddenFromSearch?: BoolFilter<"Profile"> | boolean
    isAnonymousViewing?: BoolFilter<"Profile"> | boolean
    contactPrivacyLevel?: StringNullableFilter<"Profile"> | string | null
    photoPrivacyLevel?: StringNullableFilter<"Profile"> | string | null
    isVerified?: BoolFilter<"Profile"> | boolean
    verifiedAt?: DateTimeNullableFilter<"Profile"> | Date | string | null
    trustScore?: IntFilter<"Profile"> | number
    completenessScore?: IntFilter<"Profile"> | number
    isHighlighted?: BoolFilter<"Profile"> | boolean
    slug?: StringNullableFilter<"Profile"> | string | null
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
    photos?: PhotoListRelationFilter
    profileViews?: ProfileViewListRelationFilter
    shortlistedBy?: ShortlistListRelationFilter
    horoscope?: XOR<HoroscopeNullableRelationFilter, HoroscopeWhereInput> | null
    comparisons?: ProfileComparisonListRelationFilter
    testimonials?: TestimonialListRelationFilter
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    maritalStatus?: SortOrderInput | SortOrder
    religion?: SortOrderInput | SortOrder
    caste?: SortOrderInput | SortOrder
    motherTongue?: SortOrderInput | SortOrder
    manglik?: SortOrderInput | SortOrder
    gothra?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    citizenship?: SortOrderInput | SortOrder
    education?: SortOrderInput | SortOrder
    college?: SortOrderInput | SortOrder
    occupation?: SortOrderInput | SortOrder
    income?: SortOrderInput | SortOrder
    incomeCurrency?: SortOrderInput | SortOrder
    fatherOccupation?: SortOrderInput | SortOrder
    motherOccupation?: SortOrderInput | SortOrder
    siblings?: SortOrderInput | SortOrder
    familyType?: SortOrderInput | SortOrder
    diet?: SortOrderInput | SortOrder
    smoking?: SortOrderInput | SortOrder
    drinking?: SortOrderInput | SortOrder
    hobbies?: SortOrderInput | SortOrder
    partnerPreferences?: SortOrderInput | SortOrder
    videoIntroUrl?: SortOrderInput | SortOrder
    biodataUrl?: SortOrderInput | SortOrder
    aboutMe?: SortOrderInput | SortOrder
    highlights?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    privacySettings?: SortOrderInput | SortOrder
    isHiddenFromSearch?: SortOrder
    isAnonymousViewing?: SortOrder
    contactPrivacyLevel?: SortOrderInput | SortOrder
    photoPrivacyLevel?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    trustScore?: SortOrder
    completenessScore?: SortOrder
    isHighlighted?: SortOrder
    slug?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    photos?: PhotoOrderByRelationAggregateInput
    profileViews?: ProfileViewOrderByRelationAggregateInput
    shortlistedBy?: ShortlistOrderByRelationAggregateInput
    horoscope?: HoroscopeOrderByWithRelationInput
    comparisons?: ProfileComparisonOrderByRelationAggregateInput
    testimonials?: TestimonialOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
  }

  export type ProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    slug?: string
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    status?: EnumProfileStatusFilter<"Profile"> | $Enums.ProfileStatus
    firstName?: StringNullableFilter<"Profile"> | string | null
    lastName?: StringNullableFilter<"Profile"> | string | null
    gender?: EnumGenderNullableFilter<"Profile"> | $Enums.Gender | null
    dateOfBirth?: DateTimeNullableFilter<"Profile"> | Date | string | null
    height?: IntNullableFilter<"Profile"> | number | null
    maritalStatus?: EnumMaritalStatusNullableFilter<"Profile"> | $Enums.MaritalStatus | null
    religion?: StringNullableFilter<"Profile"> | string | null
    caste?: StringNullableFilter<"Profile"> | string | null
    motherTongue?: StringNullableFilter<"Profile"> | string | null
    manglik?: BoolNullableFilter<"Profile"> | boolean | null
    gothra?: StringNullableFilter<"Profile"> | string | null
    country?: StringNullableFilter<"Profile"> | string | null
    state?: StringNullableFilter<"Profile"> | string | null
    city?: StringNullableFilter<"Profile"> | string | null
    citizenship?: StringNullableFilter<"Profile"> | string | null
    education?: StringNullableFilter<"Profile"> | string | null
    college?: StringNullableFilter<"Profile"> | string | null
    occupation?: StringNullableFilter<"Profile"> | string | null
    income?: IntNullableFilter<"Profile"> | number | null
    incomeCurrency?: StringNullableFilter<"Profile"> | string | null
    fatherOccupation?: StringNullableFilter<"Profile"> | string | null
    motherOccupation?: StringNullableFilter<"Profile"> | string | null
    siblings?: IntNullableFilter<"Profile"> | number | null
    familyType?: EnumFamilyTypeNullableFilter<"Profile"> | $Enums.FamilyType | null
    diet?: EnumDietNullableFilter<"Profile"> | $Enums.Diet | null
    smoking?: BoolNullableFilter<"Profile"> | boolean | null
    drinking?: BoolNullableFilter<"Profile"> | boolean | null
    hobbies?: StringNullableFilter<"Profile"> | string | null
    partnerPreferences?: JsonNullableFilter<"Profile">
    videoIntroUrl?: StringNullableFilter<"Profile"> | string | null
    biodataUrl?: StringNullableFilter<"Profile"> | string | null
    aboutMe?: StringNullableFilter<"Profile"> | string | null
    highlights?: JsonNullableFilter<"Profile">
    latitude?: FloatNullableFilter<"Profile"> | number | null
    longitude?: FloatNullableFilter<"Profile"> | number | null
    privacySettings?: JsonNullableFilter<"Profile">
    isHiddenFromSearch?: BoolFilter<"Profile"> | boolean
    isAnonymousViewing?: BoolFilter<"Profile"> | boolean
    contactPrivacyLevel?: StringNullableFilter<"Profile"> | string | null
    photoPrivacyLevel?: StringNullableFilter<"Profile"> | string | null
    isVerified?: BoolFilter<"Profile"> | boolean
    verifiedAt?: DateTimeNullableFilter<"Profile"> | Date | string | null
    trustScore?: IntFilter<"Profile"> | number
    completenessScore?: IntFilter<"Profile"> | number
    isHighlighted?: BoolFilter<"Profile"> | boolean
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
    photos?: PhotoListRelationFilter
    profileViews?: ProfileViewListRelationFilter
    shortlistedBy?: ShortlistListRelationFilter
    horoscope?: XOR<HoroscopeNullableRelationFilter, HoroscopeWhereInput> | null
    comparisons?: ProfileComparisonListRelationFilter
    testimonials?: TestimonialListRelationFilter
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId" | "slug">

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    maritalStatus?: SortOrderInput | SortOrder
    religion?: SortOrderInput | SortOrder
    caste?: SortOrderInput | SortOrder
    motherTongue?: SortOrderInput | SortOrder
    manglik?: SortOrderInput | SortOrder
    gothra?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    citizenship?: SortOrderInput | SortOrder
    education?: SortOrderInput | SortOrder
    college?: SortOrderInput | SortOrder
    occupation?: SortOrderInput | SortOrder
    income?: SortOrderInput | SortOrder
    incomeCurrency?: SortOrderInput | SortOrder
    fatherOccupation?: SortOrderInput | SortOrder
    motherOccupation?: SortOrderInput | SortOrder
    siblings?: SortOrderInput | SortOrder
    familyType?: SortOrderInput | SortOrder
    diet?: SortOrderInput | SortOrder
    smoking?: SortOrderInput | SortOrder
    drinking?: SortOrderInput | SortOrder
    hobbies?: SortOrderInput | SortOrder
    partnerPreferences?: SortOrderInput | SortOrder
    videoIntroUrl?: SortOrderInput | SortOrder
    biodataUrl?: SortOrderInput | SortOrder
    aboutMe?: SortOrderInput | SortOrder
    highlights?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    privacySettings?: SortOrderInput | SortOrder
    isHiddenFromSearch?: SortOrder
    isAnonymousViewing?: SortOrder
    contactPrivacyLevel?: SortOrderInput | SortOrder
    photoPrivacyLevel?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    trustScore?: SortOrder
    completenessScore?: SortOrder
    isHighlighted?: SortOrder
    slug?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _avg?: ProfileAvgOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
    _sum?: ProfileSumOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    OR?: ProfileScalarWhereWithAggregatesInput[]
    NOT?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Profile"> | string
    userId?: StringWithAggregatesFilter<"Profile"> | string
    status?: EnumProfileStatusWithAggregatesFilter<"Profile"> | $Enums.ProfileStatus
    firstName?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    gender?: EnumGenderNullableWithAggregatesFilter<"Profile"> | $Enums.Gender | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"Profile"> | Date | string | null
    height?: IntNullableWithAggregatesFilter<"Profile"> | number | null
    maritalStatus?: EnumMaritalStatusNullableWithAggregatesFilter<"Profile"> | $Enums.MaritalStatus | null
    religion?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    caste?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    motherTongue?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    manglik?: BoolNullableWithAggregatesFilter<"Profile"> | boolean | null
    gothra?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    country?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    state?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    city?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    citizenship?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    education?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    college?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    occupation?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    income?: IntNullableWithAggregatesFilter<"Profile"> | number | null
    incomeCurrency?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    fatherOccupation?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    motherOccupation?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    siblings?: IntNullableWithAggregatesFilter<"Profile"> | number | null
    familyType?: EnumFamilyTypeNullableWithAggregatesFilter<"Profile"> | $Enums.FamilyType | null
    diet?: EnumDietNullableWithAggregatesFilter<"Profile"> | $Enums.Diet | null
    smoking?: BoolNullableWithAggregatesFilter<"Profile"> | boolean | null
    drinking?: BoolNullableWithAggregatesFilter<"Profile"> | boolean | null
    hobbies?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    partnerPreferences?: JsonNullableWithAggregatesFilter<"Profile">
    videoIntroUrl?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    biodataUrl?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    aboutMe?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    highlights?: JsonNullableWithAggregatesFilter<"Profile">
    latitude?: FloatNullableWithAggregatesFilter<"Profile"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"Profile"> | number | null
    privacySettings?: JsonNullableWithAggregatesFilter<"Profile">
    isHiddenFromSearch?: BoolWithAggregatesFilter<"Profile"> | boolean
    isAnonymousViewing?: BoolWithAggregatesFilter<"Profile"> | boolean
    contactPrivacyLevel?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    photoPrivacyLevel?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    isVerified?: BoolWithAggregatesFilter<"Profile"> | boolean
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"Profile"> | Date | string | null
    trustScore?: IntWithAggregatesFilter<"Profile"> | number
    completenessScore?: IntWithAggregatesFilter<"Profile"> | number
    isHighlighted?: BoolWithAggregatesFilter<"Profile"> | boolean
    slug?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
  }

  export type PhotoWhereInput = {
    AND?: PhotoWhereInput | PhotoWhereInput[]
    OR?: PhotoWhereInput[]
    NOT?: PhotoWhereInput | PhotoWhereInput[]
    id?: StringFilter<"Photo"> | string
    profileId?: StringFilter<"Photo"> | string
    url?: StringFilter<"Photo"> | string
    cloudinaryId?: StringNullableFilter<"Photo"> | string | null
    isPrimary?: BoolFilter<"Photo"> | boolean
    isBlurred?: BoolFilter<"Photo"> | boolean
    isApproved?: BoolFilter<"Photo"> | boolean
    order?: IntFilter<"Photo"> | number
    albumName?: StringNullableFilter<"Photo"> | string | null
    caption?: StringNullableFilter<"Photo"> | string | null
    createdAt?: DateTimeFilter<"Photo"> | Date | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
  }

  export type PhotoOrderByWithRelationInput = {
    id?: SortOrder
    profileId?: SortOrder
    url?: SortOrder
    cloudinaryId?: SortOrderInput | SortOrder
    isPrimary?: SortOrder
    isBlurred?: SortOrder
    isApproved?: SortOrder
    order?: SortOrder
    albumName?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    profile?: ProfileOrderByWithRelationInput
  }

  export type PhotoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PhotoWhereInput | PhotoWhereInput[]
    OR?: PhotoWhereInput[]
    NOT?: PhotoWhereInput | PhotoWhereInput[]
    profileId?: StringFilter<"Photo"> | string
    url?: StringFilter<"Photo"> | string
    cloudinaryId?: StringNullableFilter<"Photo"> | string | null
    isPrimary?: BoolFilter<"Photo"> | boolean
    isBlurred?: BoolFilter<"Photo"> | boolean
    isApproved?: BoolFilter<"Photo"> | boolean
    order?: IntFilter<"Photo"> | number
    albumName?: StringNullableFilter<"Photo"> | string | null
    caption?: StringNullableFilter<"Photo"> | string | null
    createdAt?: DateTimeFilter<"Photo"> | Date | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
  }, "id">

  export type PhotoOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrder
    url?: SortOrder
    cloudinaryId?: SortOrderInput | SortOrder
    isPrimary?: SortOrder
    isBlurred?: SortOrder
    isApproved?: SortOrder
    order?: SortOrder
    albumName?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PhotoCountOrderByAggregateInput
    _avg?: PhotoAvgOrderByAggregateInput
    _max?: PhotoMaxOrderByAggregateInput
    _min?: PhotoMinOrderByAggregateInput
    _sum?: PhotoSumOrderByAggregateInput
  }

  export type PhotoScalarWhereWithAggregatesInput = {
    AND?: PhotoScalarWhereWithAggregatesInput | PhotoScalarWhereWithAggregatesInput[]
    OR?: PhotoScalarWhereWithAggregatesInput[]
    NOT?: PhotoScalarWhereWithAggregatesInput | PhotoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Photo"> | string
    profileId?: StringWithAggregatesFilter<"Photo"> | string
    url?: StringWithAggregatesFilter<"Photo"> | string
    cloudinaryId?: StringNullableWithAggregatesFilter<"Photo"> | string | null
    isPrimary?: BoolWithAggregatesFilter<"Photo"> | boolean
    isBlurred?: BoolWithAggregatesFilter<"Photo"> | boolean
    isApproved?: BoolWithAggregatesFilter<"Photo"> | boolean
    order?: IntWithAggregatesFilter<"Photo"> | number
    albumName?: StringNullableWithAggregatesFilter<"Photo"> | string | null
    caption?: StringNullableWithAggregatesFilter<"Photo"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Photo"> | Date | string
  }

  export type VerificationWhereInput = {
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    id?: StringFilter<"Verification"> | string
    userId?: StringFilter<"Verification"> | string
    idType?: StringFilter<"Verification"> | string
    idNumber?: StringNullableFilter<"Verification"> | string | null
    idPhotoUrl?: StringNullableFilter<"Verification"> | string | null
    selfieUrl?: StringNullableFilter<"Verification"> | string | null
    status?: StringFilter<"Verification"> | string
    reviewedBy?: StringNullableFilter<"Verification"> | string | null
    reviewedAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }

  export type VerificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    idType?: SortOrder
    idNumber?: SortOrderInput | SortOrder
    idPhotoUrl?: SortOrderInput | SortOrder
    selfieUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    idType?: StringFilter<"Verification"> | string
    idNumber?: StringNullableFilter<"Verification"> | string | null
    idPhotoUrl?: StringNullableFilter<"Verification"> | string | null
    selfieUrl?: StringNullableFilter<"Verification"> | string | null
    status?: StringFilter<"Verification"> | string
    reviewedBy?: StringNullableFilter<"Verification"> | string | null
    reviewedAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }, "id" | "userId">

  export type VerificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    idType?: SortOrder
    idNumber?: SortOrderInput | SortOrder
    idPhotoUrl?: SortOrderInput | SortOrder
    selfieUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VerificationCountOrderByAggregateInput
    _max?: VerificationMaxOrderByAggregateInput
    _min?: VerificationMinOrderByAggregateInput
  }

  export type VerificationScalarWhereWithAggregatesInput = {
    AND?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    OR?: VerificationScalarWhereWithAggregatesInput[]
    NOT?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Verification"> | string
    userId?: StringWithAggregatesFilter<"Verification"> | string
    idType?: StringWithAggregatesFilter<"Verification"> | string
    idNumber?: StringNullableWithAggregatesFilter<"Verification"> | string | null
    idPhotoUrl?: StringNullableWithAggregatesFilter<"Verification"> | string | null
    selfieUrl?: StringNullableWithAggregatesFilter<"Verification"> | string | null
    status?: StringWithAggregatesFilter<"Verification"> | string
    reviewedBy?: StringNullableWithAggregatesFilter<"Verification"> | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"Verification"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
  }

  export type InterestWhereInput = {
    AND?: InterestWhereInput | InterestWhereInput[]
    OR?: InterestWhereInput[]
    NOT?: InterestWhereInput | InterestWhereInput[]
    id?: StringFilter<"Interest"> | string
    fromUserId?: StringFilter<"Interest"> | string
    toUserId?: StringFilter<"Interest"> | string
    status?: EnumInterestStatusFilter<"Interest"> | $Enums.InterestStatus
    message?: StringNullableFilter<"Interest"> | string | null
    createdAt?: DateTimeFilter<"Interest"> | Date | string
    updatedAt?: DateTimeFilter<"Interest"> | Date | string
    fromUser?: XOR<UserRelationFilter, UserWhereInput>
    toUser?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type InterestOrderByWithRelationInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fromUser?: UserOrderByWithRelationInput
    toUser?: UserOrderByWithRelationInput
  }

  export type InterestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    fromUserId_toUserId?: InterestFromUserIdToUserIdCompoundUniqueInput
    AND?: InterestWhereInput | InterestWhereInput[]
    OR?: InterestWhereInput[]
    NOT?: InterestWhereInput | InterestWhereInput[]
    fromUserId?: StringFilter<"Interest"> | string
    toUserId?: StringFilter<"Interest"> | string
    status?: EnumInterestStatusFilter<"Interest"> | $Enums.InterestStatus
    message?: StringNullableFilter<"Interest"> | string | null
    createdAt?: DateTimeFilter<"Interest"> | Date | string
    updatedAt?: DateTimeFilter<"Interest"> | Date | string
    fromUser?: XOR<UserRelationFilter, UserWhereInput>
    toUser?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "fromUserId_toUserId">

  export type InterestOrderByWithAggregationInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InterestCountOrderByAggregateInput
    _max?: InterestMaxOrderByAggregateInput
    _min?: InterestMinOrderByAggregateInput
  }

  export type InterestScalarWhereWithAggregatesInput = {
    AND?: InterestScalarWhereWithAggregatesInput | InterestScalarWhereWithAggregatesInput[]
    OR?: InterestScalarWhereWithAggregatesInput[]
    NOT?: InterestScalarWhereWithAggregatesInput | InterestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Interest"> | string
    fromUserId?: StringWithAggregatesFilter<"Interest"> | string
    toUserId?: StringWithAggregatesFilter<"Interest"> | string
    status?: EnumInterestStatusWithAggregatesFilter<"Interest"> | $Enums.InterestStatus
    message?: StringNullableWithAggregatesFilter<"Interest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Interest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Interest"> | Date | string
  }

  export type ChatWhereInput = {
    AND?: ChatWhereInput | ChatWhereInput[]
    OR?: ChatWhereInput[]
    NOT?: ChatWhereInput | ChatWhereInput[]
    id?: StringFilter<"Chat"> | string
    user1Id?: StringFilter<"Chat"> | string
    user2Id?: StringFilter<"Chat"> | string
    lastMessageAt?: DateTimeNullableFilter<"Chat"> | Date | string | null
    createdAt?: DateTimeFilter<"Chat"> | Date | string
    updatedAt?: DateTimeFilter<"Chat"> | Date | string
    user1?: XOR<UserRelationFilter, UserWhereInput>
    user2?: XOR<UserRelationFilter, UserWhereInput>
    messages?: MessageListRelationFilter
  }

  export type ChatOrderByWithRelationInput = {
    id?: SortOrder
    user1Id?: SortOrder
    user2Id?: SortOrder
    lastMessageAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user1?: UserOrderByWithRelationInput
    user2?: UserOrderByWithRelationInput
    messages?: MessageOrderByRelationAggregateInput
  }

  export type ChatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user1Id_user2Id?: ChatUser1IdUser2IdCompoundUniqueInput
    AND?: ChatWhereInput | ChatWhereInput[]
    OR?: ChatWhereInput[]
    NOT?: ChatWhereInput | ChatWhereInput[]
    user1Id?: StringFilter<"Chat"> | string
    user2Id?: StringFilter<"Chat"> | string
    lastMessageAt?: DateTimeNullableFilter<"Chat"> | Date | string | null
    createdAt?: DateTimeFilter<"Chat"> | Date | string
    updatedAt?: DateTimeFilter<"Chat"> | Date | string
    user1?: XOR<UserRelationFilter, UserWhereInput>
    user2?: XOR<UserRelationFilter, UserWhereInput>
    messages?: MessageListRelationFilter
  }, "id" | "user1Id_user2Id">

  export type ChatOrderByWithAggregationInput = {
    id?: SortOrder
    user1Id?: SortOrder
    user2Id?: SortOrder
    lastMessageAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChatCountOrderByAggregateInput
    _max?: ChatMaxOrderByAggregateInput
    _min?: ChatMinOrderByAggregateInput
  }

  export type ChatScalarWhereWithAggregatesInput = {
    AND?: ChatScalarWhereWithAggregatesInput | ChatScalarWhereWithAggregatesInput[]
    OR?: ChatScalarWhereWithAggregatesInput[]
    NOT?: ChatScalarWhereWithAggregatesInput | ChatScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Chat"> | string
    user1Id?: StringWithAggregatesFilter<"Chat"> | string
    user2Id?: StringWithAggregatesFilter<"Chat"> | string
    lastMessageAt?: DateTimeNullableWithAggregatesFilter<"Chat"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Chat"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Chat"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    chatId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    content?: StringNullableFilter<"Message"> | string | null
    imageUrl?: StringNullableFilter<"Message"> | string | null
    videoUrl?: StringNullableFilter<"Message"> | string | null
    audioUrl?: StringNullableFilter<"Message"> | string | null
    fileUrl?: StringNullableFilter<"Message"> | string | null
    fileName?: StringNullableFilter<"Message"> | string | null
    messageType?: StringFilter<"Message"> | string
    isRead?: BoolFilter<"Message"> | boolean
    isDeleted?: BoolFilter<"Message"> | boolean
    deletedBy?: StringNullableListFilter<"Message">
    isReported?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
    chat?: XOR<ChatRelationFilter, ChatWhereInput>
    sender?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    chatId?: SortOrder
    senderId?: SortOrder
    content?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    audioUrl?: SortOrderInput | SortOrder
    fileUrl?: SortOrderInput | SortOrder
    fileName?: SortOrderInput | SortOrder
    messageType?: SortOrder
    isRead?: SortOrder
    isDeleted?: SortOrder
    deletedBy?: SortOrder
    isReported?: SortOrder
    createdAt?: SortOrder
    chat?: ChatOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    chatId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    content?: StringNullableFilter<"Message"> | string | null
    imageUrl?: StringNullableFilter<"Message"> | string | null
    videoUrl?: StringNullableFilter<"Message"> | string | null
    audioUrl?: StringNullableFilter<"Message"> | string | null
    fileUrl?: StringNullableFilter<"Message"> | string | null
    fileName?: StringNullableFilter<"Message"> | string | null
    messageType?: StringFilter<"Message"> | string
    isRead?: BoolFilter<"Message"> | boolean
    isDeleted?: BoolFilter<"Message"> | boolean
    deletedBy?: StringNullableListFilter<"Message">
    isReported?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
    chat?: XOR<ChatRelationFilter, ChatWhereInput>
    sender?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    chatId?: SortOrder
    senderId?: SortOrder
    content?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    audioUrl?: SortOrderInput | SortOrder
    fileUrl?: SortOrderInput | SortOrder
    fileName?: SortOrderInput | SortOrder
    messageType?: SortOrder
    isRead?: SortOrder
    isDeleted?: SortOrder
    deletedBy?: SortOrder
    isReported?: SortOrder
    createdAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    chatId?: StringWithAggregatesFilter<"Message"> | string
    senderId?: StringWithAggregatesFilter<"Message"> | string
    content?: StringNullableWithAggregatesFilter<"Message"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Message"> | string | null
    videoUrl?: StringNullableWithAggregatesFilter<"Message"> | string | null
    audioUrl?: StringNullableWithAggregatesFilter<"Message"> | string | null
    fileUrl?: StringNullableWithAggregatesFilter<"Message"> | string | null
    fileName?: StringNullableWithAggregatesFilter<"Message"> | string | null
    messageType?: StringWithAggregatesFilter<"Message"> | string
    isRead?: BoolWithAggregatesFilter<"Message"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"Message"> | boolean
    deletedBy?: StringNullableListFilter<"Message">
    isReported?: BoolWithAggregatesFilter<"Message"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type ProfileViewWhereInput = {
    AND?: ProfileViewWhereInput | ProfileViewWhereInput[]
    OR?: ProfileViewWhereInput[]
    NOT?: ProfileViewWhereInput | ProfileViewWhereInput[]
    id?: StringFilter<"ProfileView"> | string
    profileId?: StringFilter<"ProfileView"> | string
    viewedById?: StringFilter<"ProfileView"> | string
    createdAt?: DateTimeFilter<"ProfileView"> | Date | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
    viewedBy?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ProfileViewOrderByWithRelationInput = {
    id?: SortOrder
    profileId?: SortOrder
    viewedById?: SortOrder
    createdAt?: SortOrder
    profile?: ProfileOrderByWithRelationInput
    viewedBy?: UserOrderByWithRelationInput
  }

  export type ProfileViewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    profileId_viewedById?: ProfileViewProfileIdViewedByIdCompoundUniqueInput
    AND?: ProfileViewWhereInput | ProfileViewWhereInput[]
    OR?: ProfileViewWhereInput[]
    NOT?: ProfileViewWhereInput | ProfileViewWhereInput[]
    profileId?: StringFilter<"ProfileView"> | string
    viewedById?: StringFilter<"ProfileView"> | string
    createdAt?: DateTimeFilter<"ProfileView"> | Date | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
    viewedBy?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "profileId_viewedById">

  export type ProfileViewOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrder
    viewedById?: SortOrder
    createdAt?: SortOrder
    _count?: ProfileViewCountOrderByAggregateInput
    _max?: ProfileViewMaxOrderByAggregateInput
    _min?: ProfileViewMinOrderByAggregateInput
  }

  export type ProfileViewScalarWhereWithAggregatesInput = {
    AND?: ProfileViewScalarWhereWithAggregatesInput | ProfileViewScalarWhereWithAggregatesInput[]
    OR?: ProfileViewScalarWhereWithAggregatesInput[]
    NOT?: ProfileViewScalarWhereWithAggregatesInput | ProfileViewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProfileView"> | string
    profileId?: StringWithAggregatesFilter<"ProfileView"> | string
    viewedById?: StringWithAggregatesFilter<"ProfileView"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProfileView"> | Date | string
  }

  export type ContactViewWhereInput = {
    AND?: ContactViewWhereInput | ContactViewWhereInput[]
    OR?: ContactViewWhereInput[]
    NOT?: ContactViewWhereInput | ContactViewWhereInput[]
    id?: StringFilter<"ContactView"> | string
    subscriptionId?: StringFilter<"ContactView"> | string
    profileId?: StringFilter<"ContactView"> | string
    viewedById?: StringFilter<"ContactView"> | string
    createdAt?: DateTimeFilter<"ContactView"> | Date | string
    subscription?: XOR<SubscriptionRelationFilter, SubscriptionWhereInput>
  }

  export type ContactViewOrderByWithRelationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    profileId?: SortOrder
    viewedById?: SortOrder
    createdAt?: SortOrder
    subscription?: SubscriptionOrderByWithRelationInput
  }

  export type ContactViewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    subscriptionId_profileId_viewedById?: ContactViewSubscriptionIdProfileIdViewedByIdCompoundUniqueInput
    AND?: ContactViewWhereInput | ContactViewWhereInput[]
    OR?: ContactViewWhereInput[]
    NOT?: ContactViewWhereInput | ContactViewWhereInput[]
    subscriptionId?: StringFilter<"ContactView"> | string
    profileId?: StringFilter<"ContactView"> | string
    viewedById?: StringFilter<"ContactView"> | string
    createdAt?: DateTimeFilter<"ContactView"> | Date | string
    subscription?: XOR<SubscriptionRelationFilter, SubscriptionWhereInput>
  }, "id" | "subscriptionId_profileId_viewedById">

  export type ContactViewOrderByWithAggregationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    profileId?: SortOrder
    viewedById?: SortOrder
    createdAt?: SortOrder
    _count?: ContactViewCountOrderByAggregateInput
    _max?: ContactViewMaxOrderByAggregateInput
    _min?: ContactViewMinOrderByAggregateInput
  }

  export type ContactViewScalarWhereWithAggregatesInput = {
    AND?: ContactViewScalarWhereWithAggregatesInput | ContactViewScalarWhereWithAggregatesInput[]
    OR?: ContactViewScalarWhereWithAggregatesInput[]
    NOT?: ContactViewScalarWhereWithAggregatesInput | ContactViewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContactView"> | string
    subscriptionId?: StringWithAggregatesFilter<"ContactView"> | string
    profileId?: StringWithAggregatesFilter<"ContactView"> | string
    viewedById?: StringWithAggregatesFilter<"ContactView"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ContactView"> | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    userId?: StringFilter<"Subscription"> | string
    plan?: EnumSubscriptionPlanFilter<"Subscription"> | $Enums.SubscriptionPlan
    razorpaySubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    razorpayPlanId?: StringNullableFilter<"Subscription"> | string | null
    status?: StringFilter<"Subscription"> | string
    startDate?: DateTimeFilter<"Subscription"> | Date | string
    endDate?: DateTimeFilter<"Subscription"> | Date | string
    contactViewsUsed?: IntFilter<"Subscription"> | number
    contactViewsLimit?: IntNullableFilter<"Subscription"> | number | null
    profileBoostCredits?: IntFilter<"Subscription"> | number
    verifiedBadgeIncluded?: BoolFilter<"Subscription"> | boolean
    horoscopeReportsIncluded?: IntFilter<"Subscription"> | number
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    contactViews?: ContactViewListRelationFilter
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    razorpaySubscriptionId?: SortOrderInput | SortOrder
    razorpayPlanId?: SortOrderInput | SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    contactViewsUsed?: SortOrder
    contactViewsLimit?: SortOrderInput | SortOrder
    profileBoostCredits?: SortOrder
    verifiedBadgeIncluded?: SortOrder
    horoscopeReportsIncluded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    contactViews?: ContactViewOrderByRelationAggregateInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    userId?: StringFilter<"Subscription"> | string
    plan?: EnumSubscriptionPlanFilter<"Subscription"> | $Enums.SubscriptionPlan
    razorpaySubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    razorpayPlanId?: StringNullableFilter<"Subscription"> | string | null
    status?: StringFilter<"Subscription"> | string
    startDate?: DateTimeFilter<"Subscription"> | Date | string
    endDate?: DateTimeFilter<"Subscription"> | Date | string
    contactViewsUsed?: IntFilter<"Subscription"> | number
    contactViewsLimit?: IntNullableFilter<"Subscription"> | number | null
    profileBoostCredits?: IntFilter<"Subscription"> | number
    verifiedBadgeIncluded?: BoolFilter<"Subscription"> | boolean
    horoscopeReportsIncluded?: IntFilter<"Subscription"> | number
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    contactViews?: ContactViewListRelationFilter
  }, "id">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    razorpaySubscriptionId?: SortOrderInput | SortOrder
    razorpayPlanId?: SortOrderInput | SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    contactViewsUsed?: SortOrder
    contactViewsLimit?: SortOrderInput | SortOrder
    profileBoostCredits?: SortOrder
    verifiedBadgeIncluded?: SortOrder
    horoscopeReportsIncluded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _avg?: SubscriptionAvgOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
    _sum?: SubscriptionSumOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    userId?: StringWithAggregatesFilter<"Subscription"> | string
    plan?: EnumSubscriptionPlanWithAggregatesFilter<"Subscription"> | $Enums.SubscriptionPlan
    razorpaySubscriptionId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    razorpayPlanId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    status?: StringWithAggregatesFilter<"Subscription"> | string
    startDate?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    contactViewsUsed?: IntWithAggregatesFilter<"Subscription"> | number
    contactViewsLimit?: IntNullableWithAggregatesFilter<"Subscription"> | number | null
    profileBoostCredits?: IntWithAggregatesFilter<"Subscription"> | number
    verifiedBadgeIncluded?: BoolWithAggregatesFilter<"Subscription"> | boolean
    horoscopeReportsIncluded?: IntWithAggregatesFilter<"Subscription"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    razorpayOrderId?: StringNullableFilter<"Payment"> | string | null
    razorpayPaymentId?: StringNullableFilter<"Payment"> | string | null
    amount?: IntFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    type?: StringFilter<"Payment"> | string
    addOnType?: EnumAddOnTypeNullableFilter<"Payment"> | $Enums.AddOnType | null
    subscriptionId?: StringNullableFilter<"Payment"> | string | null
    metadata?: JsonNullableFilter<"Payment">
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    addOns?: AddOnListRelationFilter
    services?: ServiceListRelationFilter
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    razorpayOrderId?: SortOrderInput | SortOrder
    razorpayPaymentId?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    type?: SortOrder
    addOnType?: SortOrderInput | SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    addOns?: AddOnOrderByRelationAggregateInput
    services?: ServiceOrderByRelationAggregateInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    razorpayOrderId?: string
    razorpayPaymentId?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    userId?: StringFilter<"Payment"> | string
    amount?: IntFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    type?: StringFilter<"Payment"> | string
    addOnType?: EnumAddOnTypeNullableFilter<"Payment"> | $Enums.AddOnType | null
    subscriptionId?: StringNullableFilter<"Payment"> | string | null
    metadata?: JsonNullableFilter<"Payment">
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    addOns?: AddOnListRelationFilter
    services?: ServiceListRelationFilter
  }, "id" | "razorpayOrderId" | "razorpayPaymentId">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    razorpayOrderId?: SortOrderInput | SortOrder
    razorpayPaymentId?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    type?: SortOrder
    addOnType?: SortOrderInput | SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    userId?: StringWithAggregatesFilter<"Payment"> | string
    razorpayOrderId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    razorpayPaymentId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    amount?: IntWithAggregatesFilter<"Payment"> | number
    currency?: StringWithAggregatesFilter<"Payment"> | string
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    type?: StringWithAggregatesFilter<"Payment"> | string
    addOnType?: EnumAddOnTypeNullableWithAggregatesFilter<"Payment"> | $Enums.AddOnType | null
    subscriptionId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Payment">
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type AddOnWhereInput = {
    AND?: AddOnWhereInput | AddOnWhereInput[]
    OR?: AddOnWhereInput[]
    NOT?: AddOnWhereInput | AddOnWhereInput[]
    id?: StringFilter<"AddOn"> | string
    userId?: StringFilter<"AddOn"> | string
    type?: EnumAddOnTypeFilter<"AddOn"> | $Enums.AddOnType
    paymentId?: StringNullableFilter<"AddOn"> | string | null
    expiresAt?: DateTimeNullableFilter<"AddOn"> | Date | string | null
    isActive?: BoolFilter<"AddOn"> | boolean
    createdAt?: DateTimeFilter<"AddOn"> | Date | string
    payment?: XOR<PaymentNullableRelationFilter, PaymentWhereInput> | null
  }

  export type AddOnOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    paymentId?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    payment?: PaymentOrderByWithRelationInput
  }

  export type AddOnWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AddOnWhereInput | AddOnWhereInput[]
    OR?: AddOnWhereInput[]
    NOT?: AddOnWhereInput | AddOnWhereInput[]
    userId?: StringFilter<"AddOn"> | string
    type?: EnumAddOnTypeFilter<"AddOn"> | $Enums.AddOnType
    paymentId?: StringNullableFilter<"AddOn"> | string | null
    expiresAt?: DateTimeNullableFilter<"AddOn"> | Date | string | null
    isActive?: BoolFilter<"AddOn"> | boolean
    createdAt?: DateTimeFilter<"AddOn"> | Date | string
    payment?: XOR<PaymentNullableRelationFilter, PaymentWhereInput> | null
  }, "id">

  export type AddOnOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    paymentId?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: AddOnCountOrderByAggregateInput
    _max?: AddOnMaxOrderByAggregateInput
    _min?: AddOnMinOrderByAggregateInput
  }

  export type AddOnScalarWhereWithAggregatesInput = {
    AND?: AddOnScalarWhereWithAggregatesInput | AddOnScalarWhereWithAggregatesInput[]
    OR?: AddOnScalarWhereWithAggregatesInput[]
    NOT?: AddOnScalarWhereWithAggregatesInput | AddOnScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AddOn"> | string
    userId?: StringWithAggregatesFilter<"AddOn"> | string
    type?: EnumAddOnTypeWithAggregatesFilter<"AddOn"> | $Enums.AddOnType
    paymentId?: StringNullableWithAggregatesFilter<"AddOn"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"AddOn"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"AddOn"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AddOn"> | Date | string
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: StringFilter<"Service"> | string
    userId?: StringFilter<"Service"> | string
    type?: EnumServiceTypeFilter<"Service"> | $Enums.ServiceType
    status?: EnumServiceStatusFilter<"Service"> | $Enums.ServiceStatus
    paymentId?: StringNullableFilter<"Service"> | string | null
    amount?: IntFilter<"Service"> | number
    metadata?: JsonNullableFilter<"Service">
    scheduledAt?: DateTimeNullableFilter<"Service"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Service"> | Date | string | null
    notes?: StringNullableFilter<"Service"> | string | null
    rating?: IntNullableFilter<"Service"> | number | null
    review?: StringNullableFilter<"Service"> | string | null
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    payment?: XOR<PaymentNullableRelationFilter, PaymentWhereInput> | null
    bookings?: ServiceBookingListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    paymentId?: SortOrderInput | SortOrder
    amount?: SortOrder
    metadata?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    review?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    payment?: PaymentOrderByWithRelationInput
    bookings?: ServiceBookingOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    userId?: StringFilter<"Service"> | string
    type?: EnumServiceTypeFilter<"Service"> | $Enums.ServiceType
    status?: EnumServiceStatusFilter<"Service"> | $Enums.ServiceStatus
    paymentId?: StringNullableFilter<"Service"> | string | null
    amount?: IntFilter<"Service"> | number
    metadata?: JsonNullableFilter<"Service">
    scheduledAt?: DateTimeNullableFilter<"Service"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Service"> | Date | string | null
    notes?: StringNullableFilter<"Service"> | string | null
    rating?: IntNullableFilter<"Service"> | number | null
    review?: StringNullableFilter<"Service"> | string | null
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    payment?: XOR<PaymentNullableRelationFilter, PaymentWhereInput> | null
    bookings?: ServiceBookingListRelationFilter
  }, "id">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    paymentId?: SortOrderInput | SortOrder
    amount?: SortOrder
    metadata?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    review?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Service"> | string
    userId?: StringWithAggregatesFilter<"Service"> | string
    type?: EnumServiceTypeWithAggregatesFilter<"Service"> | $Enums.ServiceType
    status?: EnumServiceStatusWithAggregatesFilter<"Service"> | $Enums.ServiceStatus
    paymentId?: StringNullableWithAggregatesFilter<"Service"> | string | null
    amount?: IntWithAggregatesFilter<"Service"> | number
    metadata?: JsonNullableWithAggregatesFilter<"Service">
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"Service"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Service"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"Service"> | string | null
    rating?: IntNullableWithAggregatesFilter<"Service"> | number | null
    review?: StringNullableWithAggregatesFilter<"Service"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
  }

  export type ServiceProviderWhereInput = {
    AND?: ServiceProviderWhereInput | ServiceProviderWhereInput[]
    OR?: ServiceProviderWhereInput[]
    NOT?: ServiceProviderWhereInput | ServiceProviderWhereInput[]
    id?: StringFilter<"ServiceProvider"> | string
    name?: StringFilter<"ServiceProvider"> | string
    email?: StringFilter<"ServiceProvider"> | string
    mobile?: StringFilter<"ServiceProvider"> | string
    serviceType?: EnumServiceTypeFilter<"ServiceProvider"> | $Enums.ServiceType
    expertise?: StringNullableFilter<"ServiceProvider"> | string | null
    rating?: FloatFilter<"ServiceProvider"> | number
    totalBookings?: IntFilter<"ServiceProvider"> | number
    isActive?: BoolFilter<"ServiceProvider"> | boolean
    metadata?: JsonNullableFilter<"ServiceProvider">
    createdAt?: DateTimeFilter<"ServiceProvider"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceProvider"> | Date | string
    bookings?: ServiceBookingListRelationFilter
  }

  export type ServiceProviderOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    serviceType?: SortOrder
    expertise?: SortOrderInput | SortOrder
    rating?: SortOrder
    totalBookings?: SortOrder
    isActive?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bookings?: ServiceBookingOrderByRelationAggregateInput
  }

  export type ServiceProviderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    mobile?: string
    AND?: ServiceProviderWhereInput | ServiceProviderWhereInput[]
    OR?: ServiceProviderWhereInput[]
    NOT?: ServiceProviderWhereInput | ServiceProviderWhereInput[]
    name?: StringFilter<"ServiceProvider"> | string
    serviceType?: EnumServiceTypeFilter<"ServiceProvider"> | $Enums.ServiceType
    expertise?: StringNullableFilter<"ServiceProvider"> | string | null
    rating?: FloatFilter<"ServiceProvider"> | number
    totalBookings?: IntFilter<"ServiceProvider"> | number
    isActive?: BoolFilter<"ServiceProvider"> | boolean
    metadata?: JsonNullableFilter<"ServiceProvider">
    createdAt?: DateTimeFilter<"ServiceProvider"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceProvider"> | Date | string
    bookings?: ServiceBookingListRelationFilter
  }, "id" | "email" | "mobile">

  export type ServiceProviderOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    serviceType?: SortOrder
    expertise?: SortOrderInput | SortOrder
    rating?: SortOrder
    totalBookings?: SortOrder
    isActive?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceProviderCountOrderByAggregateInput
    _avg?: ServiceProviderAvgOrderByAggregateInput
    _max?: ServiceProviderMaxOrderByAggregateInput
    _min?: ServiceProviderMinOrderByAggregateInput
    _sum?: ServiceProviderSumOrderByAggregateInput
  }

  export type ServiceProviderScalarWhereWithAggregatesInput = {
    AND?: ServiceProviderScalarWhereWithAggregatesInput | ServiceProviderScalarWhereWithAggregatesInput[]
    OR?: ServiceProviderScalarWhereWithAggregatesInput[]
    NOT?: ServiceProviderScalarWhereWithAggregatesInput | ServiceProviderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceProvider"> | string
    name?: StringWithAggregatesFilter<"ServiceProvider"> | string
    email?: StringWithAggregatesFilter<"ServiceProvider"> | string
    mobile?: StringWithAggregatesFilter<"ServiceProvider"> | string
    serviceType?: EnumServiceTypeWithAggregatesFilter<"ServiceProvider"> | $Enums.ServiceType
    expertise?: StringNullableWithAggregatesFilter<"ServiceProvider"> | string | null
    rating?: FloatWithAggregatesFilter<"ServiceProvider"> | number
    totalBookings?: IntWithAggregatesFilter<"ServiceProvider"> | number
    isActive?: BoolWithAggregatesFilter<"ServiceProvider"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"ServiceProvider">
    createdAt?: DateTimeWithAggregatesFilter<"ServiceProvider"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServiceProvider"> | Date | string
  }

  export type ServiceBookingWhereInput = {
    AND?: ServiceBookingWhereInput | ServiceBookingWhereInput[]
    OR?: ServiceBookingWhereInput[]
    NOT?: ServiceBookingWhereInput | ServiceBookingWhereInput[]
    id?: StringFilter<"ServiceBooking"> | string
    serviceId?: StringFilter<"ServiceBooking"> | string
    providerId?: StringNullableFilter<"ServiceBooking"> | string | null
    userId?: StringFilter<"ServiceBooking"> | string
    scheduledAt?: DateTimeNullableFilter<"ServiceBooking"> | Date | string | null
    duration?: IntNullableFilter<"ServiceBooking"> | number | null
    status?: EnumServiceStatusFilter<"ServiceBooking"> | $Enums.ServiceStatus
    meetingLink?: StringNullableFilter<"ServiceBooking"> | string | null
    notes?: StringNullableFilter<"ServiceBooking"> | string | null
    createdAt?: DateTimeFilter<"ServiceBooking"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceBooking"> | Date | string
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
    provider?: XOR<ServiceProviderNullableRelationFilter, ServiceProviderWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ServiceBookingOrderByWithRelationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    providerId?: SortOrderInput | SortOrder
    userId?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    status?: SortOrder
    meetingLink?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    service?: ServiceOrderByWithRelationInput
    provider?: ServiceProviderOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ServiceBookingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceBookingWhereInput | ServiceBookingWhereInput[]
    OR?: ServiceBookingWhereInput[]
    NOT?: ServiceBookingWhereInput | ServiceBookingWhereInput[]
    serviceId?: StringFilter<"ServiceBooking"> | string
    providerId?: StringNullableFilter<"ServiceBooking"> | string | null
    userId?: StringFilter<"ServiceBooking"> | string
    scheduledAt?: DateTimeNullableFilter<"ServiceBooking"> | Date | string | null
    duration?: IntNullableFilter<"ServiceBooking"> | number | null
    status?: EnumServiceStatusFilter<"ServiceBooking"> | $Enums.ServiceStatus
    meetingLink?: StringNullableFilter<"ServiceBooking"> | string | null
    notes?: StringNullableFilter<"ServiceBooking"> | string | null
    createdAt?: DateTimeFilter<"ServiceBooking"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceBooking"> | Date | string
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
    provider?: XOR<ServiceProviderNullableRelationFilter, ServiceProviderWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ServiceBookingOrderByWithAggregationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    providerId?: SortOrderInput | SortOrder
    userId?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    status?: SortOrder
    meetingLink?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceBookingCountOrderByAggregateInput
    _avg?: ServiceBookingAvgOrderByAggregateInput
    _max?: ServiceBookingMaxOrderByAggregateInput
    _min?: ServiceBookingMinOrderByAggregateInput
    _sum?: ServiceBookingSumOrderByAggregateInput
  }

  export type ServiceBookingScalarWhereWithAggregatesInput = {
    AND?: ServiceBookingScalarWhereWithAggregatesInput | ServiceBookingScalarWhereWithAggregatesInput[]
    OR?: ServiceBookingScalarWhereWithAggregatesInput[]
    NOT?: ServiceBookingScalarWhereWithAggregatesInput | ServiceBookingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceBooking"> | string
    serviceId?: StringWithAggregatesFilter<"ServiceBooking"> | string
    providerId?: StringNullableWithAggregatesFilter<"ServiceBooking"> | string | null
    userId?: StringWithAggregatesFilter<"ServiceBooking"> | string
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"ServiceBooking"> | Date | string | null
    duration?: IntNullableWithAggregatesFilter<"ServiceBooking"> | number | null
    status?: EnumServiceStatusWithAggregatesFilter<"ServiceBooking"> | $Enums.ServiceStatus
    meetingLink?: StringNullableWithAggregatesFilter<"ServiceBooking"> | string | null
    notes?: StringNullableWithAggregatesFilter<"ServiceBooking"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ServiceBooking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServiceBooking"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"Notification">
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type SavedSearchWhereInput = {
    AND?: SavedSearchWhereInput | SavedSearchWhereInput[]
    OR?: SavedSearchWhereInput[]
    NOT?: SavedSearchWhereInput | SavedSearchWhereInput[]
    id?: StringFilter<"SavedSearch"> | string
    userId?: StringFilter<"SavedSearch"> | string
    name?: StringFilter<"SavedSearch"> | string
    filters?: JsonFilter<"SavedSearch">
    createdAt?: DateTimeFilter<"SavedSearch"> | Date | string
    updatedAt?: DateTimeFilter<"SavedSearch"> | Date | string
  }

  export type SavedSearchOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    filters?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SavedSearchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SavedSearchWhereInput | SavedSearchWhereInput[]
    OR?: SavedSearchWhereInput[]
    NOT?: SavedSearchWhereInput | SavedSearchWhereInput[]
    userId?: StringFilter<"SavedSearch"> | string
    name?: StringFilter<"SavedSearch"> | string
    filters?: JsonFilter<"SavedSearch">
    createdAt?: DateTimeFilter<"SavedSearch"> | Date | string
    updatedAt?: DateTimeFilter<"SavedSearch"> | Date | string
  }, "id">

  export type SavedSearchOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    filters?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SavedSearchCountOrderByAggregateInput
    _max?: SavedSearchMaxOrderByAggregateInput
    _min?: SavedSearchMinOrderByAggregateInput
  }

  export type SavedSearchScalarWhereWithAggregatesInput = {
    AND?: SavedSearchScalarWhereWithAggregatesInput | SavedSearchScalarWhereWithAggregatesInput[]
    OR?: SavedSearchScalarWhereWithAggregatesInput[]
    NOT?: SavedSearchScalarWhereWithAggregatesInput | SavedSearchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SavedSearch"> | string
    userId?: StringWithAggregatesFilter<"SavedSearch"> | string
    name?: StringWithAggregatesFilter<"SavedSearch"> | string
    filters?: JsonWithAggregatesFilter<"SavedSearch">
    createdAt?: DateTimeWithAggregatesFilter<"SavedSearch"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SavedSearch"> | Date | string
  }

  export type OTPWhereInput = {
    AND?: OTPWhereInput | OTPWhereInput[]
    OR?: OTPWhereInput[]
    NOT?: OTPWhereInput | OTPWhereInput[]
    id?: StringFilter<"OTP"> | string
    identifier?: StringFilter<"OTP"> | string
    code?: StringFilter<"OTP"> | string
    type?: StringFilter<"OTP"> | string
    expiresAt?: DateTimeFilter<"OTP"> | Date | string
    isUsed?: BoolFilter<"OTP"> | boolean
    createdAt?: DateTimeFilter<"OTP"> | Date | string
  }

  export type OTPOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    code?: SortOrder
    type?: SortOrder
    expiresAt?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
  }

  export type OTPWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OTPWhereInput | OTPWhereInput[]
    OR?: OTPWhereInput[]
    NOT?: OTPWhereInput | OTPWhereInput[]
    identifier?: StringFilter<"OTP"> | string
    code?: StringFilter<"OTP"> | string
    type?: StringFilter<"OTP"> | string
    expiresAt?: DateTimeFilter<"OTP"> | Date | string
    isUsed?: BoolFilter<"OTP"> | boolean
    createdAt?: DateTimeFilter<"OTP"> | Date | string
  }, "id">

  export type OTPOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    code?: SortOrder
    type?: SortOrder
    expiresAt?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
    _count?: OTPCountOrderByAggregateInput
    _max?: OTPMaxOrderByAggregateInput
    _min?: OTPMinOrderByAggregateInput
  }

  export type OTPScalarWhereWithAggregatesInput = {
    AND?: OTPScalarWhereWithAggregatesInput | OTPScalarWhereWithAggregatesInput[]
    OR?: OTPScalarWhereWithAggregatesInput[]
    NOT?: OTPScalarWhereWithAggregatesInput | OTPScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OTP"> | string
    identifier?: StringWithAggregatesFilter<"OTP"> | string
    code?: StringWithAggregatesFilter<"OTP"> | string
    type?: StringWithAggregatesFilter<"OTP"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"OTP"> | Date | string
    isUsed?: BoolWithAggregatesFilter<"OTP"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"OTP"> | Date | string
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: StringFilter<"Admin"> | string
    email?: StringFilter<"Admin"> | string
    password?: StringFilter<"Admin"> | string
    name?: StringFilter<"Admin"> | string
    role?: StringFilter<"Admin"> | string
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    password?: StringFilter<"Admin"> | string
    name?: StringFilter<"Admin"> | string
    role?: StringFilter<"Admin"> | string
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
  }, "id" | "email">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Admin"> | string
    email?: StringWithAggregatesFilter<"Admin"> | string
    password?: StringWithAggregatesFilter<"Admin"> | string
    name?: StringWithAggregatesFilter<"Admin"> | string
    role?: StringWithAggregatesFilter<"Admin"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
  }

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    id?: StringFilter<"Report"> | string
    reporterId?: StringFilter<"Report"> | string
    reportedUserId?: StringFilter<"Report"> | string
    type?: StringFilter<"Report"> | string
    reason?: StringFilter<"Report"> | string
    description?: StringNullableFilter<"Report"> | string | null
    status?: StringFilter<"Report"> | string
    reviewedBy?: StringNullableFilter<"Report"> | string | null
    reviewedAt?: DateTimeNullableFilter<"Report"> | Date | string | null
    createdAt?: DateTimeFilter<"Report"> | Date | string
  }

  export type ReportOrderByWithRelationInput = {
    id?: SortOrder
    reporterId?: SortOrder
    reportedUserId?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type ReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    reporterId?: StringFilter<"Report"> | string
    reportedUserId?: StringFilter<"Report"> | string
    type?: StringFilter<"Report"> | string
    reason?: StringFilter<"Report"> | string
    description?: StringNullableFilter<"Report"> | string | null
    status?: StringFilter<"Report"> | string
    reviewedBy?: StringNullableFilter<"Report"> | string | null
    reviewedAt?: DateTimeNullableFilter<"Report"> | Date | string | null
    createdAt?: DateTimeFilter<"Report"> | Date | string
  }, "id">

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder
    reporterId?: SortOrder
    reportedUserId?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ReportCountOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    OR?: ReportScalarWhereWithAggregatesInput[]
    NOT?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Report"> | string
    reporterId?: StringWithAggregatesFilter<"Report"> | string
    reportedUserId?: StringWithAggregatesFilter<"Report"> | string
    type?: StringWithAggregatesFilter<"Report"> | string
    reason?: StringWithAggregatesFilter<"Report"> | string
    description?: StringNullableWithAggregatesFilter<"Report"> | string | null
    status?: StringWithAggregatesFilter<"Report"> | string
    reviewedBy?: StringNullableWithAggregatesFilter<"Report"> | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"Report"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
  }

  export type ShortlistWhereInput = {
    AND?: ShortlistWhereInput | ShortlistWhereInput[]
    OR?: ShortlistWhereInput[]
    NOT?: ShortlistWhereInput | ShortlistWhereInput[]
    id?: StringFilter<"Shortlist"> | string
    userId?: StringFilter<"Shortlist"> | string
    profileId?: StringFilter<"Shortlist"> | string
    folderName?: StringNullableFilter<"Shortlist"> | string | null
    notes?: StringNullableFilter<"Shortlist"> | string | null
    createdAt?: DateTimeFilter<"Shortlist"> | Date | string
    updatedAt?: DateTimeFilter<"Shortlist"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
  }

  export type ShortlistOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    profileId?: SortOrder
    folderName?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    profile?: ProfileOrderByWithRelationInput
  }

  export type ShortlistWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_profileId?: ShortlistUserIdProfileIdCompoundUniqueInput
    AND?: ShortlistWhereInput | ShortlistWhereInput[]
    OR?: ShortlistWhereInput[]
    NOT?: ShortlistWhereInput | ShortlistWhereInput[]
    userId?: StringFilter<"Shortlist"> | string
    profileId?: StringFilter<"Shortlist"> | string
    folderName?: StringNullableFilter<"Shortlist"> | string | null
    notes?: StringNullableFilter<"Shortlist"> | string | null
    createdAt?: DateTimeFilter<"Shortlist"> | Date | string
    updatedAt?: DateTimeFilter<"Shortlist"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
  }, "id" | "userId_profileId">

  export type ShortlistOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    profileId?: SortOrder
    folderName?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShortlistCountOrderByAggregateInput
    _max?: ShortlistMaxOrderByAggregateInput
    _min?: ShortlistMinOrderByAggregateInput
  }

  export type ShortlistScalarWhereWithAggregatesInput = {
    AND?: ShortlistScalarWhereWithAggregatesInput | ShortlistScalarWhereWithAggregatesInput[]
    OR?: ShortlistScalarWhereWithAggregatesInput[]
    NOT?: ShortlistScalarWhereWithAggregatesInput | ShortlistScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Shortlist"> | string
    userId?: StringWithAggregatesFilter<"Shortlist"> | string
    profileId?: StringWithAggregatesFilter<"Shortlist"> | string
    folderName?: StringNullableWithAggregatesFilter<"Shortlist"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Shortlist"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Shortlist"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Shortlist"> | Date | string
  }

  export type BlockedUserWhereInput = {
    AND?: BlockedUserWhereInput | BlockedUserWhereInput[]
    OR?: BlockedUserWhereInput[]
    NOT?: BlockedUserWhereInput | BlockedUserWhereInput[]
    id?: StringFilter<"BlockedUser"> | string
    blockerId?: StringFilter<"BlockedUser"> | string
    blockedId?: StringFilter<"BlockedUser"> | string
    reason?: StringNullableFilter<"BlockedUser"> | string | null
    createdAt?: DateTimeFilter<"BlockedUser"> | Date | string
    blocker?: XOR<UserRelationFilter, UserWhereInput>
    blocked?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type BlockedUserOrderByWithRelationInput = {
    id?: SortOrder
    blockerId?: SortOrder
    blockedId?: SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    blocker?: UserOrderByWithRelationInput
    blocked?: UserOrderByWithRelationInput
  }

  export type BlockedUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    blockerId_blockedId?: BlockedUserBlockerIdBlockedIdCompoundUniqueInput
    AND?: BlockedUserWhereInput | BlockedUserWhereInput[]
    OR?: BlockedUserWhereInput[]
    NOT?: BlockedUserWhereInput | BlockedUserWhereInput[]
    blockerId?: StringFilter<"BlockedUser"> | string
    blockedId?: StringFilter<"BlockedUser"> | string
    reason?: StringNullableFilter<"BlockedUser"> | string | null
    createdAt?: DateTimeFilter<"BlockedUser"> | Date | string
    blocker?: XOR<UserRelationFilter, UserWhereInput>
    blocked?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "blockerId_blockedId">

  export type BlockedUserOrderByWithAggregationInput = {
    id?: SortOrder
    blockerId?: SortOrder
    blockedId?: SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BlockedUserCountOrderByAggregateInput
    _max?: BlockedUserMaxOrderByAggregateInput
    _min?: BlockedUserMinOrderByAggregateInput
  }

  export type BlockedUserScalarWhereWithAggregatesInput = {
    AND?: BlockedUserScalarWhereWithAggregatesInput | BlockedUserScalarWhereWithAggregatesInput[]
    OR?: BlockedUserScalarWhereWithAggregatesInput[]
    NOT?: BlockedUserScalarWhereWithAggregatesInput | BlockedUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlockedUser"> | string
    blockerId?: StringWithAggregatesFilter<"BlockedUser"> | string
    blockedId?: StringWithAggregatesFilter<"BlockedUser"> | string
    reason?: StringNullableWithAggregatesFilter<"BlockedUser"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BlockedUser"> | Date | string
  }

  export type HoroscopeWhereInput = {
    AND?: HoroscopeWhereInput | HoroscopeWhereInput[]
    OR?: HoroscopeWhereInput[]
    NOT?: HoroscopeWhereInput | HoroscopeWhereInput[]
    id?: StringFilter<"Horoscope"> | string
    userId?: StringFilter<"Horoscope"> | string
    profileId?: StringFilter<"Horoscope"> | string
    horoscopeUrl?: StringNullableFilter<"Horoscope"> | string | null
    birthTime?: StringNullableFilter<"Horoscope"> | string | null
    birthPlace?: StringNullableFilter<"Horoscope"> | string | null
    rashi?: StringNullableFilter<"Horoscope"> | string | null
    nakshatra?: StringNullableFilter<"Horoscope"> | string | null
    mangalDosha?: BoolNullableFilter<"Horoscope"> | boolean | null
    horoscopeData?: JsonNullableFilter<"Horoscope">
    createdAt?: DateTimeFilter<"Horoscope"> | Date | string
    updatedAt?: DateTimeFilter<"Horoscope"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
    matches1?: HoroscopeMatchListRelationFilter
    matches2?: HoroscopeMatchListRelationFilter
  }

  export type HoroscopeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    profileId?: SortOrder
    horoscopeUrl?: SortOrderInput | SortOrder
    birthTime?: SortOrderInput | SortOrder
    birthPlace?: SortOrderInput | SortOrder
    rashi?: SortOrderInput | SortOrder
    nakshatra?: SortOrderInput | SortOrder
    mangalDosha?: SortOrderInput | SortOrder
    horoscopeData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    profile?: ProfileOrderByWithRelationInput
    matches1?: HoroscopeMatchOrderByRelationAggregateInput
    matches2?: HoroscopeMatchOrderByRelationAggregateInput
  }

  export type HoroscopeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    profileId?: string
    AND?: HoroscopeWhereInput | HoroscopeWhereInput[]
    OR?: HoroscopeWhereInput[]
    NOT?: HoroscopeWhereInput | HoroscopeWhereInput[]
    horoscopeUrl?: StringNullableFilter<"Horoscope"> | string | null
    birthTime?: StringNullableFilter<"Horoscope"> | string | null
    birthPlace?: StringNullableFilter<"Horoscope"> | string | null
    rashi?: StringNullableFilter<"Horoscope"> | string | null
    nakshatra?: StringNullableFilter<"Horoscope"> | string | null
    mangalDosha?: BoolNullableFilter<"Horoscope"> | boolean | null
    horoscopeData?: JsonNullableFilter<"Horoscope">
    createdAt?: DateTimeFilter<"Horoscope"> | Date | string
    updatedAt?: DateTimeFilter<"Horoscope"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
    matches1?: HoroscopeMatchListRelationFilter
    matches2?: HoroscopeMatchListRelationFilter
  }, "id" | "userId" | "profileId">

  export type HoroscopeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    profileId?: SortOrder
    horoscopeUrl?: SortOrderInput | SortOrder
    birthTime?: SortOrderInput | SortOrder
    birthPlace?: SortOrderInput | SortOrder
    rashi?: SortOrderInput | SortOrder
    nakshatra?: SortOrderInput | SortOrder
    mangalDosha?: SortOrderInput | SortOrder
    horoscopeData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HoroscopeCountOrderByAggregateInput
    _max?: HoroscopeMaxOrderByAggregateInput
    _min?: HoroscopeMinOrderByAggregateInput
  }

  export type HoroscopeScalarWhereWithAggregatesInput = {
    AND?: HoroscopeScalarWhereWithAggregatesInput | HoroscopeScalarWhereWithAggregatesInput[]
    OR?: HoroscopeScalarWhereWithAggregatesInput[]
    NOT?: HoroscopeScalarWhereWithAggregatesInput | HoroscopeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Horoscope"> | string
    userId?: StringWithAggregatesFilter<"Horoscope"> | string
    profileId?: StringWithAggregatesFilter<"Horoscope"> | string
    horoscopeUrl?: StringNullableWithAggregatesFilter<"Horoscope"> | string | null
    birthTime?: StringNullableWithAggregatesFilter<"Horoscope"> | string | null
    birthPlace?: StringNullableWithAggregatesFilter<"Horoscope"> | string | null
    rashi?: StringNullableWithAggregatesFilter<"Horoscope"> | string | null
    nakshatra?: StringNullableWithAggregatesFilter<"Horoscope"> | string | null
    mangalDosha?: BoolNullableWithAggregatesFilter<"Horoscope"> | boolean | null
    horoscopeData?: JsonNullableWithAggregatesFilter<"Horoscope">
    createdAt?: DateTimeWithAggregatesFilter<"Horoscope"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Horoscope"> | Date | string
  }

  export type HoroscopeMatchWhereInput = {
    AND?: HoroscopeMatchWhereInput | HoroscopeMatchWhereInput[]
    OR?: HoroscopeMatchWhereInput[]
    NOT?: HoroscopeMatchWhereInput | HoroscopeMatchWhereInput[]
    id?: StringFilter<"HoroscopeMatch"> | string
    user1Id?: StringFilter<"HoroscopeMatch"> | string
    user2Id?: StringFilter<"HoroscopeMatch"> | string
    horoscope1Id?: StringFilter<"HoroscopeMatch"> | string
    horoscope2Id?: StringFilter<"HoroscopeMatch"> | string
    ashtakootScore?: IntNullableFilter<"HoroscopeMatch"> | number | null
    mangalDoshaMatch?: BoolNullableFilter<"HoroscopeMatch"> | boolean | null
    overallScore?: IntNullableFilter<"HoroscopeMatch"> | number | null
    matchDetails?: JsonNullableFilter<"HoroscopeMatch">
    createdAt?: DateTimeFilter<"HoroscopeMatch"> | Date | string
    horoscope1?: XOR<HoroscopeRelationFilter, HoroscopeWhereInput>
    horoscope2?: XOR<HoroscopeRelationFilter, HoroscopeWhereInput>
  }

  export type HoroscopeMatchOrderByWithRelationInput = {
    id?: SortOrder
    user1Id?: SortOrder
    user2Id?: SortOrder
    horoscope1Id?: SortOrder
    horoscope2Id?: SortOrder
    ashtakootScore?: SortOrderInput | SortOrder
    mangalDoshaMatch?: SortOrderInput | SortOrder
    overallScore?: SortOrderInput | SortOrder
    matchDetails?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    horoscope1?: HoroscopeOrderByWithRelationInput
    horoscope2?: HoroscopeOrderByWithRelationInput
  }

  export type HoroscopeMatchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user1Id_user2Id?: HoroscopeMatchUser1IdUser2IdCompoundUniqueInput
    AND?: HoroscopeMatchWhereInput | HoroscopeMatchWhereInput[]
    OR?: HoroscopeMatchWhereInput[]
    NOT?: HoroscopeMatchWhereInput | HoroscopeMatchWhereInput[]
    user1Id?: StringFilter<"HoroscopeMatch"> | string
    user2Id?: StringFilter<"HoroscopeMatch"> | string
    horoscope1Id?: StringFilter<"HoroscopeMatch"> | string
    horoscope2Id?: StringFilter<"HoroscopeMatch"> | string
    ashtakootScore?: IntNullableFilter<"HoroscopeMatch"> | number | null
    mangalDoshaMatch?: BoolNullableFilter<"HoroscopeMatch"> | boolean | null
    overallScore?: IntNullableFilter<"HoroscopeMatch"> | number | null
    matchDetails?: JsonNullableFilter<"HoroscopeMatch">
    createdAt?: DateTimeFilter<"HoroscopeMatch"> | Date | string
    horoscope1?: XOR<HoroscopeRelationFilter, HoroscopeWhereInput>
    horoscope2?: XOR<HoroscopeRelationFilter, HoroscopeWhereInput>
  }, "id" | "user1Id_user2Id">

  export type HoroscopeMatchOrderByWithAggregationInput = {
    id?: SortOrder
    user1Id?: SortOrder
    user2Id?: SortOrder
    horoscope1Id?: SortOrder
    horoscope2Id?: SortOrder
    ashtakootScore?: SortOrderInput | SortOrder
    mangalDoshaMatch?: SortOrderInput | SortOrder
    overallScore?: SortOrderInput | SortOrder
    matchDetails?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: HoroscopeMatchCountOrderByAggregateInput
    _avg?: HoroscopeMatchAvgOrderByAggregateInput
    _max?: HoroscopeMatchMaxOrderByAggregateInput
    _min?: HoroscopeMatchMinOrderByAggregateInput
    _sum?: HoroscopeMatchSumOrderByAggregateInput
  }

  export type HoroscopeMatchScalarWhereWithAggregatesInput = {
    AND?: HoroscopeMatchScalarWhereWithAggregatesInput | HoroscopeMatchScalarWhereWithAggregatesInput[]
    OR?: HoroscopeMatchScalarWhereWithAggregatesInput[]
    NOT?: HoroscopeMatchScalarWhereWithAggregatesInput | HoroscopeMatchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HoroscopeMatch"> | string
    user1Id?: StringWithAggregatesFilter<"HoroscopeMatch"> | string
    user2Id?: StringWithAggregatesFilter<"HoroscopeMatch"> | string
    horoscope1Id?: StringWithAggregatesFilter<"HoroscopeMatch"> | string
    horoscope2Id?: StringWithAggregatesFilter<"HoroscopeMatch"> | string
    ashtakootScore?: IntNullableWithAggregatesFilter<"HoroscopeMatch"> | number | null
    mangalDoshaMatch?: BoolNullableWithAggregatesFilter<"HoroscopeMatch"> | boolean | null
    overallScore?: IntNullableWithAggregatesFilter<"HoroscopeMatch"> | number | null
    matchDetails?: JsonNullableWithAggregatesFilter<"HoroscopeMatch">
    createdAt?: DateTimeWithAggregatesFilter<"HoroscopeMatch"> | Date | string
  }

  export type SuccessStoryWhereInput = {
    AND?: SuccessStoryWhereInput | SuccessStoryWhereInput[]
    OR?: SuccessStoryWhereInput[]
    NOT?: SuccessStoryWhereInput | SuccessStoryWhereInput[]
    id?: StringFilter<"SuccessStory"> | string
    userId?: StringFilter<"SuccessStory"> | string
    partnerId?: StringFilter<"SuccessStory"> | string
    title?: StringFilter<"SuccessStory"> | string
    story?: StringFilter<"SuccessStory"> | string
    weddingDate?: DateTimeNullableFilter<"SuccessStory"> | Date | string | null
    photos?: JsonNullableFilter<"SuccessStory">
    isApproved?: BoolFilter<"SuccessStory"> | boolean
    isFeatured?: BoolFilter<"SuccessStory"> | boolean
    createdAt?: DateTimeFilter<"SuccessStory"> | Date | string
    updatedAt?: DateTimeFilter<"SuccessStory"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SuccessStoryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    partnerId?: SortOrder
    title?: SortOrder
    story?: SortOrder
    weddingDate?: SortOrderInput | SortOrder
    photos?: SortOrderInput | SortOrder
    isApproved?: SortOrder
    isFeatured?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SuccessStoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SuccessStoryWhereInput | SuccessStoryWhereInput[]
    OR?: SuccessStoryWhereInput[]
    NOT?: SuccessStoryWhereInput | SuccessStoryWhereInput[]
    userId?: StringFilter<"SuccessStory"> | string
    partnerId?: StringFilter<"SuccessStory"> | string
    title?: StringFilter<"SuccessStory"> | string
    story?: StringFilter<"SuccessStory"> | string
    weddingDate?: DateTimeNullableFilter<"SuccessStory"> | Date | string | null
    photos?: JsonNullableFilter<"SuccessStory">
    isApproved?: BoolFilter<"SuccessStory"> | boolean
    isFeatured?: BoolFilter<"SuccessStory"> | boolean
    createdAt?: DateTimeFilter<"SuccessStory"> | Date | string
    updatedAt?: DateTimeFilter<"SuccessStory"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type SuccessStoryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    partnerId?: SortOrder
    title?: SortOrder
    story?: SortOrder
    weddingDate?: SortOrderInput | SortOrder
    photos?: SortOrderInput | SortOrder
    isApproved?: SortOrder
    isFeatured?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SuccessStoryCountOrderByAggregateInput
    _max?: SuccessStoryMaxOrderByAggregateInput
    _min?: SuccessStoryMinOrderByAggregateInput
  }

  export type SuccessStoryScalarWhereWithAggregatesInput = {
    AND?: SuccessStoryScalarWhereWithAggregatesInput | SuccessStoryScalarWhereWithAggregatesInput[]
    OR?: SuccessStoryScalarWhereWithAggregatesInput[]
    NOT?: SuccessStoryScalarWhereWithAggregatesInput | SuccessStoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SuccessStory"> | string
    userId?: StringWithAggregatesFilter<"SuccessStory"> | string
    partnerId?: StringWithAggregatesFilter<"SuccessStory"> | string
    title?: StringWithAggregatesFilter<"SuccessStory"> | string
    story?: StringWithAggregatesFilter<"SuccessStory"> | string
    weddingDate?: DateTimeNullableWithAggregatesFilter<"SuccessStory"> | Date | string | null
    photos?: JsonNullableWithAggregatesFilter<"SuccessStory">
    isApproved?: BoolWithAggregatesFilter<"SuccessStory"> | boolean
    isFeatured?: BoolWithAggregatesFilter<"SuccessStory"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SuccessStory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SuccessStory"> | Date | string
  }

  export type FamilyMemberWhereInput = {
    AND?: FamilyMemberWhereInput | FamilyMemberWhereInput[]
    OR?: FamilyMemberWhereInput[]
    NOT?: FamilyMemberWhereInput | FamilyMemberWhereInput[]
    id?: StringFilter<"FamilyMember"> | string
    userId?: StringFilter<"FamilyMember"> | string
    name?: StringFilter<"FamilyMember"> | string
    relation?: StringFilter<"FamilyMember"> | string
    email?: StringNullableFilter<"FamilyMember"> | string | null
    mobile?: StringNullableFilter<"FamilyMember"> | string | null
    password?: StringNullableFilter<"FamilyMember"> | string | null
    canViewMatches?: BoolFilter<"FamilyMember"> | boolean
    canSendInterests?: BoolFilter<"FamilyMember"> | boolean
    canChat?: BoolFilter<"FamilyMember"> | boolean
    createdAt?: DateTimeFilter<"FamilyMember"> | Date | string
    updatedAt?: DateTimeFilter<"FamilyMember"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type FamilyMemberOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    relation?: SortOrder
    email?: SortOrderInput | SortOrder
    mobile?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    canViewMatches?: SortOrder
    canSendInterests?: SortOrder
    canChat?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type FamilyMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    mobile?: string
    AND?: FamilyMemberWhereInput | FamilyMemberWhereInput[]
    OR?: FamilyMemberWhereInput[]
    NOT?: FamilyMemberWhereInput | FamilyMemberWhereInput[]
    userId?: StringFilter<"FamilyMember"> | string
    name?: StringFilter<"FamilyMember"> | string
    relation?: StringFilter<"FamilyMember"> | string
    password?: StringNullableFilter<"FamilyMember"> | string | null
    canViewMatches?: BoolFilter<"FamilyMember"> | boolean
    canSendInterests?: BoolFilter<"FamilyMember"> | boolean
    canChat?: BoolFilter<"FamilyMember"> | boolean
    createdAt?: DateTimeFilter<"FamilyMember"> | Date | string
    updatedAt?: DateTimeFilter<"FamilyMember"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "email" | "mobile">

  export type FamilyMemberOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    relation?: SortOrder
    email?: SortOrderInput | SortOrder
    mobile?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    canViewMatches?: SortOrder
    canSendInterests?: SortOrder
    canChat?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FamilyMemberCountOrderByAggregateInput
    _max?: FamilyMemberMaxOrderByAggregateInput
    _min?: FamilyMemberMinOrderByAggregateInput
  }

  export type FamilyMemberScalarWhereWithAggregatesInput = {
    AND?: FamilyMemberScalarWhereWithAggregatesInput | FamilyMemberScalarWhereWithAggregatesInput[]
    OR?: FamilyMemberScalarWhereWithAggregatesInput[]
    NOT?: FamilyMemberScalarWhereWithAggregatesInput | FamilyMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FamilyMember"> | string
    userId?: StringWithAggregatesFilter<"FamilyMember"> | string
    name?: StringWithAggregatesFilter<"FamilyMember"> | string
    relation?: StringWithAggregatesFilter<"FamilyMember"> | string
    email?: StringNullableWithAggregatesFilter<"FamilyMember"> | string | null
    mobile?: StringNullableWithAggregatesFilter<"FamilyMember"> | string | null
    password?: StringNullableWithAggregatesFilter<"FamilyMember"> | string | null
    canViewMatches?: BoolWithAggregatesFilter<"FamilyMember"> | boolean
    canSendInterests?: BoolWithAggregatesFilter<"FamilyMember"> | boolean
    canChat?: BoolWithAggregatesFilter<"FamilyMember"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"FamilyMember"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FamilyMember"> | Date | string
  }

  export type ReferralWhereInput = {
    AND?: ReferralWhereInput | ReferralWhereInput[]
    OR?: ReferralWhereInput[]
    NOT?: ReferralWhereInput | ReferralWhereInput[]
    id?: StringFilter<"Referral"> | string
    referrerId?: StringFilter<"Referral"> | string
    referredId?: StringFilter<"Referral"> | string
    rewardAmount?: IntNullableFilter<"Referral"> | number | null
    status?: StringFilter<"Referral"> | string
    completedAt?: DateTimeNullableFilter<"Referral"> | Date | string | null
    createdAt?: DateTimeFilter<"Referral"> | Date | string
    referrer?: XOR<UserRelationFilter, UserWhereInput>
    referred?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ReferralOrderByWithRelationInput = {
    id?: SortOrder
    referrerId?: SortOrder
    referredId?: SortOrder
    rewardAmount?: SortOrderInput | SortOrder
    status?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    referrer?: UserOrderByWithRelationInput
    referred?: UserOrderByWithRelationInput
  }

  export type ReferralWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    referrerId_referredId?: ReferralReferrerIdReferredIdCompoundUniqueInput
    AND?: ReferralWhereInput | ReferralWhereInput[]
    OR?: ReferralWhereInput[]
    NOT?: ReferralWhereInput | ReferralWhereInput[]
    referrerId?: StringFilter<"Referral"> | string
    referredId?: StringFilter<"Referral"> | string
    rewardAmount?: IntNullableFilter<"Referral"> | number | null
    status?: StringFilter<"Referral"> | string
    completedAt?: DateTimeNullableFilter<"Referral"> | Date | string | null
    createdAt?: DateTimeFilter<"Referral"> | Date | string
    referrer?: XOR<UserRelationFilter, UserWhereInput>
    referred?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "referrerId_referredId">

  export type ReferralOrderByWithAggregationInput = {
    id?: SortOrder
    referrerId?: SortOrder
    referredId?: SortOrder
    rewardAmount?: SortOrderInput | SortOrder
    status?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ReferralCountOrderByAggregateInput
    _avg?: ReferralAvgOrderByAggregateInput
    _max?: ReferralMaxOrderByAggregateInput
    _min?: ReferralMinOrderByAggregateInput
    _sum?: ReferralSumOrderByAggregateInput
  }

  export type ReferralScalarWhereWithAggregatesInput = {
    AND?: ReferralScalarWhereWithAggregatesInput | ReferralScalarWhereWithAggregatesInput[]
    OR?: ReferralScalarWhereWithAggregatesInput[]
    NOT?: ReferralScalarWhereWithAggregatesInput | ReferralScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Referral"> | string
    referrerId?: StringWithAggregatesFilter<"Referral"> | string
    referredId?: StringWithAggregatesFilter<"Referral"> | string
    rewardAmount?: IntNullableWithAggregatesFilter<"Referral"> | number | null
    status?: StringWithAggregatesFilter<"Referral"> | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"Referral"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Referral"> | Date | string
  }

  export type AchievementWhereInput = {
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    id?: StringFilter<"Achievement"> | string
    userId?: StringFilter<"Achievement"> | string
    type?: StringFilter<"Achievement"> | string
    title?: StringFilter<"Achievement"> | string
    description?: StringNullableFilter<"Achievement"> | string | null
    points?: IntFilter<"Achievement"> | number
    icon?: StringNullableFilter<"Achievement"> | string | null
    unlockedAt?: DateTimeFilter<"Achievement"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AchievementOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    points?: SortOrder
    icon?: SortOrderInput | SortOrder
    unlockedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    userId?: StringFilter<"Achievement"> | string
    type?: StringFilter<"Achievement"> | string
    title?: StringFilter<"Achievement"> | string
    description?: StringNullableFilter<"Achievement"> | string | null
    points?: IntFilter<"Achievement"> | number
    icon?: StringNullableFilter<"Achievement"> | string | null
    unlockedAt?: DateTimeFilter<"Achievement"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type AchievementOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    points?: SortOrder
    icon?: SortOrderInput | SortOrder
    unlockedAt?: SortOrder
    _count?: AchievementCountOrderByAggregateInput
    _avg?: AchievementAvgOrderByAggregateInput
    _max?: AchievementMaxOrderByAggregateInput
    _min?: AchievementMinOrderByAggregateInput
    _sum?: AchievementSumOrderByAggregateInput
  }

  export type AchievementScalarWhereWithAggregatesInput = {
    AND?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    OR?: AchievementScalarWhereWithAggregatesInput[]
    NOT?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Achievement"> | string
    userId?: StringWithAggregatesFilter<"Achievement"> | string
    type?: StringWithAggregatesFilter<"Achievement"> | string
    title?: StringWithAggregatesFilter<"Achievement"> | string
    description?: StringNullableWithAggregatesFilter<"Achievement"> | string | null
    points?: IntWithAggregatesFilter<"Achievement"> | number
    icon?: StringNullableWithAggregatesFilter<"Achievement"> | string | null
    unlockedAt?: DateTimeWithAggregatesFilter<"Achievement"> | Date | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter<"Document"> | string
    userId?: StringFilter<"Document"> | string
    type?: StringFilter<"Document"> | string
    name?: StringFilter<"Document"> | string
    url?: StringFilter<"Document"> | string
    expiryDate?: DateTimeNullableFilter<"Document"> | Date | string | null
    isVerified?: BoolFilter<"Document"> | boolean
    verifiedAt?: DateTimeNullableFilter<"Document"> | Date | string | null
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    url?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    userId?: StringFilter<"Document"> | string
    type?: StringFilter<"Document"> | string
    name?: StringFilter<"Document"> | string
    url?: StringFilter<"Document"> | string
    expiryDate?: DateTimeNullableFilter<"Document"> | Date | string | null
    isVerified?: BoolFilter<"Document"> | boolean
    verifiedAt?: DateTimeNullableFilter<"Document"> | Date | string | null
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    url?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Document"> | string
    userId?: StringWithAggregatesFilter<"Document"> | string
    type?: StringWithAggregatesFilter<"Document"> | string
    name?: StringWithAggregatesFilter<"Document"> | string
    url?: StringWithAggregatesFilter<"Document"> | string
    expiryDate?: DateTimeNullableWithAggregatesFilter<"Document"> | Date | string | null
    isVerified?: BoolWithAggregatesFilter<"Document"> | boolean
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"Document"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
  }

  export type VideoCallWhereInput = {
    AND?: VideoCallWhereInput | VideoCallWhereInput[]
    OR?: VideoCallWhereInput[]
    NOT?: VideoCallWhereInput | VideoCallWhereInput[]
    id?: StringFilter<"VideoCall"> | string
    callerId?: StringFilter<"VideoCall"> | string
    participantId?: StringFilter<"VideoCall"> | string
    status?: StringFilter<"VideoCall"> | string
    scheduledAt?: DateTimeNullableFilter<"VideoCall"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"VideoCall"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"VideoCall"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"VideoCall"> | Date | string | null
    duration?: IntNullableFilter<"VideoCall"> | number | null
    roomId?: StringNullableFilter<"VideoCall"> | string | null
    notes?: StringNullableFilter<"VideoCall"> | string | null
    createdAt?: DateTimeFilter<"VideoCall"> | Date | string
    updatedAt?: DateTimeFilter<"VideoCall"> | Date | string
    caller?: XOR<UserRelationFilter, UserWhereInput>
    participant?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type VideoCallOrderByWithRelationInput = {
    id?: SortOrder
    callerId?: SortOrder
    participantId?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    roomId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    caller?: UserOrderByWithRelationInput
    participant?: UserOrderByWithRelationInput
  }

  export type VideoCallWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VideoCallWhereInput | VideoCallWhereInput[]
    OR?: VideoCallWhereInput[]
    NOT?: VideoCallWhereInput | VideoCallWhereInput[]
    callerId?: StringFilter<"VideoCall"> | string
    participantId?: StringFilter<"VideoCall"> | string
    status?: StringFilter<"VideoCall"> | string
    scheduledAt?: DateTimeNullableFilter<"VideoCall"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"VideoCall"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"VideoCall"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"VideoCall"> | Date | string | null
    duration?: IntNullableFilter<"VideoCall"> | number | null
    roomId?: StringNullableFilter<"VideoCall"> | string | null
    notes?: StringNullableFilter<"VideoCall"> | string | null
    createdAt?: DateTimeFilter<"VideoCall"> | Date | string
    updatedAt?: DateTimeFilter<"VideoCall"> | Date | string
    caller?: XOR<UserRelationFilter, UserWhereInput>
    participant?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type VideoCallOrderByWithAggregationInput = {
    id?: SortOrder
    callerId?: SortOrder
    participantId?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    roomId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VideoCallCountOrderByAggregateInput
    _avg?: VideoCallAvgOrderByAggregateInput
    _max?: VideoCallMaxOrderByAggregateInput
    _min?: VideoCallMinOrderByAggregateInput
    _sum?: VideoCallSumOrderByAggregateInput
  }

  export type VideoCallScalarWhereWithAggregatesInput = {
    AND?: VideoCallScalarWhereWithAggregatesInput | VideoCallScalarWhereWithAggregatesInput[]
    OR?: VideoCallScalarWhereWithAggregatesInput[]
    NOT?: VideoCallScalarWhereWithAggregatesInput | VideoCallScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VideoCall"> | string
    callerId?: StringWithAggregatesFilter<"VideoCall"> | string
    participantId?: StringWithAggregatesFilter<"VideoCall"> | string
    status?: StringWithAggregatesFilter<"VideoCall"> | string
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"VideoCall"> | Date | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"VideoCall"> | Date | string | null
    endedAt?: DateTimeNullableWithAggregatesFilter<"VideoCall"> | Date | string | null
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"VideoCall"> | Date | string | null
    duration?: IntNullableWithAggregatesFilter<"VideoCall"> | number | null
    roomId?: StringNullableWithAggregatesFilter<"VideoCall"> | string | null
    notes?: StringNullableWithAggregatesFilter<"VideoCall"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"VideoCall"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VideoCall"> | Date | string
  }

  export type ProfileComparisonWhereInput = {
    AND?: ProfileComparisonWhereInput | ProfileComparisonWhereInput[]
    OR?: ProfileComparisonWhereInput[]
    NOT?: ProfileComparisonWhereInput | ProfileComparisonWhereInput[]
    id?: StringFilter<"ProfileComparison"> | string
    userId?: StringFilter<"ProfileComparison"> | string
    profileId?: StringFilter<"ProfileComparison"> | string
    comparisonData?: JsonNullableFilter<"ProfileComparison">
    createdAt?: DateTimeFilter<"ProfileComparison"> | Date | string
    expiresAt?: DateTimeNullableFilter<"ProfileComparison"> | Date | string | null
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
  }

  export type ProfileComparisonOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    profileId?: SortOrder
    comparisonData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    profile?: ProfileOrderByWithRelationInput
  }

  export type ProfileComparisonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_profileId?: ProfileComparisonUserIdProfileIdCompoundUniqueInput
    AND?: ProfileComparisonWhereInput | ProfileComparisonWhereInput[]
    OR?: ProfileComparisonWhereInput[]
    NOT?: ProfileComparisonWhereInput | ProfileComparisonWhereInput[]
    userId?: StringFilter<"ProfileComparison"> | string
    profileId?: StringFilter<"ProfileComparison"> | string
    comparisonData?: JsonNullableFilter<"ProfileComparison">
    createdAt?: DateTimeFilter<"ProfileComparison"> | Date | string
    expiresAt?: DateTimeNullableFilter<"ProfileComparison"> | Date | string | null
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
  }, "id" | "userId_profileId">

  export type ProfileComparisonOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    profileId?: SortOrder
    comparisonData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: ProfileComparisonCountOrderByAggregateInput
    _max?: ProfileComparisonMaxOrderByAggregateInput
    _min?: ProfileComparisonMinOrderByAggregateInput
  }

  export type ProfileComparisonScalarWhereWithAggregatesInput = {
    AND?: ProfileComparisonScalarWhereWithAggregatesInput | ProfileComparisonScalarWhereWithAggregatesInput[]
    OR?: ProfileComparisonScalarWhereWithAggregatesInput[]
    NOT?: ProfileComparisonScalarWhereWithAggregatesInput | ProfileComparisonScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProfileComparison"> | string
    userId?: StringWithAggregatesFilter<"ProfileComparison"> | string
    profileId?: StringWithAggregatesFilter<"ProfileComparison"> | string
    comparisonData?: JsonNullableWithAggregatesFilter<"ProfileComparison">
    createdAt?: DateTimeWithAggregatesFilter<"ProfileComparison"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"ProfileComparison"> | Date | string | null
  }

  export type ForumPostWhereInput = {
    AND?: ForumPostWhereInput | ForumPostWhereInput[]
    OR?: ForumPostWhereInput[]
    NOT?: ForumPostWhereInput | ForumPostWhereInput[]
    id?: StringFilter<"ForumPost"> | string
    userId?: StringFilter<"ForumPost"> | string
    title?: StringFilter<"ForumPost"> | string
    content?: StringFilter<"ForumPost"> | string
    category?: StringNullableFilter<"ForumPost"> | string | null
    tags?: StringNullableListFilter<"ForumPost">
    likes?: IntFilter<"ForumPost"> | number
    views?: IntFilter<"ForumPost"> | number
    isPinned?: BoolFilter<"ForumPost"> | boolean
    createdAt?: DateTimeFilter<"ForumPost"> | Date | string
    updatedAt?: DateTimeFilter<"ForumPost"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    comments?: ForumCommentListRelationFilter
  }

  export type ForumPostOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrderInput | SortOrder
    tags?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    isPinned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    comments?: ForumCommentOrderByRelationAggregateInput
  }

  export type ForumPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ForumPostWhereInput | ForumPostWhereInput[]
    OR?: ForumPostWhereInput[]
    NOT?: ForumPostWhereInput | ForumPostWhereInput[]
    userId?: StringFilter<"ForumPost"> | string
    title?: StringFilter<"ForumPost"> | string
    content?: StringFilter<"ForumPost"> | string
    category?: StringNullableFilter<"ForumPost"> | string | null
    tags?: StringNullableListFilter<"ForumPost">
    likes?: IntFilter<"ForumPost"> | number
    views?: IntFilter<"ForumPost"> | number
    isPinned?: BoolFilter<"ForumPost"> | boolean
    createdAt?: DateTimeFilter<"ForumPost"> | Date | string
    updatedAt?: DateTimeFilter<"ForumPost"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    comments?: ForumCommentListRelationFilter
  }, "id">

  export type ForumPostOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrderInput | SortOrder
    tags?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    isPinned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ForumPostCountOrderByAggregateInput
    _avg?: ForumPostAvgOrderByAggregateInput
    _max?: ForumPostMaxOrderByAggregateInput
    _min?: ForumPostMinOrderByAggregateInput
    _sum?: ForumPostSumOrderByAggregateInput
  }

  export type ForumPostScalarWhereWithAggregatesInput = {
    AND?: ForumPostScalarWhereWithAggregatesInput | ForumPostScalarWhereWithAggregatesInput[]
    OR?: ForumPostScalarWhereWithAggregatesInput[]
    NOT?: ForumPostScalarWhereWithAggregatesInput | ForumPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ForumPost"> | string
    userId?: StringWithAggregatesFilter<"ForumPost"> | string
    title?: StringWithAggregatesFilter<"ForumPost"> | string
    content?: StringWithAggregatesFilter<"ForumPost"> | string
    category?: StringNullableWithAggregatesFilter<"ForumPost"> | string | null
    tags?: StringNullableListFilter<"ForumPost">
    likes?: IntWithAggregatesFilter<"ForumPost"> | number
    views?: IntWithAggregatesFilter<"ForumPost"> | number
    isPinned?: BoolWithAggregatesFilter<"ForumPost"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ForumPost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ForumPost"> | Date | string
  }

  export type ForumCommentWhereInput = {
    AND?: ForumCommentWhereInput | ForumCommentWhereInput[]
    OR?: ForumCommentWhereInput[]
    NOT?: ForumCommentWhereInput | ForumCommentWhereInput[]
    id?: StringFilter<"ForumComment"> | string
    userId?: StringFilter<"ForumComment"> | string
    postId?: StringFilter<"ForumComment"> | string
    content?: StringFilter<"ForumComment"> | string
    createdAt?: DateTimeFilter<"ForumComment"> | Date | string
    updatedAt?: DateTimeFilter<"ForumComment"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    post?: XOR<ForumPostRelationFilter, ForumPostWhereInput>
  }

  export type ForumCommentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    post?: ForumPostOrderByWithRelationInput
  }

  export type ForumCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ForumCommentWhereInput | ForumCommentWhereInput[]
    OR?: ForumCommentWhereInput[]
    NOT?: ForumCommentWhereInput | ForumCommentWhereInput[]
    userId?: StringFilter<"ForumComment"> | string
    postId?: StringFilter<"ForumComment"> | string
    content?: StringFilter<"ForumComment"> | string
    createdAt?: DateTimeFilter<"ForumComment"> | Date | string
    updatedAt?: DateTimeFilter<"ForumComment"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    post?: XOR<ForumPostRelationFilter, ForumPostWhereInput>
  }, "id">

  export type ForumCommentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ForumCommentCountOrderByAggregateInput
    _max?: ForumCommentMaxOrderByAggregateInput
    _min?: ForumCommentMinOrderByAggregateInput
  }

  export type ForumCommentScalarWhereWithAggregatesInput = {
    AND?: ForumCommentScalarWhereWithAggregatesInput | ForumCommentScalarWhereWithAggregatesInput[]
    OR?: ForumCommentScalarWhereWithAggregatesInput[]
    NOT?: ForumCommentScalarWhereWithAggregatesInput | ForumCommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ForumComment"> | string
    userId?: StringWithAggregatesFilter<"ForumComment"> | string
    postId?: StringWithAggregatesFilter<"ForumComment"> | string
    content?: StringWithAggregatesFilter<"ForumComment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ForumComment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ForumComment"> | Date | string
  }

  export type CommunityGroupWhereInput = {
    AND?: CommunityGroupWhereInput | CommunityGroupWhereInput[]
    OR?: CommunityGroupWhereInput[]
    NOT?: CommunityGroupWhereInput | CommunityGroupWhereInput[]
    id?: StringFilter<"CommunityGroup"> | string
    name?: StringFilter<"CommunityGroup"> | string
    description?: StringFilter<"CommunityGroup"> | string
    photoUrl?: StringNullableFilter<"CommunityGroup"> | string | null
    isPublic?: BoolFilter<"CommunityGroup"> | boolean
    createdBy?: StringFilter<"CommunityGroup"> | string
    createdAt?: DateTimeFilter<"CommunityGroup"> | Date | string
    updatedAt?: DateTimeFilter<"CommunityGroup"> | Date | string
    members?: GroupMemberListRelationFilter
  }

  export type CommunityGroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    photoUrl?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    members?: GroupMemberOrderByRelationAggregateInput
  }

  export type CommunityGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommunityGroupWhereInput | CommunityGroupWhereInput[]
    OR?: CommunityGroupWhereInput[]
    NOT?: CommunityGroupWhereInput | CommunityGroupWhereInput[]
    name?: StringFilter<"CommunityGroup"> | string
    description?: StringFilter<"CommunityGroup"> | string
    photoUrl?: StringNullableFilter<"CommunityGroup"> | string | null
    isPublic?: BoolFilter<"CommunityGroup"> | boolean
    createdBy?: StringFilter<"CommunityGroup"> | string
    createdAt?: DateTimeFilter<"CommunityGroup"> | Date | string
    updatedAt?: DateTimeFilter<"CommunityGroup"> | Date | string
    members?: GroupMemberListRelationFilter
  }, "id">

  export type CommunityGroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    photoUrl?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommunityGroupCountOrderByAggregateInput
    _max?: CommunityGroupMaxOrderByAggregateInput
    _min?: CommunityGroupMinOrderByAggregateInput
  }

  export type CommunityGroupScalarWhereWithAggregatesInput = {
    AND?: CommunityGroupScalarWhereWithAggregatesInput | CommunityGroupScalarWhereWithAggregatesInput[]
    OR?: CommunityGroupScalarWhereWithAggregatesInput[]
    NOT?: CommunityGroupScalarWhereWithAggregatesInput | CommunityGroupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CommunityGroup"> | string
    name?: StringWithAggregatesFilter<"CommunityGroup"> | string
    description?: StringWithAggregatesFilter<"CommunityGroup"> | string
    photoUrl?: StringNullableWithAggregatesFilter<"CommunityGroup"> | string | null
    isPublic?: BoolWithAggregatesFilter<"CommunityGroup"> | boolean
    createdBy?: StringWithAggregatesFilter<"CommunityGroup"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CommunityGroup"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CommunityGroup"> | Date | string
  }

  export type GroupMemberWhereInput = {
    AND?: GroupMemberWhereInput | GroupMemberWhereInput[]
    OR?: GroupMemberWhereInput[]
    NOT?: GroupMemberWhereInput | GroupMemberWhereInput[]
    id?: StringFilter<"GroupMember"> | string
    groupId?: StringFilter<"GroupMember"> | string
    userId?: StringFilter<"GroupMember"> | string
    role?: StringFilter<"GroupMember"> | string
    joinedAt?: DateTimeFilter<"GroupMember"> | Date | string
    group?: XOR<CommunityGroupRelationFilter, CommunityGroupWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type GroupMemberOrderByWithRelationInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    group?: CommunityGroupOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type GroupMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    groupId_userId?: GroupMemberGroupIdUserIdCompoundUniqueInput
    AND?: GroupMemberWhereInput | GroupMemberWhereInput[]
    OR?: GroupMemberWhereInput[]
    NOT?: GroupMemberWhereInput | GroupMemberWhereInput[]
    groupId?: StringFilter<"GroupMember"> | string
    userId?: StringFilter<"GroupMember"> | string
    role?: StringFilter<"GroupMember"> | string
    joinedAt?: DateTimeFilter<"GroupMember"> | Date | string
    group?: XOR<CommunityGroupRelationFilter, CommunityGroupWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "groupId_userId">

  export type GroupMemberOrderByWithAggregationInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    _count?: GroupMemberCountOrderByAggregateInput
    _max?: GroupMemberMaxOrderByAggregateInput
    _min?: GroupMemberMinOrderByAggregateInput
  }

  export type GroupMemberScalarWhereWithAggregatesInput = {
    AND?: GroupMemberScalarWhereWithAggregatesInput | GroupMemberScalarWhereWithAggregatesInput[]
    OR?: GroupMemberScalarWhereWithAggregatesInput[]
    NOT?: GroupMemberScalarWhereWithAggregatesInput | GroupMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GroupMember"> | string
    groupId?: StringWithAggregatesFilter<"GroupMember"> | string
    userId?: StringWithAggregatesFilter<"GroupMember"> | string
    role?: StringWithAggregatesFilter<"GroupMember"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"GroupMember"> | Date | string
  }

  export type CommunityEventWhereInput = {
    AND?: CommunityEventWhereInput | CommunityEventWhereInput[]
    OR?: CommunityEventWhereInput[]
    NOT?: CommunityEventWhereInput | CommunityEventWhereInput[]
    id?: StringFilter<"CommunityEvent"> | string
    title?: StringFilter<"CommunityEvent"> | string
    description?: StringFilter<"CommunityEvent"> | string
    eventDate?: DateTimeFilter<"CommunityEvent"> | Date | string
    location?: StringFilter<"CommunityEvent"> | string
    photoUrl?: StringNullableFilter<"CommunityEvent"> | string | null
    maxParticipants?: IntNullableFilter<"CommunityEvent"> | number | null
    createdBy?: StringFilter<"CommunityEvent"> | string
    createdAt?: DateTimeFilter<"CommunityEvent"> | Date | string
    updatedAt?: DateTimeFilter<"CommunityEvent"> | Date | string
    participants?: EventParticipantListRelationFilter
  }

  export type CommunityEventOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    eventDate?: SortOrder
    location?: SortOrder
    photoUrl?: SortOrderInput | SortOrder
    maxParticipants?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    participants?: EventParticipantOrderByRelationAggregateInput
  }

  export type CommunityEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommunityEventWhereInput | CommunityEventWhereInput[]
    OR?: CommunityEventWhereInput[]
    NOT?: CommunityEventWhereInput | CommunityEventWhereInput[]
    title?: StringFilter<"CommunityEvent"> | string
    description?: StringFilter<"CommunityEvent"> | string
    eventDate?: DateTimeFilter<"CommunityEvent"> | Date | string
    location?: StringFilter<"CommunityEvent"> | string
    photoUrl?: StringNullableFilter<"CommunityEvent"> | string | null
    maxParticipants?: IntNullableFilter<"CommunityEvent"> | number | null
    createdBy?: StringFilter<"CommunityEvent"> | string
    createdAt?: DateTimeFilter<"CommunityEvent"> | Date | string
    updatedAt?: DateTimeFilter<"CommunityEvent"> | Date | string
    participants?: EventParticipantListRelationFilter
  }, "id">

  export type CommunityEventOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    eventDate?: SortOrder
    location?: SortOrder
    photoUrl?: SortOrderInput | SortOrder
    maxParticipants?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommunityEventCountOrderByAggregateInput
    _avg?: CommunityEventAvgOrderByAggregateInput
    _max?: CommunityEventMaxOrderByAggregateInput
    _min?: CommunityEventMinOrderByAggregateInput
    _sum?: CommunityEventSumOrderByAggregateInput
  }

  export type CommunityEventScalarWhereWithAggregatesInput = {
    AND?: CommunityEventScalarWhereWithAggregatesInput | CommunityEventScalarWhereWithAggregatesInput[]
    OR?: CommunityEventScalarWhereWithAggregatesInput[]
    NOT?: CommunityEventScalarWhereWithAggregatesInput | CommunityEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CommunityEvent"> | string
    title?: StringWithAggregatesFilter<"CommunityEvent"> | string
    description?: StringWithAggregatesFilter<"CommunityEvent"> | string
    eventDate?: DateTimeWithAggregatesFilter<"CommunityEvent"> | Date | string
    location?: StringWithAggregatesFilter<"CommunityEvent"> | string
    photoUrl?: StringNullableWithAggregatesFilter<"CommunityEvent"> | string | null
    maxParticipants?: IntNullableWithAggregatesFilter<"CommunityEvent"> | number | null
    createdBy?: StringWithAggregatesFilter<"CommunityEvent"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CommunityEvent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CommunityEvent"> | Date | string
  }

  export type EventParticipantWhereInput = {
    AND?: EventParticipantWhereInput | EventParticipantWhereInput[]
    OR?: EventParticipantWhereInput[]
    NOT?: EventParticipantWhereInput | EventParticipantWhereInput[]
    id?: StringFilter<"EventParticipant"> | string
    eventId?: StringFilter<"EventParticipant"> | string
    userId?: StringFilter<"EventParticipant"> | string
    joinedAt?: DateTimeFilter<"EventParticipant"> | Date | string
    event?: XOR<CommunityEventRelationFilter, CommunityEventWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type EventParticipantOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
    event?: CommunityEventOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type EventParticipantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    eventId_userId?: EventParticipantEventIdUserIdCompoundUniqueInput
    AND?: EventParticipantWhereInput | EventParticipantWhereInput[]
    OR?: EventParticipantWhereInput[]
    NOT?: EventParticipantWhereInput | EventParticipantWhereInput[]
    eventId?: StringFilter<"EventParticipant"> | string
    userId?: StringFilter<"EventParticipant"> | string
    joinedAt?: DateTimeFilter<"EventParticipant"> | Date | string
    event?: XOR<CommunityEventRelationFilter, CommunityEventWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "eventId_userId">

  export type EventParticipantOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
    _count?: EventParticipantCountOrderByAggregateInput
    _max?: EventParticipantMaxOrderByAggregateInput
    _min?: EventParticipantMinOrderByAggregateInput
  }

  export type EventParticipantScalarWhereWithAggregatesInput = {
    AND?: EventParticipantScalarWhereWithAggregatesInput | EventParticipantScalarWhereWithAggregatesInput[]
    OR?: EventParticipantScalarWhereWithAggregatesInput[]
    NOT?: EventParticipantScalarWhereWithAggregatesInput | EventParticipantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EventParticipant"> | string
    eventId?: StringWithAggregatesFilter<"EventParticipant"> | string
    userId?: StringWithAggregatesFilter<"EventParticipant"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"EventParticipant"> | Date | string
  }

  export type BlogPostWhereInput = {
    AND?: BlogPostWhereInput | BlogPostWhereInput[]
    OR?: BlogPostWhereInput[]
    NOT?: BlogPostWhereInput | BlogPostWhereInput[]
    id?: StringFilter<"BlogPost"> | string
    userId?: StringFilter<"BlogPost"> | string
    title?: StringFilter<"BlogPost"> | string
    content?: StringFilter<"BlogPost"> | string
    excerpt?: StringNullableFilter<"BlogPost"> | string | null
    photoUrl?: StringNullableFilter<"BlogPost"> | string | null
    tags?: StringNullableListFilter<"BlogPost">
    isPublished?: BoolFilter<"BlogPost"> | boolean
    views?: IntFilter<"BlogPost"> | number
    createdAt?: DateTimeFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeFilter<"BlogPost"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type BlogPostOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    photoUrl?: SortOrderInput | SortOrder
    tags?: SortOrder
    isPublished?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type BlogPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BlogPostWhereInput | BlogPostWhereInput[]
    OR?: BlogPostWhereInput[]
    NOT?: BlogPostWhereInput | BlogPostWhereInput[]
    userId?: StringFilter<"BlogPost"> | string
    title?: StringFilter<"BlogPost"> | string
    content?: StringFilter<"BlogPost"> | string
    excerpt?: StringNullableFilter<"BlogPost"> | string | null
    photoUrl?: StringNullableFilter<"BlogPost"> | string | null
    tags?: StringNullableListFilter<"BlogPost">
    isPublished?: BoolFilter<"BlogPost"> | boolean
    views?: IntFilter<"BlogPost"> | number
    createdAt?: DateTimeFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeFilter<"BlogPost"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type BlogPostOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    photoUrl?: SortOrderInput | SortOrder
    tags?: SortOrder
    isPublished?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BlogPostCountOrderByAggregateInput
    _avg?: BlogPostAvgOrderByAggregateInput
    _max?: BlogPostMaxOrderByAggregateInput
    _min?: BlogPostMinOrderByAggregateInput
    _sum?: BlogPostSumOrderByAggregateInput
  }

  export type BlogPostScalarWhereWithAggregatesInput = {
    AND?: BlogPostScalarWhereWithAggregatesInput | BlogPostScalarWhereWithAggregatesInput[]
    OR?: BlogPostScalarWhereWithAggregatesInput[]
    NOT?: BlogPostScalarWhereWithAggregatesInput | BlogPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlogPost"> | string
    userId?: StringWithAggregatesFilter<"BlogPost"> | string
    title?: StringWithAggregatesFilter<"BlogPost"> | string
    content?: StringWithAggregatesFilter<"BlogPost"> | string
    excerpt?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    photoUrl?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    tags?: StringNullableListFilter<"BlogPost">
    isPublished?: BoolWithAggregatesFilter<"BlogPost"> | boolean
    views?: IntWithAggregatesFilter<"BlogPost"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BlogPost"> | Date | string
  }

  export type MatchScoreWhereInput = {
    AND?: MatchScoreWhereInput | MatchScoreWhereInput[]
    OR?: MatchScoreWhereInput[]
    NOT?: MatchScoreWhereInput | MatchScoreWhereInput[]
    id?: StringFilter<"MatchScore"> | string
    userId?: StringFilter<"MatchScore"> | string
    matchedUserId?: StringFilter<"MatchScore"> | string
    overallScore?: IntFilter<"MatchScore"> | number
    religionScore?: IntNullableFilter<"MatchScore"> | number | null
    educationScore?: IntNullableFilter<"MatchScore"> | number | null
    lifestyleScore?: IntNullableFilter<"MatchScore"> | number | null
    locationScore?: IntNullableFilter<"MatchScore"> | number | null
    familyScore?: IntNullableFilter<"MatchScore"> | number | null
    matchReasons?: JsonNullableFilter<"MatchScore">
    isReverseMatch?: BoolFilter<"MatchScore"> | boolean
    createdAt?: DateTimeFilter<"MatchScore"> | Date | string
    updatedAt?: DateTimeFilter<"MatchScore"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    matchedUser?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MatchScoreOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    matchedUserId?: SortOrder
    overallScore?: SortOrder
    religionScore?: SortOrderInput | SortOrder
    educationScore?: SortOrderInput | SortOrder
    lifestyleScore?: SortOrderInput | SortOrder
    locationScore?: SortOrderInput | SortOrder
    familyScore?: SortOrderInput | SortOrder
    matchReasons?: SortOrderInput | SortOrder
    isReverseMatch?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    matchedUser?: UserOrderByWithRelationInput
  }

  export type MatchScoreWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_matchedUserId?: MatchScoreUserIdMatchedUserIdCompoundUniqueInput
    AND?: MatchScoreWhereInput | MatchScoreWhereInput[]
    OR?: MatchScoreWhereInput[]
    NOT?: MatchScoreWhereInput | MatchScoreWhereInput[]
    userId?: StringFilter<"MatchScore"> | string
    matchedUserId?: StringFilter<"MatchScore"> | string
    overallScore?: IntFilter<"MatchScore"> | number
    religionScore?: IntNullableFilter<"MatchScore"> | number | null
    educationScore?: IntNullableFilter<"MatchScore"> | number | null
    lifestyleScore?: IntNullableFilter<"MatchScore"> | number | null
    locationScore?: IntNullableFilter<"MatchScore"> | number | null
    familyScore?: IntNullableFilter<"MatchScore"> | number | null
    matchReasons?: JsonNullableFilter<"MatchScore">
    isReverseMatch?: BoolFilter<"MatchScore"> | boolean
    createdAt?: DateTimeFilter<"MatchScore"> | Date | string
    updatedAt?: DateTimeFilter<"MatchScore"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    matchedUser?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_matchedUserId">

  export type MatchScoreOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    matchedUserId?: SortOrder
    overallScore?: SortOrder
    religionScore?: SortOrderInput | SortOrder
    educationScore?: SortOrderInput | SortOrder
    lifestyleScore?: SortOrderInput | SortOrder
    locationScore?: SortOrderInput | SortOrder
    familyScore?: SortOrderInput | SortOrder
    matchReasons?: SortOrderInput | SortOrder
    isReverseMatch?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MatchScoreCountOrderByAggregateInput
    _avg?: MatchScoreAvgOrderByAggregateInput
    _max?: MatchScoreMaxOrderByAggregateInput
    _min?: MatchScoreMinOrderByAggregateInput
    _sum?: MatchScoreSumOrderByAggregateInput
  }

  export type MatchScoreScalarWhereWithAggregatesInput = {
    AND?: MatchScoreScalarWhereWithAggregatesInput | MatchScoreScalarWhereWithAggregatesInput[]
    OR?: MatchScoreScalarWhereWithAggregatesInput[]
    NOT?: MatchScoreScalarWhereWithAggregatesInput | MatchScoreScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MatchScore"> | string
    userId?: StringWithAggregatesFilter<"MatchScore"> | string
    matchedUserId?: StringWithAggregatesFilter<"MatchScore"> | string
    overallScore?: IntWithAggregatesFilter<"MatchScore"> | number
    religionScore?: IntNullableWithAggregatesFilter<"MatchScore"> | number | null
    educationScore?: IntNullableWithAggregatesFilter<"MatchScore"> | number | null
    lifestyleScore?: IntNullableWithAggregatesFilter<"MatchScore"> | number | null
    locationScore?: IntNullableWithAggregatesFilter<"MatchScore"> | number | null
    familyScore?: IntNullableWithAggregatesFilter<"MatchScore"> | number | null
    matchReasons?: JsonNullableWithAggregatesFilter<"MatchScore">
    isReverseMatch?: BoolWithAggregatesFilter<"MatchScore"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"MatchScore"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MatchScore"> | Date | string
  }

  export type SearchHistoryWhereInput = {
    AND?: SearchHistoryWhereInput | SearchHistoryWhereInput[]
    OR?: SearchHistoryWhereInput[]
    NOT?: SearchHistoryWhereInput | SearchHistoryWhereInput[]
    id?: StringFilter<"SearchHistory"> | string
    userId?: StringFilter<"SearchHistory"> | string
    profileId?: StringNullableFilter<"SearchHistory"> | string | null
    searchQuery?: StringNullableFilter<"SearchHistory"> | string | null
    filters?: JsonNullableFilter<"SearchHistory">
    createdAt?: DateTimeFilter<"SearchHistory"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SearchHistoryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    profileId?: SortOrderInput | SortOrder
    searchQuery?: SortOrderInput | SortOrder
    filters?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SearchHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SearchHistoryWhereInput | SearchHistoryWhereInput[]
    OR?: SearchHistoryWhereInput[]
    NOT?: SearchHistoryWhereInput | SearchHistoryWhereInput[]
    userId?: StringFilter<"SearchHistory"> | string
    profileId?: StringNullableFilter<"SearchHistory"> | string | null
    searchQuery?: StringNullableFilter<"SearchHistory"> | string | null
    filters?: JsonNullableFilter<"SearchHistory">
    createdAt?: DateTimeFilter<"SearchHistory"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type SearchHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    profileId?: SortOrderInput | SortOrder
    searchQuery?: SortOrderInput | SortOrder
    filters?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SearchHistoryCountOrderByAggregateInput
    _max?: SearchHistoryMaxOrderByAggregateInput
    _min?: SearchHistoryMinOrderByAggregateInput
  }

  export type SearchHistoryScalarWhereWithAggregatesInput = {
    AND?: SearchHistoryScalarWhereWithAggregatesInput | SearchHistoryScalarWhereWithAggregatesInput[]
    OR?: SearchHistoryScalarWhereWithAggregatesInput[]
    NOT?: SearchHistoryScalarWhereWithAggregatesInput | SearchHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SearchHistory"> | string
    userId?: StringWithAggregatesFilter<"SearchHistory"> | string
    profileId?: StringNullableWithAggregatesFilter<"SearchHistory"> | string | null
    searchQuery?: StringNullableWithAggregatesFilter<"SearchHistory"> | string | null
    filters?: JsonNullableWithAggregatesFilter<"SearchHistory">
    createdAt?: DateTimeWithAggregatesFilter<"SearchHistory"> | Date | string
  }

  export type MessageTemplateWhereInput = {
    AND?: MessageTemplateWhereInput | MessageTemplateWhereInput[]
    OR?: MessageTemplateWhereInput[]
    NOT?: MessageTemplateWhereInput | MessageTemplateWhereInput[]
    id?: StringFilter<"MessageTemplate"> | string
    userId?: StringFilter<"MessageTemplate"> | string
    name?: StringFilter<"MessageTemplate"> | string
    content?: StringFilter<"MessageTemplate"> | string
    category?: StringNullableFilter<"MessageTemplate"> | string | null
    createdAt?: DateTimeFilter<"MessageTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"MessageTemplate"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MessageTemplateOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    content?: SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type MessageTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageTemplateWhereInput | MessageTemplateWhereInput[]
    OR?: MessageTemplateWhereInput[]
    NOT?: MessageTemplateWhereInput | MessageTemplateWhereInput[]
    userId?: StringFilter<"MessageTemplate"> | string
    name?: StringFilter<"MessageTemplate"> | string
    content?: StringFilter<"MessageTemplate"> | string
    category?: StringNullableFilter<"MessageTemplate"> | string | null
    createdAt?: DateTimeFilter<"MessageTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"MessageTemplate"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type MessageTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    content?: SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MessageTemplateCountOrderByAggregateInput
    _max?: MessageTemplateMaxOrderByAggregateInput
    _min?: MessageTemplateMinOrderByAggregateInput
  }

  export type MessageTemplateScalarWhereWithAggregatesInput = {
    AND?: MessageTemplateScalarWhereWithAggregatesInput | MessageTemplateScalarWhereWithAggregatesInput[]
    OR?: MessageTemplateScalarWhereWithAggregatesInput[]
    NOT?: MessageTemplateScalarWhereWithAggregatesInput | MessageTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageTemplate"> | string
    userId?: StringWithAggregatesFilter<"MessageTemplate"> | string
    name?: StringWithAggregatesFilter<"MessageTemplate"> | string
    content?: StringWithAggregatesFilter<"MessageTemplate"> | string
    category?: StringNullableWithAggregatesFilter<"MessageTemplate"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MessageTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MessageTemplate"> | Date | string
  }

  export type IceBreakerWhereInput = {
    AND?: IceBreakerWhereInput | IceBreakerWhereInput[]
    OR?: IceBreakerWhereInput[]
    NOT?: IceBreakerWhereInput | IceBreakerWhereInput[]
    id?: StringFilter<"IceBreaker"> | string
    userId?: StringFilter<"IceBreaker"> | string
    profileId?: StringFilter<"IceBreaker"> | string
    question?: StringFilter<"IceBreaker"> | string
    answer?: StringNullableFilter<"IceBreaker"> | string | null
    createdAt?: DateTimeFilter<"IceBreaker"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type IceBreakerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    profileId?: SortOrder
    question?: SortOrder
    answer?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type IceBreakerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IceBreakerWhereInput | IceBreakerWhereInput[]
    OR?: IceBreakerWhereInput[]
    NOT?: IceBreakerWhereInput | IceBreakerWhereInput[]
    userId?: StringFilter<"IceBreaker"> | string
    profileId?: StringFilter<"IceBreaker"> | string
    question?: StringFilter<"IceBreaker"> | string
    answer?: StringNullableFilter<"IceBreaker"> | string | null
    createdAt?: DateTimeFilter<"IceBreaker"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type IceBreakerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    profileId?: SortOrder
    question?: SortOrder
    answer?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: IceBreakerCountOrderByAggregateInput
    _max?: IceBreakerMaxOrderByAggregateInput
    _min?: IceBreakerMinOrderByAggregateInput
  }

  export type IceBreakerScalarWhereWithAggregatesInput = {
    AND?: IceBreakerScalarWhereWithAggregatesInput | IceBreakerScalarWhereWithAggregatesInput[]
    OR?: IceBreakerScalarWhereWithAggregatesInput[]
    NOT?: IceBreakerScalarWhereWithAggregatesInput | IceBreakerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IceBreaker"> | string
    userId?: StringWithAggregatesFilter<"IceBreaker"> | string
    profileId?: StringWithAggregatesFilter<"IceBreaker"> | string
    question?: StringWithAggregatesFilter<"IceBreaker"> | string
    answer?: StringNullableWithAggregatesFilter<"IceBreaker"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"IceBreaker"> | Date | string
  }

  export type TestimonialWhereInput = {
    AND?: TestimonialWhereInput | TestimonialWhereInput[]
    OR?: TestimonialWhereInput[]
    NOT?: TestimonialWhereInput | TestimonialWhereInput[]
    id?: StringFilter<"Testimonial"> | string
    profileId?: StringFilter<"Testimonial"> | string
    authorName?: StringFilter<"Testimonial"> | string
    authorRelation?: StringNullableFilter<"Testimonial"> | string | null
    authorEmail?: StringNullableFilter<"Testimonial"> | string | null
    content?: StringFilter<"Testimonial"> | string
    rating?: IntNullableFilter<"Testimonial"> | number | null
    isApproved?: BoolFilter<"Testimonial"> | boolean
    createdAt?: DateTimeFilter<"Testimonial"> | Date | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
  }

  export type TestimonialOrderByWithRelationInput = {
    id?: SortOrder
    profileId?: SortOrder
    authorName?: SortOrder
    authorRelation?: SortOrderInput | SortOrder
    authorEmail?: SortOrderInput | SortOrder
    content?: SortOrder
    rating?: SortOrderInput | SortOrder
    isApproved?: SortOrder
    createdAt?: SortOrder
    profile?: ProfileOrderByWithRelationInput
  }

  export type TestimonialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TestimonialWhereInput | TestimonialWhereInput[]
    OR?: TestimonialWhereInput[]
    NOT?: TestimonialWhereInput | TestimonialWhereInput[]
    profileId?: StringFilter<"Testimonial"> | string
    authorName?: StringFilter<"Testimonial"> | string
    authorRelation?: StringNullableFilter<"Testimonial"> | string | null
    authorEmail?: StringNullableFilter<"Testimonial"> | string | null
    content?: StringFilter<"Testimonial"> | string
    rating?: IntNullableFilter<"Testimonial"> | number | null
    isApproved?: BoolFilter<"Testimonial"> | boolean
    createdAt?: DateTimeFilter<"Testimonial"> | Date | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
  }, "id">

  export type TestimonialOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrder
    authorName?: SortOrder
    authorRelation?: SortOrderInput | SortOrder
    authorEmail?: SortOrderInput | SortOrder
    content?: SortOrder
    rating?: SortOrderInput | SortOrder
    isApproved?: SortOrder
    createdAt?: SortOrder
    _count?: TestimonialCountOrderByAggregateInput
    _avg?: TestimonialAvgOrderByAggregateInput
    _max?: TestimonialMaxOrderByAggregateInput
    _min?: TestimonialMinOrderByAggregateInput
    _sum?: TestimonialSumOrderByAggregateInput
  }

  export type TestimonialScalarWhereWithAggregatesInput = {
    AND?: TestimonialScalarWhereWithAggregatesInput | TestimonialScalarWhereWithAggregatesInput[]
    OR?: TestimonialScalarWhereWithAggregatesInput[]
    NOT?: TestimonialScalarWhereWithAggregatesInput | TestimonialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Testimonial"> | string
    profileId?: StringWithAggregatesFilter<"Testimonial"> | string
    authorName?: StringWithAggregatesFilter<"Testimonial"> | string
    authorRelation?: StringNullableWithAggregatesFilter<"Testimonial"> | string | null
    authorEmail?: StringNullableWithAggregatesFilter<"Testimonial"> | string | null
    content?: StringWithAggregatesFilter<"Testimonial"> | string
    rating?: IntNullableWithAggregatesFilter<"Testimonial"> | number | null
    isApproved?: BoolWithAggregatesFilter<"Testimonial"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Testimonial"> | Date | string
  }

  export type ActivityWhereInput = {
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    id?: StringFilter<"Activity"> | string
    userId?: StringFilter<"Activity"> | string
    type?: StringFilter<"Activity"> | string
    title?: StringFilter<"Activity"> | string
    description?: StringNullableFilter<"Activity"> | string | null
    metadata?: JsonNullableFilter<"Activity">
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ActivityOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    userId?: StringFilter<"Activity"> | string
    type?: StringFilter<"Activity"> | string
    title?: StringFilter<"Activity"> | string
    description?: StringNullableFilter<"Activity"> | string | null
    metadata?: JsonNullableFilter<"Activity">
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ActivityOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ActivityCountOrderByAggregateInput
    _max?: ActivityMaxOrderByAggregateInput
    _min?: ActivityMinOrderByAggregateInput
  }

  export type ActivityScalarWhereWithAggregatesInput = {
    AND?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    OR?: ActivityScalarWhereWithAggregatesInput[]
    NOT?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Activity"> | string
    userId?: StringWithAggregatesFilter<"Activity"> | string
    type?: StringWithAggregatesFilter<"Activity"> | string
    title?: StringWithAggregatesFilter<"Activity"> | string
    description?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Activity">
    createdAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
  }

  export type LeaderboardWhereInput = {
    AND?: LeaderboardWhereInput | LeaderboardWhereInput[]
    OR?: LeaderboardWhereInput[]
    NOT?: LeaderboardWhereInput | LeaderboardWhereInput[]
    id?: StringFilter<"Leaderboard"> | string
    userId?: StringFilter<"Leaderboard"> | string
    category?: StringFilter<"Leaderboard"> | string
    rank?: IntFilter<"Leaderboard"> | number
    score?: IntFilter<"Leaderboard"> | number
    period?: StringFilter<"Leaderboard"> | string
    periodStart?: DateTimeFilter<"Leaderboard"> | Date | string
    periodEnd?: DateTimeNullableFilter<"Leaderboard"> | Date | string | null
    createdAt?: DateTimeFilter<"Leaderboard"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type LeaderboardOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    category?: SortOrder
    rank?: SortOrder
    score?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LeaderboardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_category_period_periodStart?: LeaderboardUserIdCategoryPeriodPeriodStartCompoundUniqueInput
    AND?: LeaderboardWhereInput | LeaderboardWhereInput[]
    OR?: LeaderboardWhereInput[]
    NOT?: LeaderboardWhereInput | LeaderboardWhereInput[]
    userId?: StringFilter<"Leaderboard"> | string
    category?: StringFilter<"Leaderboard"> | string
    rank?: IntFilter<"Leaderboard"> | number
    score?: IntFilter<"Leaderboard"> | number
    period?: StringFilter<"Leaderboard"> | string
    periodStart?: DateTimeFilter<"Leaderboard"> | Date | string
    periodEnd?: DateTimeNullableFilter<"Leaderboard"> | Date | string | null
    createdAt?: DateTimeFilter<"Leaderboard"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_category_period_periodStart">

  export type LeaderboardOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    category?: SortOrder
    rank?: SortOrder
    score?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LeaderboardCountOrderByAggregateInput
    _avg?: LeaderboardAvgOrderByAggregateInput
    _max?: LeaderboardMaxOrderByAggregateInput
    _min?: LeaderboardMinOrderByAggregateInput
    _sum?: LeaderboardSumOrderByAggregateInput
  }

  export type LeaderboardScalarWhereWithAggregatesInput = {
    AND?: LeaderboardScalarWhereWithAggregatesInput | LeaderboardScalarWhereWithAggregatesInput[]
    OR?: LeaderboardScalarWhereWithAggregatesInput[]
    NOT?: LeaderboardScalarWhereWithAggregatesInput | LeaderboardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Leaderboard"> | string
    userId?: StringWithAggregatesFilter<"Leaderboard"> | string
    category?: StringWithAggregatesFilter<"Leaderboard"> | string
    rank?: IntWithAggregatesFilter<"Leaderboard"> | number
    score?: IntWithAggregatesFilter<"Leaderboard"> | number
    period?: StringWithAggregatesFilter<"Leaderboard"> | string
    periodStart?: DateTimeWithAggregatesFilter<"Leaderboard"> | Date | string
    periodEnd?: DateTimeNullableWithAggregatesFilter<"Leaderboard"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Leaderboard"> | Date | string
  }

  export type WishlistWhereInput = {
    AND?: WishlistWhereInput | WishlistWhereInput[]
    OR?: WishlistWhereInput[]
    NOT?: WishlistWhereInput | WishlistWhereInput[]
    id?: StringFilter<"Wishlist"> | string
    userId?: StringFilter<"Wishlist"> | string
    criteria?: JsonFilter<"Wishlist">
    isActive?: BoolFilter<"Wishlist"> | boolean
    createdAt?: DateTimeFilter<"Wishlist"> | Date | string
    updatedAt?: DateTimeFilter<"Wishlist"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type WishlistOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    criteria?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type WishlistWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WishlistWhereInput | WishlistWhereInput[]
    OR?: WishlistWhereInput[]
    NOT?: WishlistWhereInput | WishlistWhereInput[]
    userId?: StringFilter<"Wishlist"> | string
    criteria?: JsonFilter<"Wishlist">
    isActive?: BoolFilter<"Wishlist"> | boolean
    createdAt?: DateTimeFilter<"Wishlist"> | Date | string
    updatedAt?: DateTimeFilter<"Wishlist"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type WishlistOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    criteria?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WishlistCountOrderByAggregateInput
    _max?: WishlistMaxOrderByAggregateInput
    _min?: WishlistMinOrderByAggregateInput
  }

  export type WishlistScalarWhereWithAggregatesInput = {
    AND?: WishlistScalarWhereWithAggregatesInput | WishlistScalarWhereWithAggregatesInput[]
    OR?: WishlistScalarWhereWithAggregatesInput[]
    NOT?: WishlistScalarWhereWithAggregatesInput | WishlistScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Wishlist"> | string
    userId?: StringWithAggregatesFilter<"Wishlist"> | string
    criteria?: JsonWithAggregatesFilter<"Wishlist">
    isActive?: BoolWithAggregatesFilter<"Wishlist"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Wishlist"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Wishlist"> | Date | string
  }

  export type ProfileExportWhereInput = {
    AND?: ProfileExportWhereInput | ProfileExportWhereInput[]
    OR?: ProfileExportWhereInput[]
    NOT?: ProfileExportWhereInput | ProfileExportWhereInput[]
    id?: StringFilter<"ProfileExport"> | string
    userId?: StringFilter<"ProfileExport"> | string
    format?: StringFilter<"ProfileExport"> | string
    url?: StringFilter<"ProfileExport"> | string
    expiresAt?: DateTimeFilter<"ProfileExport"> | Date | string
    createdAt?: DateTimeFilter<"ProfileExport"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ProfileExportOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    format?: SortOrder
    url?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ProfileExportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProfileExportWhereInput | ProfileExportWhereInput[]
    OR?: ProfileExportWhereInput[]
    NOT?: ProfileExportWhereInput | ProfileExportWhereInput[]
    userId?: StringFilter<"ProfileExport"> | string
    format?: StringFilter<"ProfileExport"> | string
    url?: StringFilter<"ProfileExport"> | string
    expiresAt?: DateTimeFilter<"ProfileExport"> | Date | string
    createdAt?: DateTimeFilter<"ProfileExport"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ProfileExportOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    format?: SortOrder
    url?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: ProfileExportCountOrderByAggregateInput
    _max?: ProfileExportMaxOrderByAggregateInput
    _min?: ProfileExportMinOrderByAggregateInput
  }

  export type ProfileExportScalarWhereWithAggregatesInput = {
    AND?: ProfileExportScalarWhereWithAggregatesInput | ProfileExportScalarWhereWithAggregatesInput[]
    OR?: ProfileExportScalarWhereWithAggregatesInput[]
    NOT?: ProfileExportScalarWhereWithAggregatesInput | ProfileExportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProfileExport"> | string
    userId?: StringWithAggregatesFilter<"ProfileExport"> | string
    format?: StringWithAggregatesFilter<"ProfileExport"> | string
    url?: StringWithAggregatesFilter<"ProfileExport"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"ProfileExport"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"ProfileExport"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    interests?: InterestCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    chats2?: ChatCreateNestedManyWithoutUser2Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SessionCreateInput = {
    id?: string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateInput = {
    id?: string
    status?: $Enums.ProfileStatus
    firstName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    dateOfBirth?: Date | string | null
    height?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    religion?: string | null
    caste?: string | null
    motherTongue?: string | null
    manglik?: boolean | null
    gothra?: string | null
    country?: string | null
    state?: string | null
    city?: string | null
    citizenship?: string | null
    education?: string | null
    college?: string | null
    occupation?: string | null
    income?: number | null
    incomeCurrency?: string | null
    fatherOccupation?: string | null
    motherOccupation?: string | null
    siblings?: number | null
    familyType?: $Enums.FamilyType | null
    diet?: $Enums.Diet | null
    smoking?: boolean | null
    drinking?: boolean | null
    hobbies?: string | null
    partnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    videoIntroUrl?: string | null
    biodataUrl?: string | null
    aboutMe?: string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    privacySettings?: NullableJsonNullValueInput | InputJsonValue
    isHiddenFromSearch?: boolean
    isAnonymousViewing?: boolean
    contactPrivacyLevel?: string | null
    photoPrivacyLevel?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    trustScore?: number
    completenessScore?: number
    isHighlighted?: boolean
    slug?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: PhotoCreateNestedManyWithoutProfileInput
    profileViews?: ProfileViewCreateNestedManyWithoutProfileInput
    shortlistedBy?: ShortlistCreateNestedManyWithoutProfileInput
    horoscope?: HoroscopeCreateNestedOneWithoutProfileInput
    comparisons?: ProfileComparisonCreateNestedManyWithoutProfileInput
    testimonials?: TestimonialCreateNestedManyWithoutProfileInput
    user: UserCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateInput = {
    id?: string
    userId: string
    status?: $Enums.ProfileStatus
    firstName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    dateOfBirth?: Date | string | null
    height?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    religion?: string | null
    caste?: string | null
    motherTongue?: string | null
    manglik?: boolean | null
    gothra?: string | null
    country?: string | null
    state?: string | null
    city?: string | null
    citizenship?: string | null
    education?: string | null
    college?: string | null
    occupation?: string | null
    income?: number | null
    incomeCurrency?: string | null
    fatherOccupation?: string | null
    motherOccupation?: string | null
    siblings?: number | null
    familyType?: $Enums.FamilyType | null
    diet?: $Enums.Diet | null
    smoking?: boolean | null
    drinking?: boolean | null
    hobbies?: string | null
    partnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    videoIntroUrl?: string | null
    biodataUrl?: string | null
    aboutMe?: string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    privacySettings?: NullableJsonNullValueInput | InputJsonValue
    isHiddenFromSearch?: boolean
    isAnonymousViewing?: boolean
    contactPrivacyLevel?: string | null
    photoPrivacyLevel?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    trustScore?: number
    completenessScore?: number
    isHighlighted?: boolean
    slug?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: PhotoUncheckedCreateNestedManyWithoutProfileInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutProfileInput
    shortlistedBy?: ShortlistUncheckedCreateNestedManyWithoutProfileInput
    horoscope?: HoroscopeUncheckedCreateNestedOneWithoutProfileInput
    comparisons?: ProfileComparisonUncheckedCreateNestedManyWithoutProfileInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    caste?: NullableStringFieldUpdateOperationsInput | string | null
    motherTongue?: NullableStringFieldUpdateOperationsInput | string | null
    manglik?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gothra?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableIntFieldUpdateOperationsInput | number | null
    incomeCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    fatherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    motherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    siblings?: NullableIntFieldUpdateOperationsInput | number | null
    familyType?: NullableEnumFamilyTypeFieldUpdateOperationsInput | $Enums.FamilyType | null
    diet?: NullableEnumDietFieldUpdateOperationsInput | $Enums.Diet | null
    smoking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    drinking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hobbies?: NullableStringFieldUpdateOperationsInput | string | null
    partnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    videoIntroUrl?: NullableStringFieldUpdateOperationsInput | string | null
    biodataUrl?: NullableStringFieldUpdateOperationsInput | string | null
    aboutMe?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    privacySettings?: NullableJsonNullValueInput | InputJsonValue
    isHiddenFromSearch?: BoolFieldUpdateOperationsInput | boolean
    isAnonymousViewing?: BoolFieldUpdateOperationsInput | boolean
    contactPrivacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    photoPrivacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    completenessScore?: IntFieldUpdateOperationsInput | number
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: PhotoUpdateManyWithoutProfileNestedInput
    profileViews?: ProfileViewUpdateManyWithoutProfileNestedInput
    shortlistedBy?: ShortlistUpdateManyWithoutProfileNestedInput
    horoscope?: HoroscopeUpdateOneWithoutProfileNestedInput
    comparisons?: ProfileComparisonUpdateManyWithoutProfileNestedInput
    testimonials?: TestimonialUpdateManyWithoutProfileNestedInput
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    caste?: NullableStringFieldUpdateOperationsInput | string | null
    motherTongue?: NullableStringFieldUpdateOperationsInput | string | null
    manglik?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gothra?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableIntFieldUpdateOperationsInput | number | null
    incomeCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    fatherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    motherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    siblings?: NullableIntFieldUpdateOperationsInput | number | null
    familyType?: NullableEnumFamilyTypeFieldUpdateOperationsInput | $Enums.FamilyType | null
    diet?: NullableEnumDietFieldUpdateOperationsInput | $Enums.Diet | null
    smoking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    drinking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hobbies?: NullableStringFieldUpdateOperationsInput | string | null
    partnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    videoIntroUrl?: NullableStringFieldUpdateOperationsInput | string | null
    biodataUrl?: NullableStringFieldUpdateOperationsInput | string | null
    aboutMe?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    privacySettings?: NullableJsonNullValueInput | InputJsonValue
    isHiddenFromSearch?: BoolFieldUpdateOperationsInput | boolean
    isAnonymousViewing?: BoolFieldUpdateOperationsInput | boolean
    contactPrivacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    photoPrivacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    completenessScore?: IntFieldUpdateOperationsInput | number
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: PhotoUncheckedUpdateManyWithoutProfileNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutProfileNestedInput
    shortlistedBy?: ShortlistUncheckedUpdateManyWithoutProfileNestedInput
    horoscope?: HoroscopeUncheckedUpdateOneWithoutProfileNestedInput
    comparisons?: ProfileComparisonUncheckedUpdateManyWithoutProfileNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileCreateManyInput = {
    id?: string
    userId: string
    status?: $Enums.ProfileStatus
    firstName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    dateOfBirth?: Date | string | null
    height?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    religion?: string | null
    caste?: string | null
    motherTongue?: string | null
    manglik?: boolean | null
    gothra?: string | null
    country?: string | null
    state?: string | null
    city?: string | null
    citizenship?: string | null
    education?: string | null
    college?: string | null
    occupation?: string | null
    income?: number | null
    incomeCurrency?: string | null
    fatherOccupation?: string | null
    motherOccupation?: string | null
    siblings?: number | null
    familyType?: $Enums.FamilyType | null
    diet?: $Enums.Diet | null
    smoking?: boolean | null
    drinking?: boolean | null
    hobbies?: string | null
    partnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    videoIntroUrl?: string | null
    biodataUrl?: string | null
    aboutMe?: string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    privacySettings?: NullableJsonNullValueInput | InputJsonValue
    isHiddenFromSearch?: boolean
    isAnonymousViewing?: boolean
    contactPrivacyLevel?: string | null
    photoPrivacyLevel?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    trustScore?: number
    completenessScore?: number
    isHighlighted?: boolean
    slug?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    caste?: NullableStringFieldUpdateOperationsInput | string | null
    motherTongue?: NullableStringFieldUpdateOperationsInput | string | null
    manglik?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gothra?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableIntFieldUpdateOperationsInput | number | null
    incomeCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    fatherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    motherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    siblings?: NullableIntFieldUpdateOperationsInput | number | null
    familyType?: NullableEnumFamilyTypeFieldUpdateOperationsInput | $Enums.FamilyType | null
    diet?: NullableEnumDietFieldUpdateOperationsInput | $Enums.Diet | null
    smoking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    drinking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hobbies?: NullableStringFieldUpdateOperationsInput | string | null
    partnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    videoIntroUrl?: NullableStringFieldUpdateOperationsInput | string | null
    biodataUrl?: NullableStringFieldUpdateOperationsInput | string | null
    aboutMe?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    privacySettings?: NullableJsonNullValueInput | InputJsonValue
    isHiddenFromSearch?: BoolFieldUpdateOperationsInput | boolean
    isAnonymousViewing?: BoolFieldUpdateOperationsInput | boolean
    contactPrivacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    photoPrivacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    completenessScore?: IntFieldUpdateOperationsInput | number
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    caste?: NullableStringFieldUpdateOperationsInput | string | null
    motherTongue?: NullableStringFieldUpdateOperationsInput | string | null
    manglik?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gothra?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableIntFieldUpdateOperationsInput | number | null
    incomeCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    fatherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    motherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    siblings?: NullableIntFieldUpdateOperationsInput | number | null
    familyType?: NullableEnumFamilyTypeFieldUpdateOperationsInput | $Enums.FamilyType | null
    diet?: NullableEnumDietFieldUpdateOperationsInput | $Enums.Diet | null
    smoking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    drinking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hobbies?: NullableStringFieldUpdateOperationsInput | string | null
    partnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    videoIntroUrl?: NullableStringFieldUpdateOperationsInput | string | null
    biodataUrl?: NullableStringFieldUpdateOperationsInput | string | null
    aboutMe?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    privacySettings?: NullableJsonNullValueInput | InputJsonValue
    isHiddenFromSearch?: BoolFieldUpdateOperationsInput | boolean
    isAnonymousViewing?: BoolFieldUpdateOperationsInput | boolean
    contactPrivacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    photoPrivacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    completenessScore?: IntFieldUpdateOperationsInput | number
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhotoCreateInput = {
    id?: string
    url: string
    cloudinaryId?: string | null
    isPrimary?: boolean
    isBlurred?: boolean
    isApproved?: boolean
    order?: number
    albumName?: string | null
    caption?: string | null
    createdAt?: Date | string
    profile: ProfileCreateNestedOneWithoutPhotosInput
  }

  export type PhotoUncheckedCreateInput = {
    id?: string
    profileId: string
    url: string
    cloudinaryId?: string | null
    isPrimary?: boolean
    isBlurred?: boolean
    isApproved?: boolean
    order?: number
    albumName?: string | null
    caption?: string | null
    createdAt?: Date | string
  }

  export type PhotoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    cloudinaryId?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    isBlurred?: BoolFieldUpdateOperationsInput | boolean
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    albumName?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutPhotosNestedInput
  }

  export type PhotoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    cloudinaryId?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    isBlurred?: BoolFieldUpdateOperationsInput | boolean
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    albumName?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhotoCreateManyInput = {
    id?: string
    profileId: string
    url: string
    cloudinaryId?: string | null
    isPrimary?: boolean
    isBlurred?: boolean
    isApproved?: boolean
    order?: number
    albumName?: string | null
    caption?: string | null
    createdAt?: Date | string
  }

  export type PhotoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    cloudinaryId?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    isBlurred?: BoolFieldUpdateOperationsInput | boolean
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    albumName?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhotoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    cloudinaryId?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    isBlurred?: BoolFieldUpdateOperationsInput | boolean
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    albumName?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateInput = {
    id?: string
    userId: string
    idType: string
    idNumber?: string | null
    idPhotoUrl?: string | null
    selfieUrl?: string | null
    status?: string
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUncheckedCreateInput = {
    id?: string
    userId: string
    idType: string
    idNumber?: string | null
    idPhotoUrl?: string | null
    selfieUrl?: string | null
    status?: string
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    idType?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    selfieUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    idType?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    selfieUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateManyInput = {
    id?: string
    userId: string
    idType: string
    idNumber?: string | null
    idPhotoUrl?: string | null
    selfieUrl?: string | null
    status?: string
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    idType?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    selfieUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    idType?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    selfieUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterestCreateInput = {
    id?: string
    status?: $Enums.InterestStatus
    message?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fromUser: UserCreateNestedOneWithoutInterestsInput
    toUser: UserCreateNestedOneWithoutReceivedInterestsInput
  }

  export type InterestUncheckedCreateInput = {
    id?: string
    fromUserId: string
    toUserId: string
    status?: $Enums.InterestStatus
    message?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInterestStatusFieldUpdateOperationsInput | $Enums.InterestStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromUser?: UserUpdateOneRequiredWithoutInterestsNestedInput
    toUser?: UserUpdateOneRequiredWithoutReceivedInterestsNestedInput
  }

  export type InterestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromUserId?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    status?: EnumInterestStatusFieldUpdateOperationsInput | $Enums.InterestStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterestCreateManyInput = {
    id?: string
    fromUserId: string
    toUserId: string
    status?: $Enums.InterestStatus
    message?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInterestStatusFieldUpdateOperationsInput | $Enums.InterestStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromUserId?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    status?: EnumInterestStatusFieldUpdateOperationsInput | $Enums.InterestStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatCreateInput = {
    id?: string
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user1: UserCreateNestedOneWithoutChatsInput
    user2: UserCreateNestedOneWithoutChats2Input
    messages?: MessageCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateInput = {
    id?: string
    user1Id: string
    user2Id: string
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user1?: UserUpdateOneRequiredWithoutChatsNestedInput
    user2?: UserUpdateOneRequiredWithoutChats2NestedInput
    messages?: MessageUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user1Id?: StringFieldUpdateOperationsInput | string
    user2Id?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type ChatCreateManyInput = {
    id?: string
    user1Id: string
    user2Id: string
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user1Id?: StringFieldUpdateOperationsInput | string
    user2Id?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    content?: string | null
    imageUrl?: string | null
    videoUrl?: string | null
    audioUrl?: string | null
    fileUrl?: string | null
    fileName?: string | null
    messageType?: string
    isRead?: boolean
    isDeleted?: boolean
    deletedBy?: MessageCreatedeletedByInput | string[]
    isReported?: boolean
    createdAt?: Date | string
    chat: ChatCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    chatId: string
    senderId: string
    content?: string | null
    imageUrl?: string | null
    videoUrl?: string | null
    audioUrl?: string | null
    fileUrl?: string | null
    fileName?: string | null
    messageType?: string
    isRead?: boolean
    isDeleted?: boolean
    deletedBy?: MessageCreatedeletedByInput | string[]
    isReported?: boolean
    createdAt?: Date | string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedBy?: MessageUpdatedeletedByInput | string[]
    isReported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chat?: ChatUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedBy?: MessageUpdatedeletedByInput | string[]
    isReported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: string
    chatId: string
    senderId: string
    content?: string | null
    imageUrl?: string | null
    videoUrl?: string | null
    audioUrl?: string | null
    fileUrl?: string | null
    fileName?: string | null
    messageType?: string
    isRead?: boolean
    isDeleted?: boolean
    deletedBy?: MessageCreatedeletedByInput | string[]
    isReported?: boolean
    createdAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedBy?: MessageUpdatedeletedByInput | string[]
    isReported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedBy?: MessageUpdatedeletedByInput | string[]
    isReported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileViewCreateInput = {
    id?: string
    createdAt?: Date | string
    profile: ProfileCreateNestedOneWithoutProfileViewsInput
    viewedBy: UserCreateNestedOneWithoutProfileViewsInput
  }

  export type ProfileViewUncheckedCreateInput = {
    id?: string
    profileId: string
    viewedById: string
    createdAt?: Date | string
  }

  export type ProfileViewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutProfileViewsNestedInput
    viewedBy?: UserUpdateOneRequiredWithoutProfileViewsNestedInput
  }

  export type ProfileViewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    viewedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileViewCreateManyInput = {
    id?: string
    profileId: string
    viewedById: string
    createdAt?: Date | string
  }

  export type ProfileViewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileViewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    viewedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactViewCreateInput = {
    id?: string
    profileId: string
    viewedById: string
    createdAt?: Date | string
    subscription: SubscriptionCreateNestedOneWithoutContactViewsInput
  }

  export type ContactViewUncheckedCreateInput = {
    id?: string
    subscriptionId: string
    profileId: string
    viewedById: string
    createdAt?: Date | string
  }

  export type ContactViewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    viewedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneRequiredWithoutContactViewsNestedInput
  }

  export type ContactViewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    viewedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactViewCreateManyInput = {
    id?: string
    subscriptionId: string
    profileId: string
    viewedById: string
    createdAt?: Date | string
  }

  export type ContactViewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    viewedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactViewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    viewedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    id?: string
    plan: $Enums.SubscriptionPlan
    razorpaySubscriptionId?: string | null
    razorpayPlanId?: string | null
    status?: string
    startDate: Date | string
    endDate: Date | string
    contactViewsUsed?: number
    contactViewsLimit?: number | null
    profileBoostCredits?: number
    verifiedBadgeIncluded?: boolean
    horoscopeReportsIncluded?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionsInput
    contactViews?: ContactViewCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    userId: string
    plan: $Enums.SubscriptionPlan
    razorpaySubscriptionId?: string | null
    razorpayPlanId?: string | null
    status?: string
    startDate: Date | string
    endDate: Date | string
    contactViewsUsed?: number
    contactViewsLimit?: number | null
    profileBoostCredits?: number
    verifiedBadgeIncluded?: boolean
    horoscopeReportsIncluded?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    contactViews?: ContactViewUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    razorpaySubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contactViewsUsed?: IntFieldUpdateOperationsInput | number
    contactViewsLimit?: NullableIntFieldUpdateOperationsInput | number | null
    profileBoostCredits?: IntFieldUpdateOperationsInput | number
    verifiedBadgeIncluded?: BoolFieldUpdateOperationsInput | boolean
    horoscopeReportsIncluded?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionsNestedInput
    contactViews?: ContactViewUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    razorpaySubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contactViewsUsed?: IntFieldUpdateOperationsInput | number
    contactViewsLimit?: NullableIntFieldUpdateOperationsInput | number | null
    profileBoostCredits?: IntFieldUpdateOperationsInput | number
    verifiedBadgeIncluded?: BoolFieldUpdateOperationsInput | boolean
    horoscopeReportsIncluded?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactViews?: ContactViewUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    userId: string
    plan: $Enums.SubscriptionPlan
    razorpaySubscriptionId?: string | null
    razorpayPlanId?: string | null
    status?: string
    startDate: Date | string
    endDate: Date | string
    contactViewsUsed?: number
    contactViewsLimit?: number | null
    profileBoostCredits?: number
    verifiedBadgeIncluded?: boolean
    horoscopeReportsIncluded?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    razorpaySubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contactViewsUsed?: IntFieldUpdateOperationsInput | number
    contactViewsLimit?: NullableIntFieldUpdateOperationsInput | number | null
    profileBoostCredits?: IntFieldUpdateOperationsInput | number
    verifiedBadgeIncluded?: BoolFieldUpdateOperationsInput | boolean
    horoscopeReportsIncluded?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    razorpaySubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contactViewsUsed?: IntFieldUpdateOperationsInput | number
    contactViewsLimit?: NullableIntFieldUpdateOperationsInput | number | null
    profileBoostCredits?: IntFieldUpdateOperationsInput | number
    verifiedBadgeIncluded?: BoolFieldUpdateOperationsInput | boolean
    horoscopeReportsIncluded?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    razorpayOrderId?: string | null
    razorpayPaymentId?: string | null
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    type: string
    addOnType?: $Enums.AddOnType | null
    subscriptionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentsInput
    addOns?: AddOnCreateNestedManyWithoutPaymentInput
    services?: ServiceCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    userId: string
    razorpayOrderId?: string | null
    razorpayPaymentId?: string | null
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    type: string
    addOnType?: $Enums.AddOnType | null
    subscriptionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    addOns?: AddOnUncheckedCreateNestedManyWithoutPaymentInput
    services?: ServiceUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    type?: StringFieldUpdateOperationsInput | string
    addOnType?: NullableEnumAddOnTypeFieldUpdateOperationsInput | $Enums.AddOnType | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
    addOns?: AddOnUpdateManyWithoutPaymentNestedInput
    services?: ServiceUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    type?: StringFieldUpdateOperationsInput | string
    addOnType?: NullableEnumAddOnTypeFieldUpdateOperationsInput | $Enums.AddOnType | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addOns?: AddOnUncheckedUpdateManyWithoutPaymentNestedInput
    services?: ServiceUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentCreateManyInput = {
    id?: string
    userId: string
    razorpayOrderId?: string | null
    razorpayPaymentId?: string | null
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    type: string
    addOnType?: $Enums.AddOnType | null
    subscriptionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    type?: StringFieldUpdateOperationsInput | string
    addOnType?: NullableEnumAddOnTypeFieldUpdateOperationsInput | $Enums.AddOnType | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    type?: StringFieldUpdateOperationsInput | string
    addOnType?: NullableEnumAddOnTypeFieldUpdateOperationsInput | $Enums.AddOnType | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddOnCreateInput = {
    id?: string
    userId: string
    type: $Enums.AddOnType
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    payment?: PaymentCreateNestedOneWithoutAddOnsInput
  }

  export type AddOnUncheckedCreateInput = {
    id?: string
    userId: string
    type: $Enums.AddOnType
    paymentId?: string | null
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type AddOnUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumAddOnTypeFieldUpdateOperationsInput | $Enums.AddOnType
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUpdateOneWithoutAddOnsNestedInput
  }

  export type AddOnUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumAddOnTypeFieldUpdateOperationsInput | $Enums.AddOnType
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddOnCreateManyInput = {
    id?: string
    userId: string
    type: $Enums.AddOnType
    paymentId?: string | null
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type AddOnUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumAddOnTypeFieldUpdateOperationsInput | $Enums.AddOnType
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddOnUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumAddOnTypeFieldUpdateOperationsInput | $Enums.AddOnType
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateInput = {
    id?: string
    type: $Enums.ServiceType
    status?: $Enums.ServiceStatus
    amount: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    notes?: string | null
    rating?: number | null
    review?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutServicesInput
    payment?: PaymentCreateNestedOneWithoutServicesInput
    bookings?: ServiceBookingCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    userId: string
    type: $Enums.ServiceType
    status?: $Enums.ServiceStatus
    paymentId?: string | null
    amount: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    notes?: string | null
    rating?: number | null
    review?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: ServiceBookingUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    amount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutServicesNestedInput
    payment?: PaymentUpdateOneWithoutServicesNestedInput
    bookings?: ServiceBookingUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: ServiceBookingUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: string
    userId: string
    type: $Enums.ServiceType
    status?: $Enums.ServiceStatus
    paymentId?: string | null
    amount: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    notes?: string | null
    rating?: number | null
    review?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    amount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceProviderCreateInput = {
    id?: string
    name: string
    email: string
    mobile: string
    serviceType: $Enums.ServiceType
    expertise?: string | null
    rating?: number
    totalBookings?: number
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: ServiceBookingCreateNestedManyWithoutProviderInput
  }

  export type ServiceProviderUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    mobile: string
    serviceType: $Enums.ServiceType
    expertise?: string | null
    rating?: number
    totalBookings?: number
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: ServiceBookingUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ServiceProviderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    totalBookings?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: ServiceBookingUpdateManyWithoutProviderNestedInput
  }

  export type ServiceProviderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    totalBookings?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: ServiceBookingUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type ServiceProviderCreateManyInput = {
    id?: string
    name: string
    email: string
    mobile: string
    serviceType: $Enums.ServiceType
    expertise?: string | null
    rating?: number
    totalBookings?: number
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceProviderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    totalBookings?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceProviderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    totalBookings?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceBookingCreateInput = {
    id?: string
    scheduledAt?: Date | string | null
    duration?: number | null
    status?: $Enums.ServiceStatus
    meetingLink?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service: ServiceCreateNestedOneWithoutBookingsInput
    provider?: ServiceProviderCreateNestedOneWithoutBookingsInput
    user: UserCreateNestedOneWithoutServiceBookingsInput
  }

  export type ServiceBookingUncheckedCreateInput = {
    id?: string
    serviceId: string
    providerId?: string | null
    userId: string
    scheduledAt?: Date | string | null
    duration?: number | null
    status?: $Enums.ServiceStatus
    meetingLink?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceBookingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutBookingsNestedInput
    provider?: ServiceProviderUpdateOneWithoutBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutServiceBookingsNestedInput
  }

  export type ServiceBookingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceBookingCreateManyInput = {
    id?: string
    serviceId: string
    providerId?: string | null
    userId: string
    scheduledAt?: Date | string | null
    duration?: number | null
    status?: $Enums.ServiceStatus
    meetingLink?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceBookingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceBookingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: string
    title: string
    message: string
    isRead?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    title: string
    message: string
    isRead?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    type: string
    title: string
    message: string
    isRead?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedSearchCreateInput = {
    id?: string
    userId: string
    name: string
    filters: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SavedSearchUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    filters: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SavedSearchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    filters?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedSearchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    filters?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedSearchCreateManyInput = {
    id?: string
    userId: string
    name: string
    filters: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SavedSearchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    filters?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedSearchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    filters?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OTPCreateInput = {
    id?: string
    identifier: string
    code: string
    type: string
    expiresAt: Date | string
    isUsed?: boolean
    createdAt?: Date | string
  }

  export type OTPUncheckedCreateInput = {
    id?: string
    identifier: string
    code: string
    type: string
    expiresAt: Date | string
    isUsed?: boolean
    createdAt?: Date | string
  }

  export type OTPUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OTPUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OTPCreateManyInput = {
    id?: string
    identifier: string
    code: string
    type: string
    expiresAt: Date | string
    isUsed?: boolean
    createdAt?: Date | string
  }

  export type OTPUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OTPUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCreateManyInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateInput = {
    id?: string
    reporterId: string
    reportedUserId: string
    type: string
    reason: string
    description?: string | null
    status?: string
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ReportUncheckedCreateInput = {
    id?: string
    reporterId: string
    reportedUserId: string
    type: string
    reason: string
    description?: string | null
    status?: string
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reporterId?: StringFieldUpdateOperationsInput | string
    reportedUserId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reporterId?: StringFieldUpdateOperationsInput | string
    reportedUserId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateManyInput = {
    id?: string
    reporterId: string
    reportedUserId: string
    type: string
    reason: string
    description?: string | null
    status?: string
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reporterId?: StringFieldUpdateOperationsInput | string
    reportedUserId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reporterId?: StringFieldUpdateOperationsInput | string
    reportedUserId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShortlistCreateInput = {
    id?: string
    folderName?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutShortlistsInput
    profile: ProfileCreateNestedOneWithoutShortlistedByInput
  }

  export type ShortlistUncheckedCreateInput = {
    id?: string
    userId: string
    profileId: string
    folderName?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShortlistUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    folderName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutShortlistsNestedInput
    profile?: ProfileUpdateOneRequiredWithoutShortlistedByNestedInput
  }

  export type ShortlistUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    folderName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShortlistCreateManyInput = {
    id?: string
    userId: string
    profileId: string
    folderName?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShortlistUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    folderName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShortlistUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    folderName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockedUserCreateInput = {
    id?: string
    reason?: string | null
    createdAt?: Date | string
    blocker: UserCreateNestedOneWithoutBlockedUsersInput
    blocked: UserCreateNestedOneWithoutBlockedByInput
  }

  export type BlockedUserUncheckedCreateInput = {
    id?: string
    blockerId: string
    blockedId: string
    reason?: string | null
    createdAt?: Date | string
  }

  export type BlockedUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocker?: UserUpdateOneRequiredWithoutBlockedUsersNestedInput
    blocked?: UserUpdateOneRequiredWithoutBlockedByNestedInput
  }

  export type BlockedUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockerId?: StringFieldUpdateOperationsInput | string
    blockedId?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockedUserCreateManyInput = {
    id?: string
    blockerId: string
    blockedId: string
    reason?: string | null
    createdAt?: Date | string
  }

  export type BlockedUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockedUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockerId?: StringFieldUpdateOperationsInput | string
    blockedId?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HoroscopeCreateInput = {
    id?: string
    horoscopeUrl?: string | null
    birthTime?: string | null
    birthPlace?: string | null
    rashi?: string | null
    nakshatra?: string | null
    mangalDosha?: boolean | null
    horoscopeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutHoroscopesInput
    profile: ProfileCreateNestedOneWithoutHoroscopeInput
    matches1?: HoroscopeMatchCreateNestedManyWithoutHoroscope1Input
    matches2?: HoroscopeMatchCreateNestedManyWithoutHoroscope2Input
  }

  export type HoroscopeUncheckedCreateInput = {
    id?: string
    userId: string
    profileId: string
    horoscopeUrl?: string | null
    birthTime?: string | null
    birthPlace?: string | null
    rashi?: string | null
    nakshatra?: string | null
    mangalDosha?: boolean | null
    horoscopeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    matches1?: HoroscopeMatchUncheckedCreateNestedManyWithoutHoroscope1Input
    matches2?: HoroscopeMatchUncheckedCreateNestedManyWithoutHoroscope2Input
  }

  export type HoroscopeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    horoscopeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    birthTime?: NullableStringFieldUpdateOperationsInput | string | null
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    rashi?: NullableStringFieldUpdateOperationsInput | string | null
    nakshatra?: NullableStringFieldUpdateOperationsInput | string | null
    mangalDosha?: NullableBoolFieldUpdateOperationsInput | boolean | null
    horoscopeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHoroscopesNestedInput
    profile?: ProfileUpdateOneRequiredWithoutHoroscopeNestedInput
    matches1?: HoroscopeMatchUpdateManyWithoutHoroscope1NestedInput
    matches2?: HoroscopeMatchUpdateManyWithoutHoroscope2NestedInput
  }

  export type HoroscopeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    horoscopeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    birthTime?: NullableStringFieldUpdateOperationsInput | string | null
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    rashi?: NullableStringFieldUpdateOperationsInput | string | null
    nakshatra?: NullableStringFieldUpdateOperationsInput | string | null
    mangalDosha?: NullableBoolFieldUpdateOperationsInput | boolean | null
    horoscopeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matches1?: HoroscopeMatchUncheckedUpdateManyWithoutHoroscope1NestedInput
    matches2?: HoroscopeMatchUncheckedUpdateManyWithoutHoroscope2NestedInput
  }

  export type HoroscopeCreateManyInput = {
    id?: string
    userId: string
    profileId: string
    horoscopeUrl?: string | null
    birthTime?: string | null
    birthPlace?: string | null
    rashi?: string | null
    nakshatra?: string | null
    mangalDosha?: boolean | null
    horoscopeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HoroscopeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    horoscopeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    birthTime?: NullableStringFieldUpdateOperationsInput | string | null
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    rashi?: NullableStringFieldUpdateOperationsInput | string | null
    nakshatra?: NullableStringFieldUpdateOperationsInput | string | null
    mangalDosha?: NullableBoolFieldUpdateOperationsInput | boolean | null
    horoscopeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HoroscopeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    horoscopeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    birthTime?: NullableStringFieldUpdateOperationsInput | string | null
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    rashi?: NullableStringFieldUpdateOperationsInput | string | null
    nakshatra?: NullableStringFieldUpdateOperationsInput | string | null
    mangalDosha?: NullableBoolFieldUpdateOperationsInput | boolean | null
    horoscopeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HoroscopeMatchCreateInput = {
    id?: string
    user1Id: string
    user2Id: string
    ashtakootScore?: number | null
    mangalDoshaMatch?: boolean | null
    overallScore?: number | null
    matchDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    horoscope1: HoroscopeCreateNestedOneWithoutMatches1Input
    horoscope2: HoroscopeCreateNestedOneWithoutMatches2Input
  }

  export type HoroscopeMatchUncheckedCreateInput = {
    id?: string
    user1Id: string
    user2Id: string
    horoscope1Id: string
    horoscope2Id: string
    ashtakootScore?: number | null
    mangalDoshaMatch?: boolean | null
    overallScore?: number | null
    matchDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type HoroscopeMatchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user1Id?: StringFieldUpdateOperationsInput | string
    user2Id?: StringFieldUpdateOperationsInput | string
    ashtakootScore?: NullableIntFieldUpdateOperationsInput | number | null
    mangalDoshaMatch?: NullableBoolFieldUpdateOperationsInput | boolean | null
    overallScore?: NullableIntFieldUpdateOperationsInput | number | null
    matchDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    horoscope1?: HoroscopeUpdateOneRequiredWithoutMatches1NestedInput
    horoscope2?: HoroscopeUpdateOneRequiredWithoutMatches2NestedInput
  }

  export type HoroscopeMatchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user1Id?: StringFieldUpdateOperationsInput | string
    user2Id?: StringFieldUpdateOperationsInput | string
    horoscope1Id?: StringFieldUpdateOperationsInput | string
    horoscope2Id?: StringFieldUpdateOperationsInput | string
    ashtakootScore?: NullableIntFieldUpdateOperationsInput | number | null
    mangalDoshaMatch?: NullableBoolFieldUpdateOperationsInput | boolean | null
    overallScore?: NullableIntFieldUpdateOperationsInput | number | null
    matchDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HoroscopeMatchCreateManyInput = {
    id?: string
    user1Id: string
    user2Id: string
    horoscope1Id: string
    horoscope2Id: string
    ashtakootScore?: number | null
    mangalDoshaMatch?: boolean | null
    overallScore?: number | null
    matchDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type HoroscopeMatchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user1Id?: StringFieldUpdateOperationsInput | string
    user2Id?: StringFieldUpdateOperationsInput | string
    ashtakootScore?: NullableIntFieldUpdateOperationsInput | number | null
    mangalDoshaMatch?: NullableBoolFieldUpdateOperationsInput | boolean | null
    overallScore?: NullableIntFieldUpdateOperationsInput | number | null
    matchDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HoroscopeMatchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user1Id?: StringFieldUpdateOperationsInput | string
    user2Id?: StringFieldUpdateOperationsInput | string
    horoscope1Id?: StringFieldUpdateOperationsInput | string
    horoscope2Id?: StringFieldUpdateOperationsInput | string
    ashtakootScore?: NullableIntFieldUpdateOperationsInput | number | null
    mangalDoshaMatch?: NullableBoolFieldUpdateOperationsInput | boolean | null
    overallScore?: NullableIntFieldUpdateOperationsInput | number | null
    matchDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuccessStoryCreateInput = {
    id?: string
    partnerId: string
    title: string
    story: string
    weddingDate?: Date | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: boolean
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSuccessStoriesInput
  }

  export type SuccessStoryUncheckedCreateInput = {
    id?: string
    userId: string
    partnerId: string
    title: string
    story: string
    weddingDate?: Date | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: boolean
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SuccessStoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    story?: StringFieldUpdateOperationsInput | string
    weddingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSuccessStoriesNestedInput
  }

  export type SuccessStoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    story?: StringFieldUpdateOperationsInput | string
    weddingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuccessStoryCreateManyInput = {
    id?: string
    userId: string
    partnerId: string
    title: string
    story: string
    weddingDate?: Date | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: boolean
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SuccessStoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    story?: StringFieldUpdateOperationsInput | string
    weddingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuccessStoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    story?: StringFieldUpdateOperationsInput | string
    weddingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyMemberCreateInput = {
    id?: string
    name: string
    relation: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    canViewMatches?: boolean
    canSendInterests?: boolean
    canChat?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFamilyMembersInput
  }

  export type FamilyMemberUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    relation: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    canViewMatches?: boolean
    canSendInterests?: boolean
    canChat?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FamilyMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    canViewMatches?: BoolFieldUpdateOperationsInput | boolean
    canSendInterests?: BoolFieldUpdateOperationsInput | boolean
    canChat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFamilyMembersNestedInput
  }

  export type FamilyMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    canViewMatches?: BoolFieldUpdateOperationsInput | boolean
    canSendInterests?: BoolFieldUpdateOperationsInput | boolean
    canChat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyMemberCreateManyInput = {
    id?: string
    userId: string
    name: string
    relation: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    canViewMatches?: boolean
    canSendInterests?: boolean
    canChat?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FamilyMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    canViewMatches?: BoolFieldUpdateOperationsInput | boolean
    canSendInterests?: BoolFieldUpdateOperationsInput | boolean
    canChat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    canViewMatches?: BoolFieldUpdateOperationsInput | boolean
    canSendInterests?: BoolFieldUpdateOperationsInput | boolean
    canChat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralCreateInput = {
    id?: string
    rewardAmount?: number | null
    status?: string
    completedAt?: Date | string | null
    createdAt?: Date | string
    referrer: UserCreateNestedOneWithoutReferralsInput
    referred: UserCreateNestedOneWithoutReferredByRefInput
  }

  export type ReferralUncheckedCreateInput = {
    id?: string
    referrerId: string
    referredId: string
    rewardAmount?: number | null
    status?: string
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ReferralUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rewardAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referrer?: UserUpdateOneRequiredWithoutReferralsNestedInput
    referred?: UserUpdateOneRequiredWithoutReferredByRefNestedInput
  }

  export type ReferralUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    referrerId?: StringFieldUpdateOperationsInput | string
    referredId?: StringFieldUpdateOperationsInput | string
    rewardAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralCreateManyInput = {
    id?: string
    referrerId: string
    referredId: string
    rewardAmount?: number | null
    status?: string
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ReferralUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rewardAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    referrerId?: StringFieldUpdateOperationsInput | string
    referredId?: StringFieldUpdateOperationsInput | string
    rewardAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementCreateInput = {
    id?: string
    type: string
    title: string
    description?: string | null
    points?: number
    icon?: string | null
    unlockedAt?: Date | string
    user: UserCreateNestedOneWithoutAchievementsInput
  }

  export type AchievementUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    title: string
    description?: string | null
    points?: number
    icon?: string | null
    unlockedAt?: Date | string
  }

  export type AchievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAchievementsNestedInput
  }

  export type AchievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementCreateManyInput = {
    id?: string
    userId: string
    type: string
    title: string
    description?: string | null
    points?: number
    icon?: string | null
    unlockedAt?: Date | string
  }

  export type AchievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    id?: string
    type: string
    name: string
    url: string
    expiryDate?: Date | string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    name: string
    url: string
    expiryDate?: Date | string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManyInput = {
    id?: string
    userId: string
    type: string
    name: string
    url: string
    expiryDate?: Date | string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCallCreateInput = {
    id?: string
    status?: string
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    cancelledAt?: Date | string | null
    duration?: number | null
    roomId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    caller: UserCreateNestedOneWithoutVideoCallsAsCallerInput
    participant: UserCreateNestedOneWithoutVideoCallsAsParticipantInput
  }

  export type VideoCallUncheckedCreateInput = {
    id?: string
    callerId: string
    participantId: string
    status?: string
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    cancelledAt?: Date | string | null
    duration?: number | null
    roomId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCallUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    caller?: UserUpdateOneRequiredWithoutVideoCallsAsCallerNestedInput
    participant?: UserUpdateOneRequiredWithoutVideoCallsAsParticipantNestedInput
  }

  export type VideoCallUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    callerId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCallCreateManyInput = {
    id?: string
    callerId: string
    participantId: string
    status?: string
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    cancelledAt?: Date | string | null
    duration?: number | null
    roomId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCallUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCallUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    callerId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileComparisonCreateInput = {
    id?: string
    userId: string
    comparisonData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    expiresAt?: Date | string | null
    profile: ProfileCreateNestedOneWithoutComparisonsInput
  }

  export type ProfileComparisonUncheckedCreateInput = {
    id?: string
    userId: string
    profileId: string
    comparisonData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type ProfileComparisonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    comparisonData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUpdateOneRequiredWithoutComparisonsNestedInput
  }

  export type ProfileComparisonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    comparisonData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProfileComparisonCreateManyInput = {
    id?: string
    userId: string
    profileId: string
    comparisonData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type ProfileComparisonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    comparisonData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProfileComparisonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    comparisonData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ForumPostCreateInput = {
    id?: string
    title: string
    content: string
    category?: string | null
    tags?: ForumPostCreatetagsInput | string[]
    likes?: number
    views?: number
    isPinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutForumPostsInput
    comments?: ForumCommentCreateNestedManyWithoutPostInput
  }

  export type ForumPostUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    content: string
    category?: string | null
    tags?: ForumPostCreatetagsInput | string[]
    likes?: number
    views?: number
    isPinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ForumCommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type ForumPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ForumPostUpdatetagsInput | string[]
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutForumPostsNestedInput
    comments?: ForumCommentUpdateManyWithoutPostNestedInput
  }

  export type ForumPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ForumPostUpdatetagsInput | string[]
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ForumCommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type ForumPostCreateManyInput = {
    id?: string
    userId: string
    title: string
    content: string
    category?: string | null
    tags?: ForumPostCreatetagsInput | string[]
    likes?: number
    views?: number
    isPinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ForumPostUpdatetagsInput | string[]
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ForumPostUpdatetagsInput | string[]
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumCommentCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutForumCommentsInput
    post: ForumPostCreateNestedOneWithoutCommentsInput
  }

  export type ForumCommentUncheckedCreateInput = {
    id?: string
    userId: string
    postId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutForumCommentsNestedInput
    post?: ForumPostUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type ForumCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumCommentCreateManyInput = {
    id?: string
    userId: string
    postId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityGroupCreateInput = {
    id?: string
    name: string
    description: string
    photoUrl?: string | null
    isPublic?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: GroupMemberCreateNestedManyWithoutGroupInput
  }

  export type CommunityGroupUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    photoUrl?: string | null
    isPublic?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: GroupMemberUncheckedCreateNestedManyWithoutGroupInput
  }

  export type CommunityGroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: GroupMemberUpdateManyWithoutGroupNestedInput
  }

  export type CommunityGroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: GroupMemberUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type CommunityGroupCreateManyInput = {
    id?: string
    name: string
    description: string
    photoUrl?: string | null
    isPublic?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityGroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityGroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberCreateInput = {
    id?: string
    role?: string
    joinedAt?: Date | string
    group: CommunityGroupCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutGroupMembersInput
  }

  export type GroupMemberUncheckedCreateInput = {
    id?: string
    groupId: string
    userId: string
    role?: string
    joinedAt?: Date | string
  }

  export type GroupMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: CommunityGroupUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutGroupMembersNestedInput
  }

  export type GroupMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberCreateManyInput = {
    id?: string
    groupId: string
    userId: string
    role?: string
    joinedAt?: Date | string
  }

  export type GroupMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityEventCreateInput = {
    id?: string
    title: string
    description: string
    eventDate: Date | string
    location: string
    photoUrl?: string | null
    maxParticipants?: number | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: EventParticipantCreateNestedManyWithoutEventInput
  }

  export type CommunityEventUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    eventDate: Date | string
    location: string
    photoUrl?: string | null
    maxParticipants?: number | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: EventParticipantUncheckedCreateNestedManyWithoutEventInput
  }

  export type CommunityEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: EventParticipantUpdateManyWithoutEventNestedInput
  }

  export type CommunityEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: EventParticipantUncheckedUpdateManyWithoutEventNestedInput
  }

  export type CommunityEventCreateManyInput = {
    id?: string
    title: string
    description: string
    eventDate: Date | string
    location: string
    photoUrl?: string | null
    maxParticipants?: number | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventParticipantCreateInput = {
    id?: string
    joinedAt?: Date | string
    event: CommunityEventCreateNestedOneWithoutParticipantsInput
    user: UserCreateNestedOneWithoutEventParticipantsInput
  }

  export type EventParticipantUncheckedCreateInput = {
    id?: string
    eventId: string
    userId: string
    joinedAt?: Date | string
  }

  export type EventParticipantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: CommunityEventUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserUpdateOneRequiredWithoutEventParticipantsNestedInput
  }

  export type EventParticipantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventParticipantCreateManyInput = {
    id?: string
    eventId: string
    userId: string
    joinedAt?: Date | string
  }

  export type EventParticipantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventParticipantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostCreateInput = {
    id?: string
    title: string
    content: string
    excerpt?: string | null
    photoUrl?: string | null
    tags?: BlogPostCreatetagsInput | string[]
    isPublished?: boolean
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBlogPostsInput
  }

  export type BlogPostUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    content: string
    excerpt?: string | null
    photoUrl?: string | null
    tags?: BlogPostCreatetagsInput | string[]
    isPublished?: boolean
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BlogPostUpdatetagsInput | string[]
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBlogPostsNestedInput
  }

  export type BlogPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BlogPostUpdatetagsInput | string[]
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostCreateManyInput = {
    id?: string
    userId: string
    title: string
    content: string
    excerpt?: string | null
    photoUrl?: string | null
    tags?: BlogPostCreatetagsInput | string[]
    isPublished?: boolean
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BlogPostUpdatetagsInput | string[]
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BlogPostUpdatetagsInput | string[]
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchScoreCreateInput = {
    id?: string
    overallScore: number
    religionScore?: number | null
    educationScore?: number | null
    lifestyleScore?: number | null
    locationScore?: number | null
    familyScore?: number | null
    matchReasons?: NullableJsonNullValueInput | InputJsonValue
    isReverseMatch?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMatchScoresInput
    matchedUser: UserCreateNestedOneWithoutMatchedByInput
  }

  export type MatchScoreUncheckedCreateInput = {
    id?: string
    userId: string
    matchedUserId: string
    overallScore: number
    religionScore?: number | null
    educationScore?: number | null
    lifestyleScore?: number | null
    locationScore?: number | null
    familyScore?: number | null
    matchReasons?: NullableJsonNullValueInput | InputJsonValue
    isReverseMatch?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchScoreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    religionScore?: NullableIntFieldUpdateOperationsInput | number | null
    educationScore?: NullableIntFieldUpdateOperationsInput | number | null
    lifestyleScore?: NullableIntFieldUpdateOperationsInput | number | null
    locationScore?: NullableIntFieldUpdateOperationsInput | number | null
    familyScore?: NullableIntFieldUpdateOperationsInput | number | null
    matchReasons?: NullableJsonNullValueInput | InputJsonValue
    isReverseMatch?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMatchScoresNestedInput
    matchedUser?: UserUpdateOneRequiredWithoutMatchedByNestedInput
  }

  export type MatchScoreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    matchedUserId?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    religionScore?: NullableIntFieldUpdateOperationsInput | number | null
    educationScore?: NullableIntFieldUpdateOperationsInput | number | null
    lifestyleScore?: NullableIntFieldUpdateOperationsInput | number | null
    locationScore?: NullableIntFieldUpdateOperationsInput | number | null
    familyScore?: NullableIntFieldUpdateOperationsInput | number | null
    matchReasons?: NullableJsonNullValueInput | InputJsonValue
    isReverseMatch?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchScoreCreateManyInput = {
    id?: string
    userId: string
    matchedUserId: string
    overallScore: number
    religionScore?: number | null
    educationScore?: number | null
    lifestyleScore?: number | null
    locationScore?: number | null
    familyScore?: number | null
    matchReasons?: NullableJsonNullValueInput | InputJsonValue
    isReverseMatch?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchScoreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    religionScore?: NullableIntFieldUpdateOperationsInput | number | null
    educationScore?: NullableIntFieldUpdateOperationsInput | number | null
    lifestyleScore?: NullableIntFieldUpdateOperationsInput | number | null
    locationScore?: NullableIntFieldUpdateOperationsInput | number | null
    familyScore?: NullableIntFieldUpdateOperationsInput | number | null
    matchReasons?: NullableJsonNullValueInput | InputJsonValue
    isReverseMatch?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchScoreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    matchedUserId?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    religionScore?: NullableIntFieldUpdateOperationsInput | number | null
    educationScore?: NullableIntFieldUpdateOperationsInput | number | null
    lifestyleScore?: NullableIntFieldUpdateOperationsInput | number | null
    locationScore?: NullableIntFieldUpdateOperationsInput | number | null
    familyScore?: NullableIntFieldUpdateOperationsInput | number | null
    matchReasons?: NullableJsonNullValueInput | InputJsonValue
    isReverseMatch?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchHistoryCreateInput = {
    id?: string
    profileId?: string | null
    searchQuery?: string | null
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSearchHistoryInput
  }

  export type SearchHistoryUncheckedCreateInput = {
    id?: string
    userId: string
    profileId?: string | null
    searchQuery?: string | null
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SearchHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    searchQuery?: NullableStringFieldUpdateOperationsInput | string | null
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSearchHistoryNestedInput
  }

  export type SearchHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    searchQuery?: NullableStringFieldUpdateOperationsInput | string | null
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchHistoryCreateManyInput = {
    id?: string
    userId: string
    profileId?: string | null
    searchQuery?: string | null
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SearchHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    searchQuery?: NullableStringFieldUpdateOperationsInput | string | null
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    searchQuery?: NullableStringFieldUpdateOperationsInput | string | null
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageTemplateCreateInput = {
    id?: string
    name: string
    content: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMessageTemplatesInput
  }

  export type MessageTemplateUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    content: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMessageTemplatesNestedInput
  }

  export type MessageTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageTemplateCreateManyInput = {
    id?: string
    userId: string
    name: string
    content: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IceBreakerCreateInput = {
    id?: string
    profileId: string
    question: string
    answer?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutIceBreakersInput
  }

  export type IceBreakerUncheckedCreateInput = {
    id?: string
    userId: string
    profileId: string
    question: string
    answer?: string | null
    createdAt?: Date | string
  }

  export type IceBreakerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutIceBreakersNestedInput
  }

  export type IceBreakerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IceBreakerCreateManyInput = {
    id?: string
    userId: string
    profileId: string
    question: string
    answer?: string | null
    createdAt?: Date | string
  }

  export type IceBreakerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IceBreakerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestimonialCreateInput = {
    id?: string
    authorName: string
    authorRelation?: string | null
    authorEmail?: string | null
    content: string
    rating?: number | null
    isApproved?: boolean
    createdAt?: Date | string
    profile: ProfileCreateNestedOneWithoutTestimonialsInput
  }

  export type TestimonialUncheckedCreateInput = {
    id?: string
    profileId: string
    authorName: string
    authorRelation?: string | null
    authorEmail?: string | null
    content: string
    rating?: number | null
    isApproved?: boolean
    createdAt?: Date | string
  }

  export type TestimonialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorRelation?: NullableStringFieldUpdateOperationsInput | string | null
    authorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutTestimonialsNestedInput
  }

  export type TestimonialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorRelation?: NullableStringFieldUpdateOperationsInput | string | null
    authorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestimonialCreateManyInput = {
    id?: string
    profileId: string
    authorName: string
    authorRelation?: string | null
    authorEmail?: string | null
    content: string
    rating?: number | null
    isApproved?: boolean
    createdAt?: Date | string
  }

  export type TestimonialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorRelation?: NullableStringFieldUpdateOperationsInput | string | null
    authorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestimonialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorRelation?: NullableStringFieldUpdateOperationsInput | string | null
    authorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateInput = {
    id?: string
    type: string
    title: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    title: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateManyInput = {
    id?: string
    userId: string
    type: string
    title: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardCreateInput = {
    id?: string
    category: string
    rank: number
    score: number
    period: string
    periodStart: Date | string
    periodEnd?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutLeaderboardInput
  }

  export type LeaderboardUncheckedCreateInput = {
    id?: string
    userId: string
    category: string
    rank: number
    score: number
    period: string
    periodStart: Date | string
    periodEnd?: Date | string | null
    createdAt?: Date | string
  }

  export type LeaderboardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLeaderboardNestedInput
  }

  export type LeaderboardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardCreateManyInput = {
    id?: string
    userId: string
    category: string
    rank: number
    score: number
    period: string
    periodStart: Date | string
    periodEnd?: Date | string | null
    createdAt?: Date | string
  }

  export type LeaderboardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistCreateInput = {
    id?: string
    criteria: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWishlistsInput
  }

  export type WishlistUncheckedCreateInput = {
    id?: string
    userId: string
    criteria: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WishlistUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    criteria?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWishlistsNestedInput
  }

  export type WishlistUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    criteria?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistCreateManyInput = {
    id?: string
    userId: string
    criteria: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WishlistUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    criteria?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    criteria?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileExportCreateInput = {
    id?: string
    format: string
    url: string
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutProfileExportsInput
  }

  export type ProfileExportUncheckedCreateInput = {
    id?: string
    userId: string
    format: string
    url: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type ProfileExportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProfileExportsNestedInput
  }

  export type ProfileExportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileExportCreateManyInput = {
    id?: string
    userId: string
    format: string
    url: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type ProfileExportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileExportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ProfileNullableRelationFilter = {
    is?: ProfileWhereInput | null
    isNot?: ProfileWhereInput | null
  }

  export type InterestListRelationFilter = {
    every?: InterestWhereInput
    some?: InterestWhereInput
    none?: InterestWhereInput
  }

  export type ChatListRelationFilter = {
    every?: ChatWhereInput
    some?: ChatWhereInput
    none?: ChatWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type SubscriptionListRelationFilter = {
    every?: SubscriptionWhereInput
    some?: SubscriptionWhereInput
    none?: SubscriptionWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type ProfileViewListRelationFilter = {
    every?: ProfileViewWhereInput
    some?: ProfileViewWhereInput
    none?: ProfileViewWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type ShortlistListRelationFilter = {
    every?: ShortlistWhereInput
    some?: ShortlistWhereInput
    none?: ShortlistWhereInput
  }

  export type BlockedUserListRelationFilter = {
    every?: BlockedUserWhereInput
    some?: BlockedUserWhereInput
    none?: BlockedUserWhereInput
  }

  export type ReferralListRelationFilter = {
    every?: ReferralWhereInput
    some?: ReferralWhereInput
    none?: ReferralWhereInput
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type AchievementListRelationFilter = {
    every?: AchievementWhereInput
    some?: AchievementWhereInput
    none?: AchievementWhereInput
  }

  export type HoroscopeListRelationFilter = {
    every?: HoroscopeWhereInput
    some?: HoroscopeWhereInput
    none?: HoroscopeWhereInput
  }

  export type FamilyMemberListRelationFilter = {
    every?: FamilyMemberWhereInput
    some?: FamilyMemberWhereInput
    none?: FamilyMemberWhereInput
  }

  export type SuccessStoryListRelationFilter = {
    every?: SuccessStoryWhereInput
    some?: SuccessStoryWhereInput
    none?: SuccessStoryWhereInput
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type VideoCallListRelationFilter = {
    every?: VideoCallWhereInput
    some?: VideoCallWhereInput
    none?: VideoCallWhereInput
  }

  export type ForumPostListRelationFilter = {
    every?: ForumPostWhereInput
    some?: ForumPostWhereInput
    none?: ForumPostWhereInput
  }

  export type ForumCommentListRelationFilter = {
    every?: ForumCommentWhereInput
    some?: ForumCommentWhereInput
    none?: ForumCommentWhereInput
  }

  export type GroupMemberListRelationFilter = {
    every?: GroupMemberWhereInput
    some?: GroupMemberWhereInput
    none?: GroupMemberWhereInput
  }

  export type EventParticipantListRelationFilter = {
    every?: EventParticipantWhereInput
    some?: EventParticipantWhereInput
    none?: EventParticipantWhereInput
  }

  export type BlogPostListRelationFilter = {
    every?: BlogPostWhereInput
    some?: BlogPostWhereInput
    none?: BlogPostWhereInput
  }

  export type MatchScoreListRelationFilter = {
    every?: MatchScoreWhereInput
    some?: MatchScoreWhereInput
    none?: MatchScoreWhereInput
  }

  export type SearchHistoryListRelationFilter = {
    every?: SearchHistoryWhereInput
    some?: SearchHistoryWhereInput
    none?: SearchHistoryWhereInput
  }

  export type MessageTemplateListRelationFilter = {
    every?: MessageTemplateWhereInput
    some?: MessageTemplateWhereInput
    none?: MessageTemplateWhereInput
  }

  export type IceBreakerListRelationFilter = {
    every?: IceBreakerWhereInput
    some?: IceBreakerWhereInput
    none?: IceBreakerWhereInput
  }

  export type ActivityListRelationFilter = {
    every?: ActivityWhereInput
    some?: ActivityWhereInput
    none?: ActivityWhereInput
  }

  export type LeaderboardListRelationFilter = {
    every?: LeaderboardWhereInput
    some?: LeaderboardWhereInput
    none?: LeaderboardWhereInput
  }

  export type WishlistListRelationFilter = {
    every?: WishlistWhereInput
    some?: WishlistWhereInput
    none?: WishlistWhereInput
  }

  export type ProfileExportListRelationFilter = {
    every?: ProfileExportWhereInput
    some?: ProfileExportWhereInput
    none?: ProfileExportWhereInput
  }

  export type ServiceListRelationFilter = {
    every?: ServiceWhereInput
    some?: ServiceWhereInput
    none?: ServiceWhereInput
  }

  export type ServiceBookingListRelationFilter = {
    every?: ServiceBookingWhereInput
    some?: ServiceBookingWhereInput
    none?: ServiceBookingWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type InterestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileViewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShortlistOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlockedUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReferralOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AchievementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HoroscopeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FamilyMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SuccessStoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VideoCallOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ForumPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ForumCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlogPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MatchScoreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SearchHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IceBreakerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaderboardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WishlistOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileExportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceBookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isEmailVerified?: SortOrder
    isMobileVerified?: SortOrder
    googleId?: SortOrder
    appleId?: SortOrder
    fcmToken?: SortOrder
    referralCode?: SortOrder
    referredBy?: SortOrder
    points?: SortOrder
    lastActiveAt?: SortOrder
    isOnline?: SortOrder
    lastLoginDate?: SortOrder
    loginStreak?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
    gdprConsent?: SortOrder
    gdprConsentAt?: SortOrder
    deletedAt?: SortOrder
    preferredLanguage?: SortOrder
    notificationPreferences?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    points?: SortOrder
    loginStreak?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isEmailVerified?: SortOrder
    isMobileVerified?: SortOrder
    googleId?: SortOrder
    appleId?: SortOrder
    fcmToken?: SortOrder
    referralCode?: SortOrder
    referredBy?: SortOrder
    points?: SortOrder
    lastActiveAt?: SortOrder
    isOnline?: SortOrder
    lastLoginDate?: SortOrder
    loginStreak?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
    gdprConsent?: SortOrder
    gdprConsentAt?: SortOrder
    deletedAt?: SortOrder
    preferredLanguage?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isEmailVerified?: SortOrder
    isMobileVerified?: SortOrder
    googleId?: SortOrder
    appleId?: SortOrder
    fcmToken?: SortOrder
    referralCode?: SortOrder
    referredBy?: SortOrder
    points?: SortOrder
    lastActiveAt?: SortOrder
    isOnline?: SortOrder
    lastLoginDate?: SortOrder
    loginStreak?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
    gdprConsent?: SortOrder
    gdprConsentAt?: SortOrder
    deletedAt?: SortOrder
    preferredLanguage?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    points?: SortOrder
    loginStreak?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumProfileStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProfileStatus | EnumProfileStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProfileStatus[] | ListEnumProfileStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProfileStatus[] | ListEnumProfileStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProfileStatusFilter<$PrismaModel> | $Enums.ProfileStatus
  }

  export type EnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumMaritalStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.MaritalStatus | EnumMaritalStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMaritalStatusNullableFilter<$PrismaModel> | $Enums.MaritalStatus | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type EnumFamilyTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.FamilyType | EnumFamilyTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.FamilyType[] | ListEnumFamilyTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FamilyType[] | ListEnumFamilyTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFamilyTypeNullableFilter<$PrismaModel> | $Enums.FamilyType | null
  }

  export type EnumDietNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Diet | EnumDietFieldRefInput<$PrismaModel> | null
    in?: $Enums.Diet[] | ListEnumDietFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Diet[] | ListEnumDietFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDietNullableFilter<$PrismaModel> | $Enums.Diet | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type PhotoListRelationFilter = {
    every?: PhotoWhereInput
    some?: PhotoWhereInput
    none?: PhotoWhereInput
  }

  export type HoroscopeNullableRelationFilter = {
    is?: HoroscopeWhereInput | null
    isNot?: HoroscopeWhereInput | null
  }

  export type ProfileComparisonListRelationFilter = {
    every?: ProfileComparisonWhereInput
    some?: ProfileComparisonWhereInput
    none?: ProfileComparisonWhereInput
  }

  export type TestimonialListRelationFilter = {
    every?: TestimonialWhereInput
    some?: TestimonialWhereInput
    none?: TestimonialWhereInput
  }

  export type PhotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileComparisonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestimonialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    gender?: SortOrder
    dateOfBirth?: SortOrder
    height?: SortOrder
    maritalStatus?: SortOrder
    religion?: SortOrder
    caste?: SortOrder
    motherTongue?: SortOrder
    manglik?: SortOrder
    gothra?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    citizenship?: SortOrder
    education?: SortOrder
    college?: SortOrder
    occupation?: SortOrder
    income?: SortOrder
    incomeCurrency?: SortOrder
    fatherOccupation?: SortOrder
    motherOccupation?: SortOrder
    siblings?: SortOrder
    familyType?: SortOrder
    diet?: SortOrder
    smoking?: SortOrder
    drinking?: SortOrder
    hobbies?: SortOrder
    partnerPreferences?: SortOrder
    videoIntroUrl?: SortOrder
    biodataUrl?: SortOrder
    aboutMe?: SortOrder
    highlights?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    privacySettings?: SortOrder
    isHiddenFromSearch?: SortOrder
    isAnonymousViewing?: SortOrder
    contactPrivacyLevel?: SortOrder
    photoPrivacyLevel?: SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrder
    trustScore?: SortOrder
    completenessScore?: SortOrder
    isHighlighted?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileAvgOrderByAggregateInput = {
    height?: SortOrder
    income?: SortOrder
    siblings?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    trustScore?: SortOrder
    completenessScore?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    gender?: SortOrder
    dateOfBirth?: SortOrder
    height?: SortOrder
    maritalStatus?: SortOrder
    religion?: SortOrder
    caste?: SortOrder
    motherTongue?: SortOrder
    manglik?: SortOrder
    gothra?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    citizenship?: SortOrder
    education?: SortOrder
    college?: SortOrder
    occupation?: SortOrder
    income?: SortOrder
    incomeCurrency?: SortOrder
    fatherOccupation?: SortOrder
    motherOccupation?: SortOrder
    siblings?: SortOrder
    familyType?: SortOrder
    diet?: SortOrder
    smoking?: SortOrder
    drinking?: SortOrder
    hobbies?: SortOrder
    videoIntroUrl?: SortOrder
    biodataUrl?: SortOrder
    aboutMe?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    isHiddenFromSearch?: SortOrder
    isAnonymousViewing?: SortOrder
    contactPrivacyLevel?: SortOrder
    photoPrivacyLevel?: SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrder
    trustScore?: SortOrder
    completenessScore?: SortOrder
    isHighlighted?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    gender?: SortOrder
    dateOfBirth?: SortOrder
    height?: SortOrder
    maritalStatus?: SortOrder
    religion?: SortOrder
    caste?: SortOrder
    motherTongue?: SortOrder
    manglik?: SortOrder
    gothra?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    citizenship?: SortOrder
    education?: SortOrder
    college?: SortOrder
    occupation?: SortOrder
    income?: SortOrder
    incomeCurrency?: SortOrder
    fatherOccupation?: SortOrder
    motherOccupation?: SortOrder
    siblings?: SortOrder
    familyType?: SortOrder
    diet?: SortOrder
    smoking?: SortOrder
    drinking?: SortOrder
    hobbies?: SortOrder
    videoIntroUrl?: SortOrder
    biodataUrl?: SortOrder
    aboutMe?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    isHiddenFromSearch?: SortOrder
    isAnonymousViewing?: SortOrder
    contactPrivacyLevel?: SortOrder
    photoPrivacyLevel?: SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrder
    trustScore?: SortOrder
    completenessScore?: SortOrder
    isHighlighted?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileSumOrderByAggregateInput = {
    height?: SortOrder
    income?: SortOrder
    siblings?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    trustScore?: SortOrder
    completenessScore?: SortOrder
  }

  export type EnumProfileStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProfileStatus | EnumProfileStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProfileStatus[] | ListEnumProfileStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProfileStatus[] | ListEnumProfileStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProfileStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProfileStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProfileStatusFilter<$PrismaModel>
    _max?: NestedEnumProfileStatusFilter<$PrismaModel>
  }

  export type EnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumMaritalStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaritalStatus | EnumMaritalStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMaritalStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.MaritalStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumMaritalStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumMaritalStatusNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type EnumFamilyTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FamilyType | EnumFamilyTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.FamilyType[] | ListEnumFamilyTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FamilyType[] | ListEnumFamilyTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFamilyTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.FamilyType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumFamilyTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumFamilyTypeNullableFilter<$PrismaModel>
  }

  export type EnumDietNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Diet | EnumDietFieldRefInput<$PrismaModel> | null
    in?: $Enums.Diet[] | ListEnumDietFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Diet[] | ListEnumDietFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDietNullableWithAggregatesFilter<$PrismaModel> | $Enums.Diet | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDietNullableFilter<$PrismaModel>
    _max?: NestedEnumDietNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ProfileRelationFilter = {
    is?: ProfileWhereInput
    isNot?: ProfileWhereInput
  }

  export type PhotoCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    url?: SortOrder
    cloudinaryId?: SortOrder
    isPrimary?: SortOrder
    isBlurred?: SortOrder
    isApproved?: SortOrder
    order?: SortOrder
    albumName?: SortOrder
    caption?: SortOrder
    createdAt?: SortOrder
  }

  export type PhotoAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type PhotoMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    url?: SortOrder
    cloudinaryId?: SortOrder
    isPrimary?: SortOrder
    isBlurred?: SortOrder
    isApproved?: SortOrder
    order?: SortOrder
    albumName?: SortOrder
    caption?: SortOrder
    createdAt?: SortOrder
  }

  export type PhotoMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    url?: SortOrder
    cloudinaryId?: SortOrder
    isPrimary?: SortOrder
    isBlurred?: SortOrder
    isApproved?: SortOrder
    order?: SortOrder
    albumName?: SortOrder
    caption?: SortOrder
    createdAt?: SortOrder
  }

  export type PhotoSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type VerificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    idType?: SortOrder
    idNumber?: SortOrder
    idPhotoUrl?: SortOrder
    selfieUrl?: SortOrder
    status?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    idType?: SortOrder
    idNumber?: SortOrder
    idPhotoUrl?: SortOrder
    selfieUrl?: SortOrder
    status?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    idType?: SortOrder
    idNumber?: SortOrder
    idPhotoUrl?: SortOrder
    selfieUrl?: SortOrder
    status?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumInterestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InterestStatus | EnumInterestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InterestStatus[] | ListEnumInterestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterestStatus[] | ListEnumInterestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInterestStatusFilter<$PrismaModel> | $Enums.InterestStatus
  }

  export type InterestFromUserIdToUserIdCompoundUniqueInput = {
    fromUserId: string
    toUserId: string
  }

  export type InterestCountOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    status?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InterestMaxOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    status?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InterestMinOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    status?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumInterestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InterestStatus | EnumInterestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InterestStatus[] | ListEnumInterestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterestStatus[] | ListEnumInterestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInterestStatusWithAggregatesFilter<$PrismaModel> | $Enums.InterestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInterestStatusFilter<$PrismaModel>
    _max?: NestedEnumInterestStatusFilter<$PrismaModel>
  }

  export type ChatUser1IdUser2IdCompoundUniqueInput = {
    user1Id: string
    user2Id: string
  }

  export type ChatCountOrderByAggregateInput = {
    id?: SortOrder
    user1Id?: SortOrder
    user2Id?: SortOrder
    lastMessageAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatMaxOrderByAggregateInput = {
    id?: SortOrder
    user1Id?: SortOrder
    user2Id?: SortOrder
    lastMessageAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatMinOrderByAggregateInput = {
    id?: SortOrder
    user1Id?: SortOrder
    user2Id?: SortOrder
    lastMessageAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ChatRelationFilter = {
    is?: ChatWhereInput
    isNot?: ChatWhereInput
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    videoUrl?: SortOrder
    audioUrl?: SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    messageType?: SortOrder
    isRead?: SortOrder
    isDeleted?: SortOrder
    deletedBy?: SortOrder
    isReported?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    videoUrl?: SortOrder
    audioUrl?: SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    messageType?: SortOrder
    isRead?: SortOrder
    isDeleted?: SortOrder
    isReported?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    videoUrl?: SortOrder
    audioUrl?: SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    messageType?: SortOrder
    isRead?: SortOrder
    isDeleted?: SortOrder
    isReported?: SortOrder
    createdAt?: SortOrder
  }

  export type ProfileViewProfileIdViewedByIdCompoundUniqueInput = {
    profileId: string
    viewedById: string
  }

  export type ProfileViewCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    viewedById?: SortOrder
    createdAt?: SortOrder
  }

  export type ProfileViewMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    viewedById?: SortOrder
    createdAt?: SortOrder
  }

  export type ProfileViewMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    viewedById?: SortOrder
    createdAt?: SortOrder
  }

  export type SubscriptionRelationFilter = {
    is?: SubscriptionWhereInput
    isNot?: SubscriptionWhereInput
  }

  export type ContactViewSubscriptionIdProfileIdViewedByIdCompoundUniqueInput = {
    subscriptionId: string
    profileId: string
    viewedById: string
  }

  export type ContactViewCountOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    profileId?: SortOrder
    viewedById?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactViewMaxOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    profileId?: SortOrder
    viewedById?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactViewMinOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    profileId?: SortOrder
    viewedById?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumSubscriptionPlanFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionPlanFilter<$PrismaModel> | $Enums.SubscriptionPlan
  }

  export type ContactViewListRelationFilter = {
    every?: ContactViewWhereInput
    some?: ContactViewWhereInput
    none?: ContactViewWhereInput
  }

  export type ContactViewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    razorpaySubscriptionId?: SortOrder
    razorpayPlanId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    contactViewsUsed?: SortOrder
    contactViewsLimit?: SortOrder
    profileBoostCredits?: SortOrder
    verifiedBadgeIncluded?: SortOrder
    horoscopeReportsIncluded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionAvgOrderByAggregateInput = {
    contactViewsUsed?: SortOrder
    contactViewsLimit?: SortOrder
    profileBoostCredits?: SortOrder
    horoscopeReportsIncluded?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    razorpaySubscriptionId?: SortOrder
    razorpayPlanId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    contactViewsUsed?: SortOrder
    contactViewsLimit?: SortOrder
    profileBoostCredits?: SortOrder
    verifiedBadgeIncluded?: SortOrder
    horoscopeReportsIncluded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    razorpaySubscriptionId?: SortOrder
    razorpayPlanId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    contactViewsUsed?: SortOrder
    contactViewsLimit?: SortOrder
    profileBoostCredits?: SortOrder
    verifiedBadgeIncluded?: SortOrder
    horoscopeReportsIncluded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionSumOrderByAggregateInput = {
    contactViewsUsed?: SortOrder
    contactViewsLimit?: SortOrder
    profileBoostCredits?: SortOrder
    horoscopeReportsIncluded?: SortOrder
  }

  export type EnumSubscriptionPlanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionPlanWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionPlan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type EnumAddOnTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AddOnType | EnumAddOnTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.AddOnType[] | ListEnumAddOnTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AddOnType[] | ListEnumAddOnTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAddOnTypeNullableFilter<$PrismaModel> | $Enums.AddOnType | null
  }

  export type AddOnListRelationFilter = {
    every?: AddOnWhereInput
    some?: AddOnWhereInput
    none?: AddOnWhereInput
  }

  export type AddOnOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    razorpayOrderId?: SortOrder
    razorpayPaymentId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    type?: SortOrder
    addOnType?: SortOrder
    subscriptionId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    razorpayOrderId?: SortOrder
    razorpayPaymentId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    type?: SortOrder
    addOnType?: SortOrder
    subscriptionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    razorpayOrderId?: SortOrder
    razorpayPaymentId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    type?: SortOrder
    addOnType?: SortOrder
    subscriptionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type EnumAddOnTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AddOnType | EnumAddOnTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.AddOnType[] | ListEnumAddOnTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AddOnType[] | ListEnumAddOnTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAddOnTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.AddOnType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAddOnTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumAddOnTypeNullableFilter<$PrismaModel>
  }

  export type EnumAddOnTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AddOnType | EnumAddOnTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AddOnType[] | ListEnumAddOnTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AddOnType[] | ListEnumAddOnTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAddOnTypeFilter<$PrismaModel> | $Enums.AddOnType
  }

  export type PaymentNullableRelationFilter = {
    is?: PaymentWhereInput | null
    isNot?: PaymentWhereInput | null
  }

  export type AddOnCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    paymentId?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type AddOnMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    paymentId?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type AddOnMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    paymentId?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAddOnTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AddOnType | EnumAddOnTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AddOnType[] | ListEnumAddOnTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AddOnType[] | ListEnumAddOnTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAddOnTypeWithAggregatesFilter<$PrismaModel> | $Enums.AddOnType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAddOnTypeFilter<$PrismaModel>
    _max?: NestedEnumAddOnTypeFilter<$PrismaModel>
  }

  export type EnumServiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceTypeFilter<$PrismaModel> | $Enums.ServiceType
  }

  export type EnumServiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceStatus | EnumServiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceStatusFilter<$PrismaModel> | $Enums.ServiceStatus
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    paymentId?: SortOrder
    amount?: SortOrder
    metadata?: SortOrder
    scheduledAt?: SortOrder
    completedAt?: SortOrder
    notes?: SortOrder
    rating?: SortOrder
    review?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    amount?: SortOrder
    rating?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    paymentId?: SortOrder
    amount?: SortOrder
    scheduledAt?: SortOrder
    completedAt?: SortOrder
    notes?: SortOrder
    rating?: SortOrder
    review?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    paymentId?: SortOrder
    amount?: SortOrder
    scheduledAt?: SortOrder
    completedAt?: SortOrder
    notes?: SortOrder
    rating?: SortOrder
    review?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    amount?: SortOrder
    rating?: SortOrder
  }

  export type EnumServiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ServiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceTypeFilter<$PrismaModel>
    _max?: NestedEnumServiceTypeFilter<$PrismaModel>
  }

  export type EnumServiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceStatus | EnumServiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.ServiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceStatusFilter<$PrismaModel>
    _max?: NestedEnumServiceStatusFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ServiceProviderCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    serviceType?: SortOrder
    expertise?: SortOrder
    rating?: SortOrder
    totalBookings?: SortOrder
    isActive?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceProviderAvgOrderByAggregateInput = {
    rating?: SortOrder
    totalBookings?: SortOrder
  }

  export type ServiceProviderMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    serviceType?: SortOrder
    expertise?: SortOrder
    rating?: SortOrder
    totalBookings?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceProviderMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    serviceType?: SortOrder
    expertise?: SortOrder
    rating?: SortOrder
    totalBookings?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceProviderSumOrderByAggregateInput = {
    rating?: SortOrder
    totalBookings?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ServiceRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type ServiceProviderNullableRelationFilter = {
    is?: ServiceProviderWhereInput | null
    isNot?: ServiceProviderWhereInput | null
  }

  export type ServiceBookingCountOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    meetingLink?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceBookingAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type ServiceBookingMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    meetingLink?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceBookingMinOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    meetingLink?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceBookingSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SavedSearchCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    filters?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SavedSearchMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SavedSearchMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type OTPCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    code?: SortOrder
    type?: SortOrder
    expiresAt?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
  }

  export type OTPMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    code?: SortOrder
    type?: SortOrder
    expiresAt?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
  }

  export type OTPMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    code?: SortOrder
    type?: SortOrder
    expiresAt?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder
    reporterId?: SortOrder
    reportedUserId?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    description?: SortOrder
    status?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder
    reporterId?: SortOrder
    reportedUserId?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    description?: SortOrder
    status?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder
    reporterId?: SortOrder
    reportedUserId?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    description?: SortOrder
    status?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ShortlistUserIdProfileIdCompoundUniqueInput = {
    userId: string
    profileId: string
  }

  export type ShortlistCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    profileId?: SortOrder
    folderName?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShortlistMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    profileId?: SortOrder
    folderName?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShortlistMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    profileId?: SortOrder
    folderName?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlockedUserBlockerIdBlockedIdCompoundUniqueInput = {
    blockerId: string
    blockedId: string
  }

  export type BlockedUserCountOrderByAggregateInput = {
    id?: SortOrder
    blockerId?: SortOrder
    blockedId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type BlockedUserMaxOrderByAggregateInput = {
    id?: SortOrder
    blockerId?: SortOrder
    blockedId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type BlockedUserMinOrderByAggregateInput = {
    id?: SortOrder
    blockerId?: SortOrder
    blockedId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type HoroscopeMatchListRelationFilter = {
    every?: HoroscopeMatchWhereInput
    some?: HoroscopeMatchWhereInput
    none?: HoroscopeMatchWhereInput
  }

  export type HoroscopeMatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HoroscopeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    profileId?: SortOrder
    horoscopeUrl?: SortOrder
    birthTime?: SortOrder
    birthPlace?: SortOrder
    rashi?: SortOrder
    nakshatra?: SortOrder
    mangalDosha?: SortOrder
    horoscopeData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HoroscopeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    profileId?: SortOrder
    horoscopeUrl?: SortOrder
    birthTime?: SortOrder
    birthPlace?: SortOrder
    rashi?: SortOrder
    nakshatra?: SortOrder
    mangalDosha?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HoroscopeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    profileId?: SortOrder
    horoscopeUrl?: SortOrder
    birthTime?: SortOrder
    birthPlace?: SortOrder
    rashi?: SortOrder
    nakshatra?: SortOrder
    mangalDosha?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HoroscopeRelationFilter = {
    is?: HoroscopeWhereInput
    isNot?: HoroscopeWhereInput
  }

  export type HoroscopeMatchUser1IdUser2IdCompoundUniqueInput = {
    user1Id: string
    user2Id: string
  }

  export type HoroscopeMatchCountOrderByAggregateInput = {
    id?: SortOrder
    user1Id?: SortOrder
    user2Id?: SortOrder
    horoscope1Id?: SortOrder
    horoscope2Id?: SortOrder
    ashtakootScore?: SortOrder
    mangalDoshaMatch?: SortOrder
    overallScore?: SortOrder
    matchDetails?: SortOrder
    createdAt?: SortOrder
  }

  export type HoroscopeMatchAvgOrderByAggregateInput = {
    ashtakootScore?: SortOrder
    overallScore?: SortOrder
  }

  export type HoroscopeMatchMaxOrderByAggregateInput = {
    id?: SortOrder
    user1Id?: SortOrder
    user2Id?: SortOrder
    horoscope1Id?: SortOrder
    horoscope2Id?: SortOrder
    ashtakootScore?: SortOrder
    mangalDoshaMatch?: SortOrder
    overallScore?: SortOrder
    createdAt?: SortOrder
  }

  export type HoroscopeMatchMinOrderByAggregateInput = {
    id?: SortOrder
    user1Id?: SortOrder
    user2Id?: SortOrder
    horoscope1Id?: SortOrder
    horoscope2Id?: SortOrder
    ashtakootScore?: SortOrder
    mangalDoshaMatch?: SortOrder
    overallScore?: SortOrder
    createdAt?: SortOrder
  }

  export type HoroscopeMatchSumOrderByAggregateInput = {
    ashtakootScore?: SortOrder
    overallScore?: SortOrder
  }

  export type SuccessStoryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    partnerId?: SortOrder
    title?: SortOrder
    story?: SortOrder
    weddingDate?: SortOrder
    photos?: SortOrder
    isApproved?: SortOrder
    isFeatured?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SuccessStoryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    partnerId?: SortOrder
    title?: SortOrder
    story?: SortOrder
    weddingDate?: SortOrder
    isApproved?: SortOrder
    isFeatured?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SuccessStoryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    partnerId?: SortOrder
    title?: SortOrder
    story?: SortOrder
    weddingDate?: SortOrder
    isApproved?: SortOrder
    isFeatured?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FamilyMemberCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    relation?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    password?: SortOrder
    canViewMatches?: SortOrder
    canSendInterests?: SortOrder
    canChat?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FamilyMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    relation?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    password?: SortOrder
    canViewMatches?: SortOrder
    canSendInterests?: SortOrder
    canChat?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FamilyMemberMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    relation?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    password?: SortOrder
    canViewMatches?: SortOrder
    canSendInterests?: SortOrder
    canChat?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferralReferrerIdReferredIdCompoundUniqueInput = {
    referrerId: string
    referredId: string
  }

  export type ReferralCountOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    referredId?: SortOrder
    rewardAmount?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ReferralAvgOrderByAggregateInput = {
    rewardAmount?: SortOrder
  }

  export type ReferralMaxOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    referredId?: SortOrder
    rewardAmount?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ReferralMinOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    referredId?: SortOrder
    rewardAmount?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ReferralSumOrderByAggregateInput = {
    rewardAmount?: SortOrder
  }

  export type AchievementCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    points?: SortOrder
    icon?: SortOrder
    unlockedAt?: SortOrder
  }

  export type AchievementAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type AchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    points?: SortOrder
    icon?: SortOrder
    unlockedAt?: SortOrder
  }

  export type AchievementMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    points?: SortOrder
    icon?: SortOrder
    unlockedAt?: SortOrder
  }

  export type AchievementSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    url?: SortOrder
    expiryDate?: SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    url?: SortOrder
    expiryDate?: SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    url?: SortOrder
    expiryDate?: SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoCallCountOrderByAggregateInput = {
    id?: SortOrder
    callerId?: SortOrder
    participantId?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    cancelledAt?: SortOrder
    duration?: SortOrder
    roomId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoCallAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type VideoCallMaxOrderByAggregateInput = {
    id?: SortOrder
    callerId?: SortOrder
    participantId?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    cancelledAt?: SortOrder
    duration?: SortOrder
    roomId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoCallMinOrderByAggregateInput = {
    id?: SortOrder
    callerId?: SortOrder
    participantId?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    cancelledAt?: SortOrder
    duration?: SortOrder
    roomId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoCallSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type ProfileComparisonUserIdProfileIdCompoundUniqueInput = {
    userId: string
    profileId: string
  }

  export type ProfileComparisonCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    profileId?: SortOrder
    comparisonData?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type ProfileComparisonMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    profileId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type ProfileComparisonMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    profileId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type ForumPostCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    isPinned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumPostAvgOrderByAggregateInput = {
    likes?: SortOrder
    views?: SortOrder
  }

  export type ForumPostMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    isPinned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumPostMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    isPinned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumPostSumOrderByAggregateInput = {
    likes?: SortOrder
    views?: SortOrder
  }

  export type ForumPostRelationFilter = {
    is?: ForumPostWhereInput
    isNot?: ForumPostWhereInput
  }

  export type ForumCommentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumCommentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunityGroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    photoUrl?: SortOrder
    isPublic?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunityGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    photoUrl?: SortOrder
    isPublic?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunityGroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    photoUrl?: SortOrder
    isPublic?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunityGroupRelationFilter = {
    is?: CommunityGroupWhereInput
    isNot?: CommunityGroupWhereInput
  }

  export type GroupMemberGroupIdUserIdCompoundUniqueInput = {
    groupId: string
    userId: string
  }

  export type GroupMemberCountOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type GroupMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type GroupMemberMinOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type CommunityEventCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    eventDate?: SortOrder
    location?: SortOrder
    photoUrl?: SortOrder
    maxParticipants?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunityEventAvgOrderByAggregateInput = {
    maxParticipants?: SortOrder
  }

  export type CommunityEventMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    eventDate?: SortOrder
    location?: SortOrder
    photoUrl?: SortOrder
    maxParticipants?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunityEventMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    eventDate?: SortOrder
    location?: SortOrder
    photoUrl?: SortOrder
    maxParticipants?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunityEventSumOrderByAggregateInput = {
    maxParticipants?: SortOrder
  }

  export type CommunityEventRelationFilter = {
    is?: CommunityEventWhereInput
    isNot?: CommunityEventWhereInput
  }

  export type EventParticipantEventIdUserIdCompoundUniqueInput = {
    eventId: string
    userId: string
  }

  export type EventParticipantCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
  }

  export type EventParticipantMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
  }

  export type EventParticipantMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
  }

  export type BlogPostCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    photoUrl?: SortOrder
    tags?: SortOrder
    isPublished?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogPostAvgOrderByAggregateInput = {
    views?: SortOrder
  }

  export type BlogPostMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    photoUrl?: SortOrder
    isPublished?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogPostMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    photoUrl?: SortOrder
    isPublished?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogPostSumOrderByAggregateInput = {
    views?: SortOrder
  }

  export type MatchScoreUserIdMatchedUserIdCompoundUniqueInput = {
    userId: string
    matchedUserId: string
  }

  export type MatchScoreCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    matchedUserId?: SortOrder
    overallScore?: SortOrder
    religionScore?: SortOrder
    educationScore?: SortOrder
    lifestyleScore?: SortOrder
    locationScore?: SortOrder
    familyScore?: SortOrder
    matchReasons?: SortOrder
    isReverseMatch?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchScoreAvgOrderByAggregateInput = {
    overallScore?: SortOrder
    religionScore?: SortOrder
    educationScore?: SortOrder
    lifestyleScore?: SortOrder
    locationScore?: SortOrder
    familyScore?: SortOrder
  }

  export type MatchScoreMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    matchedUserId?: SortOrder
    overallScore?: SortOrder
    religionScore?: SortOrder
    educationScore?: SortOrder
    lifestyleScore?: SortOrder
    locationScore?: SortOrder
    familyScore?: SortOrder
    isReverseMatch?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchScoreMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    matchedUserId?: SortOrder
    overallScore?: SortOrder
    religionScore?: SortOrder
    educationScore?: SortOrder
    lifestyleScore?: SortOrder
    locationScore?: SortOrder
    familyScore?: SortOrder
    isReverseMatch?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchScoreSumOrderByAggregateInput = {
    overallScore?: SortOrder
    religionScore?: SortOrder
    educationScore?: SortOrder
    lifestyleScore?: SortOrder
    locationScore?: SortOrder
    familyScore?: SortOrder
  }

  export type SearchHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    profileId?: SortOrder
    searchQuery?: SortOrder
    filters?: SortOrder
    createdAt?: SortOrder
  }

  export type SearchHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    profileId?: SortOrder
    searchQuery?: SortOrder
    createdAt?: SortOrder
  }

  export type SearchHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    profileId?: SortOrder
    searchQuery?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    content?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    content?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    content?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IceBreakerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    profileId?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrder
  }

  export type IceBreakerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    profileId?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrder
  }

  export type IceBreakerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    profileId?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrder
  }

  export type TestimonialCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    authorName?: SortOrder
    authorRelation?: SortOrder
    authorEmail?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    isApproved?: SortOrder
    createdAt?: SortOrder
  }

  export type TestimonialAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type TestimonialMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    authorName?: SortOrder
    authorRelation?: SortOrder
    authorEmail?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    isApproved?: SortOrder
    createdAt?: SortOrder
  }

  export type TestimonialMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    authorName?: SortOrder
    authorRelation?: SortOrder
    authorEmail?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    isApproved?: SortOrder
    createdAt?: SortOrder
  }

  export type TestimonialSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ActivityCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type LeaderboardUserIdCategoryPeriodPeriodStartCompoundUniqueInput = {
    userId: string
    category: string
    period: string
    periodStart: Date | string
  }

  export type LeaderboardCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    category?: SortOrder
    rank?: SortOrder
    score?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    createdAt?: SortOrder
  }

  export type LeaderboardAvgOrderByAggregateInput = {
    rank?: SortOrder
    score?: SortOrder
  }

  export type LeaderboardMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    category?: SortOrder
    rank?: SortOrder
    score?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    createdAt?: SortOrder
  }

  export type LeaderboardMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    category?: SortOrder
    rank?: SortOrder
    score?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    createdAt?: SortOrder
  }

  export type LeaderboardSumOrderByAggregateInput = {
    rank?: SortOrder
    score?: SortOrder
  }

  export type WishlistCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    criteria?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WishlistMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WishlistMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileExportCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    format?: SortOrder
    url?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ProfileExportMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    format?: SortOrder
    url?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ProfileExportMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    format?: SortOrder
    url?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type InterestCreateNestedManyWithoutFromUserInput = {
    create?: XOR<InterestCreateWithoutFromUserInput, InterestUncheckedCreateWithoutFromUserInput> | InterestCreateWithoutFromUserInput[] | InterestUncheckedCreateWithoutFromUserInput[]
    connectOrCreate?: InterestCreateOrConnectWithoutFromUserInput | InterestCreateOrConnectWithoutFromUserInput[]
    createMany?: InterestCreateManyFromUserInputEnvelope
    connect?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
  }

  export type InterestCreateNestedManyWithoutToUserInput = {
    create?: XOR<InterestCreateWithoutToUserInput, InterestUncheckedCreateWithoutToUserInput> | InterestCreateWithoutToUserInput[] | InterestUncheckedCreateWithoutToUserInput[]
    connectOrCreate?: InterestCreateOrConnectWithoutToUserInput | InterestCreateOrConnectWithoutToUserInput[]
    createMany?: InterestCreateManyToUserInputEnvelope
    connect?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
  }

  export type ChatCreateNestedManyWithoutUser1Input = {
    create?: XOR<ChatCreateWithoutUser1Input, ChatUncheckedCreateWithoutUser1Input> | ChatCreateWithoutUser1Input[] | ChatUncheckedCreateWithoutUser1Input[]
    connectOrCreate?: ChatCreateOrConnectWithoutUser1Input | ChatCreateOrConnectWithoutUser1Input[]
    createMany?: ChatCreateManyUser1InputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type ChatCreateNestedManyWithoutUser2Input = {
    create?: XOR<ChatCreateWithoutUser2Input, ChatUncheckedCreateWithoutUser2Input> | ChatCreateWithoutUser2Input[] | ChatUncheckedCreateWithoutUser2Input[]
    connectOrCreate?: ChatCreateOrConnectWithoutUser2Input | ChatCreateOrConnectWithoutUser2Input[]
    createMany?: ChatCreateManyUser2InputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedManyWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ProfileViewCreateNestedManyWithoutViewedByInput = {
    create?: XOR<ProfileViewCreateWithoutViewedByInput, ProfileViewUncheckedCreateWithoutViewedByInput> | ProfileViewCreateWithoutViewedByInput[] | ProfileViewUncheckedCreateWithoutViewedByInput[]
    connectOrCreate?: ProfileViewCreateOrConnectWithoutViewedByInput | ProfileViewCreateOrConnectWithoutViewedByInput[]
    createMany?: ProfileViewCreateManyViewedByInputEnvelope
    connect?: ProfileViewWhereUniqueInput | ProfileViewWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ShortlistCreateNestedManyWithoutUserInput = {
    create?: XOR<ShortlistCreateWithoutUserInput, ShortlistUncheckedCreateWithoutUserInput> | ShortlistCreateWithoutUserInput[] | ShortlistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShortlistCreateOrConnectWithoutUserInput | ShortlistCreateOrConnectWithoutUserInput[]
    createMany?: ShortlistCreateManyUserInputEnvelope
    connect?: ShortlistWhereUniqueInput | ShortlistWhereUniqueInput[]
  }

  export type BlockedUserCreateNestedManyWithoutBlockerInput = {
    create?: XOR<BlockedUserCreateWithoutBlockerInput, BlockedUserUncheckedCreateWithoutBlockerInput> | BlockedUserCreateWithoutBlockerInput[] | BlockedUserUncheckedCreateWithoutBlockerInput[]
    connectOrCreate?: BlockedUserCreateOrConnectWithoutBlockerInput | BlockedUserCreateOrConnectWithoutBlockerInput[]
    createMany?: BlockedUserCreateManyBlockerInputEnvelope
    connect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
  }

  export type BlockedUserCreateNestedManyWithoutBlockedInput = {
    create?: XOR<BlockedUserCreateWithoutBlockedInput, BlockedUserUncheckedCreateWithoutBlockedInput> | BlockedUserCreateWithoutBlockedInput[] | BlockedUserUncheckedCreateWithoutBlockedInput[]
    connectOrCreate?: BlockedUserCreateOrConnectWithoutBlockedInput | BlockedUserCreateOrConnectWithoutBlockedInput[]
    createMany?: BlockedUserCreateManyBlockedInputEnvelope
    connect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
  }

  export type ReferralCreateNestedManyWithoutReferrerInput = {
    create?: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput> | ReferralCreateWithoutReferrerInput[] | ReferralUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferrerInput | ReferralCreateOrConnectWithoutReferrerInput[]
    createMany?: ReferralCreateManyReferrerInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type ReferralCreateNestedManyWithoutReferredInput = {
    create?: XOR<ReferralCreateWithoutReferredInput, ReferralUncheckedCreateWithoutReferredInput> | ReferralCreateWithoutReferredInput[] | ReferralUncheckedCreateWithoutReferredInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferredInput | ReferralCreateOrConnectWithoutReferredInput[]
    createMany?: ReferralCreateManyReferredInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutReferredUsersInput = {
    create?: XOR<UserCreateWithoutReferredUsersInput, UserUncheckedCreateWithoutReferredUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferredUsersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutReferrerInput = {
    create?: XOR<UserCreateWithoutReferrerInput, UserUncheckedCreateWithoutReferrerInput> | UserCreateWithoutReferrerInput[] | UserUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutReferrerInput | UserCreateOrConnectWithoutReferrerInput[]
    createMany?: UserCreateManyReferrerInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AchievementCreateNestedManyWithoutUserInput = {
    create?: XOR<AchievementCreateWithoutUserInput, AchievementUncheckedCreateWithoutUserInput> | AchievementCreateWithoutUserInput[] | AchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutUserInput | AchievementCreateOrConnectWithoutUserInput[]
    createMany?: AchievementCreateManyUserInputEnvelope
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
  }

  export type HoroscopeCreateNestedManyWithoutUserInput = {
    create?: XOR<HoroscopeCreateWithoutUserInput, HoroscopeUncheckedCreateWithoutUserInput> | HoroscopeCreateWithoutUserInput[] | HoroscopeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HoroscopeCreateOrConnectWithoutUserInput | HoroscopeCreateOrConnectWithoutUserInput[]
    createMany?: HoroscopeCreateManyUserInputEnvelope
    connect?: HoroscopeWhereUniqueInput | HoroscopeWhereUniqueInput[]
  }

  export type FamilyMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<FamilyMemberCreateWithoutUserInput, FamilyMemberUncheckedCreateWithoutUserInput> | FamilyMemberCreateWithoutUserInput[] | FamilyMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutUserInput | FamilyMemberCreateOrConnectWithoutUserInput[]
    createMany?: FamilyMemberCreateManyUserInputEnvelope
    connect?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
  }

  export type SuccessStoryCreateNestedManyWithoutUserInput = {
    create?: XOR<SuccessStoryCreateWithoutUserInput, SuccessStoryUncheckedCreateWithoutUserInput> | SuccessStoryCreateWithoutUserInput[] | SuccessStoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SuccessStoryCreateOrConnectWithoutUserInput | SuccessStoryCreateOrConnectWithoutUserInput[]
    createMany?: SuccessStoryCreateManyUserInputEnvelope
    connect?: SuccessStoryWhereUniqueInput | SuccessStoryWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput> | DocumentCreateWithoutUserInput[] | DocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUserInput | DocumentCreateOrConnectWithoutUserInput[]
    createMany?: DocumentCreateManyUserInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type VideoCallCreateNestedManyWithoutCallerInput = {
    create?: XOR<VideoCallCreateWithoutCallerInput, VideoCallUncheckedCreateWithoutCallerInput> | VideoCallCreateWithoutCallerInput[] | VideoCallUncheckedCreateWithoutCallerInput[]
    connectOrCreate?: VideoCallCreateOrConnectWithoutCallerInput | VideoCallCreateOrConnectWithoutCallerInput[]
    createMany?: VideoCallCreateManyCallerInputEnvelope
    connect?: VideoCallWhereUniqueInput | VideoCallWhereUniqueInput[]
  }

  export type VideoCallCreateNestedManyWithoutParticipantInput = {
    create?: XOR<VideoCallCreateWithoutParticipantInput, VideoCallUncheckedCreateWithoutParticipantInput> | VideoCallCreateWithoutParticipantInput[] | VideoCallUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: VideoCallCreateOrConnectWithoutParticipantInput | VideoCallCreateOrConnectWithoutParticipantInput[]
    createMany?: VideoCallCreateManyParticipantInputEnvelope
    connect?: VideoCallWhereUniqueInput | VideoCallWhereUniqueInput[]
  }

  export type ForumPostCreateNestedManyWithoutUserInput = {
    create?: XOR<ForumPostCreateWithoutUserInput, ForumPostUncheckedCreateWithoutUserInput> | ForumPostCreateWithoutUserInput[] | ForumPostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ForumPostCreateOrConnectWithoutUserInput | ForumPostCreateOrConnectWithoutUserInput[]
    createMany?: ForumPostCreateManyUserInputEnvelope
    connect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
  }

  export type ForumCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<ForumCommentCreateWithoutUserInput, ForumCommentUncheckedCreateWithoutUserInput> | ForumCommentCreateWithoutUserInput[] | ForumCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ForumCommentCreateOrConnectWithoutUserInput | ForumCommentCreateOrConnectWithoutUserInput[]
    createMany?: ForumCommentCreateManyUserInputEnvelope
    connect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
  }

  export type GroupMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput> | GroupMemberCreateWithoutUserInput[] | GroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutUserInput | GroupMemberCreateOrConnectWithoutUserInput[]
    createMany?: GroupMemberCreateManyUserInputEnvelope
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
  }

  export type EventParticipantCreateNestedManyWithoutUserInput = {
    create?: XOR<EventParticipantCreateWithoutUserInput, EventParticipantUncheckedCreateWithoutUserInput> | EventParticipantCreateWithoutUserInput[] | EventParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventParticipantCreateOrConnectWithoutUserInput | EventParticipantCreateOrConnectWithoutUserInput[]
    createMany?: EventParticipantCreateManyUserInputEnvelope
    connect?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
  }

  export type BlogPostCreateNestedManyWithoutUserInput = {
    create?: XOR<BlogPostCreateWithoutUserInput, BlogPostUncheckedCreateWithoutUserInput> | BlogPostCreateWithoutUserInput[] | BlogPostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutUserInput | BlogPostCreateOrConnectWithoutUserInput[]
    createMany?: BlogPostCreateManyUserInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type MatchScoreCreateNestedManyWithoutUserInput = {
    create?: XOR<MatchScoreCreateWithoutUserInput, MatchScoreUncheckedCreateWithoutUserInput> | MatchScoreCreateWithoutUserInput[] | MatchScoreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MatchScoreCreateOrConnectWithoutUserInput | MatchScoreCreateOrConnectWithoutUserInput[]
    createMany?: MatchScoreCreateManyUserInputEnvelope
    connect?: MatchScoreWhereUniqueInput | MatchScoreWhereUniqueInput[]
  }

  export type MatchScoreCreateNestedManyWithoutMatchedUserInput = {
    create?: XOR<MatchScoreCreateWithoutMatchedUserInput, MatchScoreUncheckedCreateWithoutMatchedUserInput> | MatchScoreCreateWithoutMatchedUserInput[] | MatchScoreUncheckedCreateWithoutMatchedUserInput[]
    connectOrCreate?: MatchScoreCreateOrConnectWithoutMatchedUserInput | MatchScoreCreateOrConnectWithoutMatchedUserInput[]
    createMany?: MatchScoreCreateManyMatchedUserInputEnvelope
    connect?: MatchScoreWhereUniqueInput | MatchScoreWhereUniqueInput[]
  }

  export type SearchHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<SearchHistoryCreateWithoutUserInput, SearchHistoryUncheckedCreateWithoutUserInput> | SearchHistoryCreateWithoutUserInput[] | SearchHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SearchHistoryCreateOrConnectWithoutUserInput | SearchHistoryCreateOrConnectWithoutUserInput[]
    createMany?: SearchHistoryCreateManyUserInputEnvelope
    connect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
  }

  export type MessageTemplateCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageTemplateCreateWithoutUserInput, MessageTemplateUncheckedCreateWithoutUserInput> | MessageTemplateCreateWithoutUserInput[] | MessageTemplateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageTemplateCreateOrConnectWithoutUserInput | MessageTemplateCreateOrConnectWithoutUserInput[]
    createMany?: MessageTemplateCreateManyUserInputEnvelope
    connect?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
  }

  export type IceBreakerCreateNestedManyWithoutUserInput = {
    create?: XOR<IceBreakerCreateWithoutUserInput, IceBreakerUncheckedCreateWithoutUserInput> | IceBreakerCreateWithoutUserInput[] | IceBreakerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IceBreakerCreateOrConnectWithoutUserInput | IceBreakerCreateOrConnectWithoutUserInput[]
    createMany?: IceBreakerCreateManyUserInputEnvelope
    connect?: IceBreakerWhereUniqueInput | IceBreakerWhereUniqueInput[]
  }

  export type ActivityCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type LeaderboardCreateNestedManyWithoutUserInput = {
    create?: XOR<LeaderboardCreateWithoutUserInput, LeaderboardUncheckedCreateWithoutUserInput> | LeaderboardCreateWithoutUserInput[] | LeaderboardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaderboardCreateOrConnectWithoutUserInput | LeaderboardCreateOrConnectWithoutUserInput[]
    createMany?: LeaderboardCreateManyUserInputEnvelope
    connect?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
  }

  export type WishlistCreateNestedManyWithoutUserInput = {
    create?: XOR<WishlistCreateWithoutUserInput, WishlistUncheckedCreateWithoutUserInput> | WishlistCreateWithoutUserInput[] | WishlistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WishlistCreateOrConnectWithoutUserInput | WishlistCreateOrConnectWithoutUserInput[]
    createMany?: WishlistCreateManyUserInputEnvelope
    connect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
  }

  export type ProfileExportCreateNestedManyWithoutUserInput = {
    create?: XOR<ProfileExportCreateWithoutUserInput, ProfileExportUncheckedCreateWithoutUserInput> | ProfileExportCreateWithoutUserInput[] | ProfileExportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfileExportCreateOrConnectWithoutUserInput | ProfileExportCreateOrConnectWithoutUserInput[]
    createMany?: ProfileExportCreateManyUserInputEnvelope
    connect?: ProfileExportWhereUniqueInput | ProfileExportWhereUniqueInput[]
  }

  export type ServiceCreateNestedManyWithoutUserInput = {
    create?: XOR<ServiceCreateWithoutUserInput, ServiceUncheckedCreateWithoutUserInput> | ServiceCreateWithoutUserInput[] | ServiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutUserInput | ServiceCreateOrConnectWithoutUserInput[]
    createMany?: ServiceCreateManyUserInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type ServiceBookingCreateNestedManyWithoutUserInput = {
    create?: XOR<ServiceBookingCreateWithoutUserInput, ServiceBookingUncheckedCreateWithoutUserInput> | ServiceBookingCreateWithoutUserInput[] | ServiceBookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceBookingCreateOrConnectWithoutUserInput | ServiceBookingCreateOrConnectWithoutUserInput[]
    createMany?: ServiceBookingCreateManyUserInputEnvelope
    connect?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
  }

  export type ProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type InterestUncheckedCreateNestedManyWithoutFromUserInput = {
    create?: XOR<InterestCreateWithoutFromUserInput, InterestUncheckedCreateWithoutFromUserInput> | InterestCreateWithoutFromUserInput[] | InterestUncheckedCreateWithoutFromUserInput[]
    connectOrCreate?: InterestCreateOrConnectWithoutFromUserInput | InterestCreateOrConnectWithoutFromUserInput[]
    createMany?: InterestCreateManyFromUserInputEnvelope
    connect?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
  }

  export type InterestUncheckedCreateNestedManyWithoutToUserInput = {
    create?: XOR<InterestCreateWithoutToUserInput, InterestUncheckedCreateWithoutToUserInput> | InterestCreateWithoutToUserInput[] | InterestUncheckedCreateWithoutToUserInput[]
    connectOrCreate?: InterestCreateOrConnectWithoutToUserInput | InterestCreateOrConnectWithoutToUserInput[]
    createMany?: InterestCreateManyToUserInputEnvelope
    connect?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
  }

  export type ChatUncheckedCreateNestedManyWithoutUser1Input = {
    create?: XOR<ChatCreateWithoutUser1Input, ChatUncheckedCreateWithoutUser1Input> | ChatCreateWithoutUser1Input[] | ChatUncheckedCreateWithoutUser1Input[]
    connectOrCreate?: ChatCreateOrConnectWithoutUser1Input | ChatCreateOrConnectWithoutUser1Input[]
    createMany?: ChatCreateManyUser1InputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type ChatUncheckedCreateNestedManyWithoutUser2Input = {
    create?: XOR<ChatCreateWithoutUser2Input, ChatUncheckedCreateWithoutUser2Input> | ChatCreateWithoutUser2Input[] | ChatUncheckedCreateWithoutUser2Input[]
    connectOrCreate?: ChatCreateOrConnectWithoutUser2Input | ChatCreateOrConnectWithoutUser2Input[]
    createMany?: ChatCreateManyUser2InputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ProfileViewUncheckedCreateNestedManyWithoutViewedByInput = {
    create?: XOR<ProfileViewCreateWithoutViewedByInput, ProfileViewUncheckedCreateWithoutViewedByInput> | ProfileViewCreateWithoutViewedByInput[] | ProfileViewUncheckedCreateWithoutViewedByInput[]
    connectOrCreate?: ProfileViewCreateOrConnectWithoutViewedByInput | ProfileViewCreateOrConnectWithoutViewedByInput[]
    createMany?: ProfileViewCreateManyViewedByInputEnvelope
    connect?: ProfileViewWhereUniqueInput | ProfileViewWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ShortlistUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ShortlistCreateWithoutUserInput, ShortlistUncheckedCreateWithoutUserInput> | ShortlistCreateWithoutUserInput[] | ShortlistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShortlistCreateOrConnectWithoutUserInput | ShortlistCreateOrConnectWithoutUserInput[]
    createMany?: ShortlistCreateManyUserInputEnvelope
    connect?: ShortlistWhereUniqueInput | ShortlistWhereUniqueInput[]
  }

  export type BlockedUserUncheckedCreateNestedManyWithoutBlockerInput = {
    create?: XOR<BlockedUserCreateWithoutBlockerInput, BlockedUserUncheckedCreateWithoutBlockerInput> | BlockedUserCreateWithoutBlockerInput[] | BlockedUserUncheckedCreateWithoutBlockerInput[]
    connectOrCreate?: BlockedUserCreateOrConnectWithoutBlockerInput | BlockedUserCreateOrConnectWithoutBlockerInput[]
    createMany?: BlockedUserCreateManyBlockerInputEnvelope
    connect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
  }

  export type BlockedUserUncheckedCreateNestedManyWithoutBlockedInput = {
    create?: XOR<BlockedUserCreateWithoutBlockedInput, BlockedUserUncheckedCreateWithoutBlockedInput> | BlockedUserCreateWithoutBlockedInput[] | BlockedUserUncheckedCreateWithoutBlockedInput[]
    connectOrCreate?: BlockedUserCreateOrConnectWithoutBlockedInput | BlockedUserCreateOrConnectWithoutBlockedInput[]
    createMany?: BlockedUserCreateManyBlockedInputEnvelope
    connect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
  }

  export type ReferralUncheckedCreateNestedManyWithoutReferrerInput = {
    create?: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput> | ReferralCreateWithoutReferrerInput[] | ReferralUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferrerInput | ReferralCreateOrConnectWithoutReferrerInput[]
    createMany?: ReferralCreateManyReferrerInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type ReferralUncheckedCreateNestedManyWithoutReferredInput = {
    create?: XOR<ReferralCreateWithoutReferredInput, ReferralUncheckedCreateWithoutReferredInput> | ReferralCreateWithoutReferredInput[] | ReferralUncheckedCreateWithoutReferredInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferredInput | ReferralCreateOrConnectWithoutReferredInput[]
    createMany?: ReferralCreateManyReferredInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutReferrerInput = {
    create?: XOR<UserCreateWithoutReferrerInput, UserUncheckedCreateWithoutReferrerInput> | UserCreateWithoutReferrerInput[] | UserUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutReferrerInput | UserCreateOrConnectWithoutReferrerInput[]
    createMany?: UserCreateManyReferrerInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AchievementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AchievementCreateWithoutUserInput, AchievementUncheckedCreateWithoutUserInput> | AchievementCreateWithoutUserInput[] | AchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutUserInput | AchievementCreateOrConnectWithoutUserInput[]
    createMany?: AchievementCreateManyUserInputEnvelope
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
  }

  export type HoroscopeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<HoroscopeCreateWithoutUserInput, HoroscopeUncheckedCreateWithoutUserInput> | HoroscopeCreateWithoutUserInput[] | HoroscopeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HoroscopeCreateOrConnectWithoutUserInput | HoroscopeCreateOrConnectWithoutUserInput[]
    createMany?: HoroscopeCreateManyUserInputEnvelope
    connect?: HoroscopeWhereUniqueInput | HoroscopeWhereUniqueInput[]
  }

  export type FamilyMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FamilyMemberCreateWithoutUserInput, FamilyMemberUncheckedCreateWithoutUserInput> | FamilyMemberCreateWithoutUserInput[] | FamilyMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutUserInput | FamilyMemberCreateOrConnectWithoutUserInput[]
    createMany?: FamilyMemberCreateManyUserInputEnvelope
    connect?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
  }

  export type SuccessStoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SuccessStoryCreateWithoutUserInput, SuccessStoryUncheckedCreateWithoutUserInput> | SuccessStoryCreateWithoutUserInput[] | SuccessStoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SuccessStoryCreateOrConnectWithoutUserInput | SuccessStoryCreateOrConnectWithoutUserInput[]
    createMany?: SuccessStoryCreateManyUserInputEnvelope
    connect?: SuccessStoryWhereUniqueInput | SuccessStoryWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput> | DocumentCreateWithoutUserInput[] | DocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUserInput | DocumentCreateOrConnectWithoutUserInput[]
    createMany?: DocumentCreateManyUserInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type VideoCallUncheckedCreateNestedManyWithoutCallerInput = {
    create?: XOR<VideoCallCreateWithoutCallerInput, VideoCallUncheckedCreateWithoutCallerInput> | VideoCallCreateWithoutCallerInput[] | VideoCallUncheckedCreateWithoutCallerInput[]
    connectOrCreate?: VideoCallCreateOrConnectWithoutCallerInput | VideoCallCreateOrConnectWithoutCallerInput[]
    createMany?: VideoCallCreateManyCallerInputEnvelope
    connect?: VideoCallWhereUniqueInput | VideoCallWhereUniqueInput[]
  }

  export type VideoCallUncheckedCreateNestedManyWithoutParticipantInput = {
    create?: XOR<VideoCallCreateWithoutParticipantInput, VideoCallUncheckedCreateWithoutParticipantInput> | VideoCallCreateWithoutParticipantInput[] | VideoCallUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: VideoCallCreateOrConnectWithoutParticipantInput | VideoCallCreateOrConnectWithoutParticipantInput[]
    createMany?: VideoCallCreateManyParticipantInputEnvelope
    connect?: VideoCallWhereUniqueInput | VideoCallWhereUniqueInput[]
  }

  export type ForumPostUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ForumPostCreateWithoutUserInput, ForumPostUncheckedCreateWithoutUserInput> | ForumPostCreateWithoutUserInput[] | ForumPostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ForumPostCreateOrConnectWithoutUserInput | ForumPostCreateOrConnectWithoutUserInput[]
    createMany?: ForumPostCreateManyUserInputEnvelope
    connect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
  }

  export type ForumCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ForumCommentCreateWithoutUserInput, ForumCommentUncheckedCreateWithoutUserInput> | ForumCommentCreateWithoutUserInput[] | ForumCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ForumCommentCreateOrConnectWithoutUserInput | ForumCommentCreateOrConnectWithoutUserInput[]
    createMany?: ForumCommentCreateManyUserInputEnvelope
    connect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
  }

  export type GroupMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput> | GroupMemberCreateWithoutUserInput[] | GroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutUserInput | GroupMemberCreateOrConnectWithoutUserInput[]
    createMany?: GroupMemberCreateManyUserInputEnvelope
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
  }

  export type EventParticipantUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EventParticipantCreateWithoutUserInput, EventParticipantUncheckedCreateWithoutUserInput> | EventParticipantCreateWithoutUserInput[] | EventParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventParticipantCreateOrConnectWithoutUserInput | EventParticipantCreateOrConnectWithoutUserInput[]
    createMany?: EventParticipantCreateManyUserInputEnvelope
    connect?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
  }

  export type BlogPostUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BlogPostCreateWithoutUserInput, BlogPostUncheckedCreateWithoutUserInput> | BlogPostCreateWithoutUserInput[] | BlogPostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutUserInput | BlogPostCreateOrConnectWithoutUserInput[]
    createMany?: BlogPostCreateManyUserInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type MatchScoreUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MatchScoreCreateWithoutUserInput, MatchScoreUncheckedCreateWithoutUserInput> | MatchScoreCreateWithoutUserInput[] | MatchScoreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MatchScoreCreateOrConnectWithoutUserInput | MatchScoreCreateOrConnectWithoutUserInput[]
    createMany?: MatchScoreCreateManyUserInputEnvelope
    connect?: MatchScoreWhereUniqueInput | MatchScoreWhereUniqueInput[]
  }

  export type MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput = {
    create?: XOR<MatchScoreCreateWithoutMatchedUserInput, MatchScoreUncheckedCreateWithoutMatchedUserInput> | MatchScoreCreateWithoutMatchedUserInput[] | MatchScoreUncheckedCreateWithoutMatchedUserInput[]
    connectOrCreate?: MatchScoreCreateOrConnectWithoutMatchedUserInput | MatchScoreCreateOrConnectWithoutMatchedUserInput[]
    createMany?: MatchScoreCreateManyMatchedUserInputEnvelope
    connect?: MatchScoreWhereUniqueInput | MatchScoreWhereUniqueInput[]
  }

  export type SearchHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SearchHistoryCreateWithoutUserInput, SearchHistoryUncheckedCreateWithoutUserInput> | SearchHistoryCreateWithoutUserInput[] | SearchHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SearchHistoryCreateOrConnectWithoutUserInput | SearchHistoryCreateOrConnectWithoutUserInput[]
    createMany?: SearchHistoryCreateManyUserInputEnvelope
    connect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
  }

  export type MessageTemplateUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageTemplateCreateWithoutUserInput, MessageTemplateUncheckedCreateWithoutUserInput> | MessageTemplateCreateWithoutUserInput[] | MessageTemplateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageTemplateCreateOrConnectWithoutUserInput | MessageTemplateCreateOrConnectWithoutUserInput[]
    createMany?: MessageTemplateCreateManyUserInputEnvelope
    connect?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
  }

  export type IceBreakerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<IceBreakerCreateWithoutUserInput, IceBreakerUncheckedCreateWithoutUserInput> | IceBreakerCreateWithoutUserInput[] | IceBreakerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IceBreakerCreateOrConnectWithoutUserInput | IceBreakerCreateOrConnectWithoutUserInput[]
    createMany?: IceBreakerCreateManyUserInputEnvelope
    connect?: IceBreakerWhereUniqueInput | IceBreakerWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type LeaderboardUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LeaderboardCreateWithoutUserInput, LeaderboardUncheckedCreateWithoutUserInput> | LeaderboardCreateWithoutUserInput[] | LeaderboardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaderboardCreateOrConnectWithoutUserInput | LeaderboardCreateOrConnectWithoutUserInput[]
    createMany?: LeaderboardCreateManyUserInputEnvelope
    connect?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
  }

  export type WishlistUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WishlistCreateWithoutUserInput, WishlistUncheckedCreateWithoutUserInput> | WishlistCreateWithoutUserInput[] | WishlistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WishlistCreateOrConnectWithoutUserInput | WishlistCreateOrConnectWithoutUserInput[]
    createMany?: WishlistCreateManyUserInputEnvelope
    connect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
  }

  export type ProfileExportUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProfileExportCreateWithoutUserInput, ProfileExportUncheckedCreateWithoutUserInput> | ProfileExportCreateWithoutUserInput[] | ProfileExportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfileExportCreateOrConnectWithoutUserInput | ProfileExportCreateOrConnectWithoutUserInput[]
    createMany?: ProfileExportCreateManyUserInputEnvelope
    connect?: ProfileExportWhereUniqueInput | ProfileExportWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ServiceCreateWithoutUserInput, ServiceUncheckedCreateWithoutUserInput> | ServiceCreateWithoutUserInput[] | ServiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutUserInput | ServiceCreateOrConnectWithoutUserInput[]
    createMany?: ServiceCreateManyUserInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type ServiceBookingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ServiceBookingCreateWithoutUserInput, ServiceBookingUncheckedCreateWithoutUserInput> | ServiceBookingCreateWithoutUserInput[] | ServiceBookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceBookingCreateOrConnectWithoutUserInput | ServiceBookingCreateOrConnectWithoutUserInput[]
    createMany?: ServiceBookingCreateManyUserInputEnvelope
    connect?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type InterestUpdateManyWithoutFromUserNestedInput = {
    create?: XOR<InterestCreateWithoutFromUserInput, InterestUncheckedCreateWithoutFromUserInput> | InterestCreateWithoutFromUserInput[] | InterestUncheckedCreateWithoutFromUserInput[]
    connectOrCreate?: InterestCreateOrConnectWithoutFromUserInput | InterestCreateOrConnectWithoutFromUserInput[]
    upsert?: InterestUpsertWithWhereUniqueWithoutFromUserInput | InterestUpsertWithWhereUniqueWithoutFromUserInput[]
    createMany?: InterestCreateManyFromUserInputEnvelope
    set?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
    disconnect?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
    delete?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
    connect?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
    update?: InterestUpdateWithWhereUniqueWithoutFromUserInput | InterestUpdateWithWhereUniqueWithoutFromUserInput[]
    updateMany?: InterestUpdateManyWithWhereWithoutFromUserInput | InterestUpdateManyWithWhereWithoutFromUserInput[]
    deleteMany?: InterestScalarWhereInput | InterestScalarWhereInput[]
  }

  export type InterestUpdateManyWithoutToUserNestedInput = {
    create?: XOR<InterestCreateWithoutToUserInput, InterestUncheckedCreateWithoutToUserInput> | InterestCreateWithoutToUserInput[] | InterestUncheckedCreateWithoutToUserInput[]
    connectOrCreate?: InterestCreateOrConnectWithoutToUserInput | InterestCreateOrConnectWithoutToUserInput[]
    upsert?: InterestUpsertWithWhereUniqueWithoutToUserInput | InterestUpsertWithWhereUniqueWithoutToUserInput[]
    createMany?: InterestCreateManyToUserInputEnvelope
    set?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
    disconnect?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
    delete?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
    connect?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
    update?: InterestUpdateWithWhereUniqueWithoutToUserInput | InterestUpdateWithWhereUniqueWithoutToUserInput[]
    updateMany?: InterestUpdateManyWithWhereWithoutToUserInput | InterestUpdateManyWithWhereWithoutToUserInput[]
    deleteMany?: InterestScalarWhereInput | InterestScalarWhereInput[]
  }

  export type ChatUpdateManyWithoutUser1NestedInput = {
    create?: XOR<ChatCreateWithoutUser1Input, ChatUncheckedCreateWithoutUser1Input> | ChatCreateWithoutUser1Input[] | ChatUncheckedCreateWithoutUser1Input[]
    connectOrCreate?: ChatCreateOrConnectWithoutUser1Input | ChatCreateOrConnectWithoutUser1Input[]
    upsert?: ChatUpsertWithWhereUniqueWithoutUser1Input | ChatUpsertWithWhereUniqueWithoutUser1Input[]
    createMany?: ChatCreateManyUser1InputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutUser1Input | ChatUpdateWithWhereUniqueWithoutUser1Input[]
    updateMany?: ChatUpdateManyWithWhereWithoutUser1Input | ChatUpdateManyWithWhereWithoutUser1Input[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type ChatUpdateManyWithoutUser2NestedInput = {
    create?: XOR<ChatCreateWithoutUser2Input, ChatUncheckedCreateWithoutUser2Input> | ChatCreateWithoutUser2Input[] | ChatUncheckedCreateWithoutUser2Input[]
    connectOrCreate?: ChatCreateOrConnectWithoutUser2Input | ChatCreateOrConnectWithoutUser2Input[]
    upsert?: ChatUpsertWithWhereUniqueWithoutUser2Input | ChatUpsertWithWhereUniqueWithoutUser2Input[]
    createMany?: ChatCreateManyUser2InputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutUser2Input | ChatUpdateWithWhereUniqueWithoutUser2Input[]
    updateMany?: ChatUpdateManyWithWhereWithoutUser2Input | ChatUpdateManyWithWhereWithoutUser2Input[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type SubscriptionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutUserInput | SubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutUserInput | SubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutUserInput | SubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ProfileViewUpdateManyWithoutViewedByNestedInput = {
    create?: XOR<ProfileViewCreateWithoutViewedByInput, ProfileViewUncheckedCreateWithoutViewedByInput> | ProfileViewCreateWithoutViewedByInput[] | ProfileViewUncheckedCreateWithoutViewedByInput[]
    connectOrCreate?: ProfileViewCreateOrConnectWithoutViewedByInput | ProfileViewCreateOrConnectWithoutViewedByInput[]
    upsert?: ProfileViewUpsertWithWhereUniqueWithoutViewedByInput | ProfileViewUpsertWithWhereUniqueWithoutViewedByInput[]
    createMany?: ProfileViewCreateManyViewedByInputEnvelope
    set?: ProfileViewWhereUniqueInput | ProfileViewWhereUniqueInput[]
    disconnect?: ProfileViewWhereUniqueInput | ProfileViewWhereUniqueInput[]
    delete?: ProfileViewWhereUniqueInput | ProfileViewWhereUniqueInput[]
    connect?: ProfileViewWhereUniqueInput | ProfileViewWhereUniqueInput[]
    update?: ProfileViewUpdateWithWhereUniqueWithoutViewedByInput | ProfileViewUpdateWithWhereUniqueWithoutViewedByInput[]
    updateMany?: ProfileViewUpdateManyWithWhereWithoutViewedByInput | ProfileViewUpdateManyWithWhereWithoutViewedByInput[]
    deleteMany?: ProfileViewScalarWhereInput | ProfileViewScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ShortlistUpdateManyWithoutUserNestedInput = {
    create?: XOR<ShortlistCreateWithoutUserInput, ShortlistUncheckedCreateWithoutUserInput> | ShortlistCreateWithoutUserInput[] | ShortlistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShortlistCreateOrConnectWithoutUserInput | ShortlistCreateOrConnectWithoutUserInput[]
    upsert?: ShortlistUpsertWithWhereUniqueWithoutUserInput | ShortlistUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ShortlistCreateManyUserInputEnvelope
    set?: ShortlistWhereUniqueInput | ShortlistWhereUniqueInput[]
    disconnect?: ShortlistWhereUniqueInput | ShortlistWhereUniqueInput[]
    delete?: ShortlistWhereUniqueInput | ShortlistWhereUniqueInput[]
    connect?: ShortlistWhereUniqueInput | ShortlistWhereUniqueInput[]
    update?: ShortlistUpdateWithWhereUniqueWithoutUserInput | ShortlistUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ShortlistUpdateManyWithWhereWithoutUserInput | ShortlistUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ShortlistScalarWhereInput | ShortlistScalarWhereInput[]
  }

  export type BlockedUserUpdateManyWithoutBlockerNestedInput = {
    create?: XOR<BlockedUserCreateWithoutBlockerInput, BlockedUserUncheckedCreateWithoutBlockerInput> | BlockedUserCreateWithoutBlockerInput[] | BlockedUserUncheckedCreateWithoutBlockerInput[]
    connectOrCreate?: BlockedUserCreateOrConnectWithoutBlockerInput | BlockedUserCreateOrConnectWithoutBlockerInput[]
    upsert?: BlockedUserUpsertWithWhereUniqueWithoutBlockerInput | BlockedUserUpsertWithWhereUniqueWithoutBlockerInput[]
    createMany?: BlockedUserCreateManyBlockerInputEnvelope
    set?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    disconnect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    delete?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    connect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    update?: BlockedUserUpdateWithWhereUniqueWithoutBlockerInput | BlockedUserUpdateWithWhereUniqueWithoutBlockerInput[]
    updateMany?: BlockedUserUpdateManyWithWhereWithoutBlockerInput | BlockedUserUpdateManyWithWhereWithoutBlockerInput[]
    deleteMany?: BlockedUserScalarWhereInput | BlockedUserScalarWhereInput[]
  }

  export type BlockedUserUpdateManyWithoutBlockedNestedInput = {
    create?: XOR<BlockedUserCreateWithoutBlockedInput, BlockedUserUncheckedCreateWithoutBlockedInput> | BlockedUserCreateWithoutBlockedInput[] | BlockedUserUncheckedCreateWithoutBlockedInput[]
    connectOrCreate?: BlockedUserCreateOrConnectWithoutBlockedInput | BlockedUserCreateOrConnectWithoutBlockedInput[]
    upsert?: BlockedUserUpsertWithWhereUniqueWithoutBlockedInput | BlockedUserUpsertWithWhereUniqueWithoutBlockedInput[]
    createMany?: BlockedUserCreateManyBlockedInputEnvelope
    set?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    disconnect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    delete?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    connect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    update?: BlockedUserUpdateWithWhereUniqueWithoutBlockedInput | BlockedUserUpdateWithWhereUniqueWithoutBlockedInput[]
    updateMany?: BlockedUserUpdateManyWithWhereWithoutBlockedInput | BlockedUserUpdateManyWithWhereWithoutBlockedInput[]
    deleteMany?: BlockedUserScalarWhereInput | BlockedUserScalarWhereInput[]
  }

  export type ReferralUpdateManyWithoutReferrerNestedInput = {
    create?: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput> | ReferralCreateWithoutReferrerInput[] | ReferralUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferrerInput | ReferralCreateOrConnectWithoutReferrerInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutReferrerInput | ReferralUpsertWithWhereUniqueWithoutReferrerInput[]
    createMany?: ReferralCreateManyReferrerInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutReferrerInput | ReferralUpdateWithWhereUniqueWithoutReferrerInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutReferrerInput | ReferralUpdateManyWithWhereWithoutReferrerInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type ReferralUpdateManyWithoutReferredNestedInput = {
    create?: XOR<ReferralCreateWithoutReferredInput, ReferralUncheckedCreateWithoutReferredInput> | ReferralCreateWithoutReferredInput[] | ReferralUncheckedCreateWithoutReferredInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferredInput | ReferralCreateOrConnectWithoutReferredInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutReferredInput | ReferralUpsertWithWhereUniqueWithoutReferredInput[]
    createMany?: ReferralCreateManyReferredInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutReferredInput | ReferralUpdateWithWhereUniqueWithoutReferredInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutReferredInput | ReferralUpdateManyWithWhereWithoutReferredInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type UserUpdateOneWithoutReferredUsersNestedInput = {
    create?: XOR<UserCreateWithoutReferredUsersInput, UserUncheckedCreateWithoutReferredUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferredUsersInput
    upsert?: UserUpsertWithoutReferredUsersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReferredUsersInput, UserUpdateWithoutReferredUsersInput>, UserUncheckedUpdateWithoutReferredUsersInput>
  }

  export type UserUpdateManyWithoutReferrerNestedInput = {
    create?: XOR<UserCreateWithoutReferrerInput, UserUncheckedCreateWithoutReferrerInput> | UserCreateWithoutReferrerInput[] | UserUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutReferrerInput | UserCreateOrConnectWithoutReferrerInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutReferrerInput | UserUpsertWithWhereUniqueWithoutReferrerInput[]
    createMany?: UserCreateManyReferrerInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutReferrerInput | UserUpdateWithWhereUniqueWithoutReferrerInput[]
    updateMany?: UserUpdateManyWithWhereWithoutReferrerInput | UserUpdateManyWithWhereWithoutReferrerInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AchievementUpdateManyWithoutUserNestedInput = {
    create?: XOR<AchievementCreateWithoutUserInput, AchievementUncheckedCreateWithoutUserInput> | AchievementCreateWithoutUserInput[] | AchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutUserInput | AchievementCreateOrConnectWithoutUserInput[]
    upsert?: AchievementUpsertWithWhereUniqueWithoutUserInput | AchievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AchievementCreateManyUserInputEnvelope
    set?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    disconnect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    delete?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    update?: AchievementUpdateWithWhereUniqueWithoutUserInput | AchievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AchievementUpdateManyWithWhereWithoutUserInput | AchievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
  }

  export type HoroscopeUpdateManyWithoutUserNestedInput = {
    create?: XOR<HoroscopeCreateWithoutUserInput, HoroscopeUncheckedCreateWithoutUserInput> | HoroscopeCreateWithoutUserInput[] | HoroscopeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HoroscopeCreateOrConnectWithoutUserInput | HoroscopeCreateOrConnectWithoutUserInput[]
    upsert?: HoroscopeUpsertWithWhereUniqueWithoutUserInput | HoroscopeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: HoroscopeCreateManyUserInputEnvelope
    set?: HoroscopeWhereUniqueInput | HoroscopeWhereUniqueInput[]
    disconnect?: HoroscopeWhereUniqueInput | HoroscopeWhereUniqueInput[]
    delete?: HoroscopeWhereUniqueInput | HoroscopeWhereUniqueInput[]
    connect?: HoroscopeWhereUniqueInput | HoroscopeWhereUniqueInput[]
    update?: HoroscopeUpdateWithWhereUniqueWithoutUserInput | HoroscopeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: HoroscopeUpdateManyWithWhereWithoutUserInput | HoroscopeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: HoroscopeScalarWhereInput | HoroscopeScalarWhereInput[]
  }

  export type FamilyMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<FamilyMemberCreateWithoutUserInput, FamilyMemberUncheckedCreateWithoutUserInput> | FamilyMemberCreateWithoutUserInput[] | FamilyMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutUserInput | FamilyMemberCreateOrConnectWithoutUserInput[]
    upsert?: FamilyMemberUpsertWithWhereUniqueWithoutUserInput | FamilyMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FamilyMemberCreateManyUserInputEnvelope
    set?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    disconnect?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    delete?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    connect?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    update?: FamilyMemberUpdateWithWhereUniqueWithoutUserInput | FamilyMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FamilyMemberUpdateManyWithWhereWithoutUserInput | FamilyMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FamilyMemberScalarWhereInput | FamilyMemberScalarWhereInput[]
  }

  export type SuccessStoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<SuccessStoryCreateWithoutUserInput, SuccessStoryUncheckedCreateWithoutUserInput> | SuccessStoryCreateWithoutUserInput[] | SuccessStoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SuccessStoryCreateOrConnectWithoutUserInput | SuccessStoryCreateOrConnectWithoutUserInput[]
    upsert?: SuccessStoryUpsertWithWhereUniqueWithoutUserInput | SuccessStoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SuccessStoryCreateManyUserInputEnvelope
    set?: SuccessStoryWhereUniqueInput | SuccessStoryWhereUniqueInput[]
    disconnect?: SuccessStoryWhereUniqueInput | SuccessStoryWhereUniqueInput[]
    delete?: SuccessStoryWhereUniqueInput | SuccessStoryWhereUniqueInput[]
    connect?: SuccessStoryWhereUniqueInput | SuccessStoryWhereUniqueInput[]
    update?: SuccessStoryUpdateWithWhereUniqueWithoutUserInput | SuccessStoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SuccessStoryUpdateManyWithWhereWithoutUserInput | SuccessStoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SuccessStoryScalarWhereInput | SuccessStoryScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput> | DocumentCreateWithoutUserInput[] | DocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUserInput | DocumentCreateOrConnectWithoutUserInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutUserInput | DocumentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentCreateManyUserInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutUserInput | DocumentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutUserInput | DocumentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type VideoCallUpdateManyWithoutCallerNestedInput = {
    create?: XOR<VideoCallCreateWithoutCallerInput, VideoCallUncheckedCreateWithoutCallerInput> | VideoCallCreateWithoutCallerInput[] | VideoCallUncheckedCreateWithoutCallerInput[]
    connectOrCreate?: VideoCallCreateOrConnectWithoutCallerInput | VideoCallCreateOrConnectWithoutCallerInput[]
    upsert?: VideoCallUpsertWithWhereUniqueWithoutCallerInput | VideoCallUpsertWithWhereUniqueWithoutCallerInput[]
    createMany?: VideoCallCreateManyCallerInputEnvelope
    set?: VideoCallWhereUniqueInput | VideoCallWhereUniqueInput[]
    disconnect?: VideoCallWhereUniqueInput | VideoCallWhereUniqueInput[]
    delete?: VideoCallWhereUniqueInput | VideoCallWhereUniqueInput[]
    connect?: VideoCallWhereUniqueInput | VideoCallWhereUniqueInput[]
    update?: VideoCallUpdateWithWhereUniqueWithoutCallerInput | VideoCallUpdateWithWhereUniqueWithoutCallerInput[]
    updateMany?: VideoCallUpdateManyWithWhereWithoutCallerInput | VideoCallUpdateManyWithWhereWithoutCallerInput[]
    deleteMany?: VideoCallScalarWhereInput | VideoCallScalarWhereInput[]
  }

  export type VideoCallUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<VideoCallCreateWithoutParticipantInput, VideoCallUncheckedCreateWithoutParticipantInput> | VideoCallCreateWithoutParticipantInput[] | VideoCallUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: VideoCallCreateOrConnectWithoutParticipantInput | VideoCallCreateOrConnectWithoutParticipantInput[]
    upsert?: VideoCallUpsertWithWhereUniqueWithoutParticipantInput | VideoCallUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: VideoCallCreateManyParticipantInputEnvelope
    set?: VideoCallWhereUniqueInput | VideoCallWhereUniqueInput[]
    disconnect?: VideoCallWhereUniqueInput | VideoCallWhereUniqueInput[]
    delete?: VideoCallWhereUniqueInput | VideoCallWhereUniqueInput[]
    connect?: VideoCallWhereUniqueInput | VideoCallWhereUniqueInput[]
    update?: VideoCallUpdateWithWhereUniqueWithoutParticipantInput | VideoCallUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: VideoCallUpdateManyWithWhereWithoutParticipantInput | VideoCallUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: VideoCallScalarWhereInput | VideoCallScalarWhereInput[]
  }

  export type ForumPostUpdateManyWithoutUserNestedInput = {
    create?: XOR<ForumPostCreateWithoutUserInput, ForumPostUncheckedCreateWithoutUserInput> | ForumPostCreateWithoutUserInput[] | ForumPostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ForumPostCreateOrConnectWithoutUserInput | ForumPostCreateOrConnectWithoutUserInput[]
    upsert?: ForumPostUpsertWithWhereUniqueWithoutUserInput | ForumPostUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ForumPostCreateManyUserInputEnvelope
    set?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    disconnect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    delete?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    connect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    update?: ForumPostUpdateWithWhereUniqueWithoutUserInput | ForumPostUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ForumPostUpdateManyWithWhereWithoutUserInput | ForumPostUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ForumPostScalarWhereInput | ForumPostScalarWhereInput[]
  }

  export type ForumCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<ForumCommentCreateWithoutUserInput, ForumCommentUncheckedCreateWithoutUserInput> | ForumCommentCreateWithoutUserInput[] | ForumCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ForumCommentCreateOrConnectWithoutUserInput | ForumCommentCreateOrConnectWithoutUserInput[]
    upsert?: ForumCommentUpsertWithWhereUniqueWithoutUserInput | ForumCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ForumCommentCreateManyUserInputEnvelope
    set?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    disconnect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    delete?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    connect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    update?: ForumCommentUpdateWithWhereUniqueWithoutUserInput | ForumCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ForumCommentUpdateManyWithWhereWithoutUserInput | ForumCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ForumCommentScalarWhereInput | ForumCommentScalarWhereInput[]
  }

  export type GroupMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput> | GroupMemberCreateWithoutUserInput[] | GroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutUserInput | GroupMemberCreateOrConnectWithoutUserInput[]
    upsert?: GroupMemberUpsertWithWhereUniqueWithoutUserInput | GroupMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GroupMemberCreateManyUserInputEnvelope
    set?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    disconnect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    delete?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    update?: GroupMemberUpdateWithWhereUniqueWithoutUserInput | GroupMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GroupMemberUpdateManyWithWhereWithoutUserInput | GroupMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
  }

  export type EventParticipantUpdateManyWithoutUserNestedInput = {
    create?: XOR<EventParticipantCreateWithoutUserInput, EventParticipantUncheckedCreateWithoutUserInput> | EventParticipantCreateWithoutUserInput[] | EventParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventParticipantCreateOrConnectWithoutUserInput | EventParticipantCreateOrConnectWithoutUserInput[]
    upsert?: EventParticipantUpsertWithWhereUniqueWithoutUserInput | EventParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EventParticipantCreateManyUserInputEnvelope
    set?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
    disconnect?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
    delete?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
    connect?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
    update?: EventParticipantUpdateWithWhereUniqueWithoutUserInput | EventParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EventParticipantUpdateManyWithWhereWithoutUserInput | EventParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EventParticipantScalarWhereInput | EventParticipantScalarWhereInput[]
  }

  export type BlogPostUpdateManyWithoutUserNestedInput = {
    create?: XOR<BlogPostCreateWithoutUserInput, BlogPostUncheckedCreateWithoutUserInput> | BlogPostCreateWithoutUserInput[] | BlogPostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutUserInput | BlogPostCreateOrConnectWithoutUserInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutUserInput | BlogPostUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BlogPostCreateManyUserInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutUserInput | BlogPostUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutUserInput | BlogPostUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type MatchScoreUpdateManyWithoutUserNestedInput = {
    create?: XOR<MatchScoreCreateWithoutUserInput, MatchScoreUncheckedCreateWithoutUserInput> | MatchScoreCreateWithoutUserInput[] | MatchScoreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MatchScoreCreateOrConnectWithoutUserInput | MatchScoreCreateOrConnectWithoutUserInput[]
    upsert?: MatchScoreUpsertWithWhereUniqueWithoutUserInput | MatchScoreUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MatchScoreCreateManyUserInputEnvelope
    set?: MatchScoreWhereUniqueInput | MatchScoreWhereUniqueInput[]
    disconnect?: MatchScoreWhereUniqueInput | MatchScoreWhereUniqueInput[]
    delete?: MatchScoreWhereUniqueInput | MatchScoreWhereUniqueInput[]
    connect?: MatchScoreWhereUniqueInput | MatchScoreWhereUniqueInput[]
    update?: MatchScoreUpdateWithWhereUniqueWithoutUserInput | MatchScoreUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MatchScoreUpdateManyWithWhereWithoutUserInput | MatchScoreUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MatchScoreScalarWhereInput | MatchScoreScalarWhereInput[]
  }

  export type MatchScoreUpdateManyWithoutMatchedUserNestedInput = {
    create?: XOR<MatchScoreCreateWithoutMatchedUserInput, MatchScoreUncheckedCreateWithoutMatchedUserInput> | MatchScoreCreateWithoutMatchedUserInput[] | MatchScoreUncheckedCreateWithoutMatchedUserInput[]
    connectOrCreate?: MatchScoreCreateOrConnectWithoutMatchedUserInput | MatchScoreCreateOrConnectWithoutMatchedUserInput[]
    upsert?: MatchScoreUpsertWithWhereUniqueWithoutMatchedUserInput | MatchScoreUpsertWithWhereUniqueWithoutMatchedUserInput[]
    createMany?: MatchScoreCreateManyMatchedUserInputEnvelope
    set?: MatchScoreWhereUniqueInput | MatchScoreWhereUniqueInput[]
    disconnect?: MatchScoreWhereUniqueInput | MatchScoreWhereUniqueInput[]
    delete?: MatchScoreWhereUniqueInput | MatchScoreWhereUniqueInput[]
    connect?: MatchScoreWhereUniqueInput | MatchScoreWhereUniqueInput[]
    update?: MatchScoreUpdateWithWhereUniqueWithoutMatchedUserInput | MatchScoreUpdateWithWhereUniqueWithoutMatchedUserInput[]
    updateMany?: MatchScoreUpdateManyWithWhereWithoutMatchedUserInput | MatchScoreUpdateManyWithWhereWithoutMatchedUserInput[]
    deleteMany?: MatchScoreScalarWhereInput | MatchScoreScalarWhereInput[]
  }

  export type SearchHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<SearchHistoryCreateWithoutUserInput, SearchHistoryUncheckedCreateWithoutUserInput> | SearchHistoryCreateWithoutUserInput[] | SearchHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SearchHistoryCreateOrConnectWithoutUserInput | SearchHistoryCreateOrConnectWithoutUserInput[]
    upsert?: SearchHistoryUpsertWithWhereUniqueWithoutUserInput | SearchHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SearchHistoryCreateManyUserInputEnvelope
    set?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    disconnect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    delete?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    connect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    update?: SearchHistoryUpdateWithWhereUniqueWithoutUserInput | SearchHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SearchHistoryUpdateManyWithWhereWithoutUserInput | SearchHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SearchHistoryScalarWhereInput | SearchHistoryScalarWhereInput[]
  }

  export type MessageTemplateUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageTemplateCreateWithoutUserInput, MessageTemplateUncheckedCreateWithoutUserInput> | MessageTemplateCreateWithoutUserInput[] | MessageTemplateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageTemplateCreateOrConnectWithoutUserInput | MessageTemplateCreateOrConnectWithoutUserInput[]
    upsert?: MessageTemplateUpsertWithWhereUniqueWithoutUserInput | MessageTemplateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageTemplateCreateManyUserInputEnvelope
    set?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
    disconnect?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
    delete?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
    connect?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
    update?: MessageTemplateUpdateWithWhereUniqueWithoutUserInput | MessageTemplateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageTemplateUpdateManyWithWhereWithoutUserInput | MessageTemplateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageTemplateScalarWhereInput | MessageTemplateScalarWhereInput[]
  }

  export type IceBreakerUpdateManyWithoutUserNestedInput = {
    create?: XOR<IceBreakerCreateWithoutUserInput, IceBreakerUncheckedCreateWithoutUserInput> | IceBreakerCreateWithoutUserInput[] | IceBreakerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IceBreakerCreateOrConnectWithoutUserInput | IceBreakerCreateOrConnectWithoutUserInput[]
    upsert?: IceBreakerUpsertWithWhereUniqueWithoutUserInput | IceBreakerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: IceBreakerCreateManyUserInputEnvelope
    set?: IceBreakerWhereUniqueInput | IceBreakerWhereUniqueInput[]
    disconnect?: IceBreakerWhereUniqueInput | IceBreakerWhereUniqueInput[]
    delete?: IceBreakerWhereUniqueInput | IceBreakerWhereUniqueInput[]
    connect?: IceBreakerWhereUniqueInput | IceBreakerWhereUniqueInput[]
    update?: IceBreakerUpdateWithWhereUniqueWithoutUserInput | IceBreakerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: IceBreakerUpdateManyWithWhereWithoutUserInput | IceBreakerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: IceBreakerScalarWhereInput | IceBreakerScalarWhereInput[]
  }

  export type ActivityUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutUserInput | ActivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutUserInput | ActivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutUserInput | ActivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type LeaderboardUpdateManyWithoutUserNestedInput = {
    create?: XOR<LeaderboardCreateWithoutUserInput, LeaderboardUncheckedCreateWithoutUserInput> | LeaderboardCreateWithoutUserInput[] | LeaderboardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaderboardCreateOrConnectWithoutUserInput | LeaderboardCreateOrConnectWithoutUserInput[]
    upsert?: LeaderboardUpsertWithWhereUniqueWithoutUserInput | LeaderboardUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LeaderboardCreateManyUserInputEnvelope
    set?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
    disconnect?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
    delete?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
    connect?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
    update?: LeaderboardUpdateWithWhereUniqueWithoutUserInput | LeaderboardUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LeaderboardUpdateManyWithWhereWithoutUserInput | LeaderboardUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LeaderboardScalarWhereInput | LeaderboardScalarWhereInput[]
  }

  export type WishlistUpdateManyWithoutUserNestedInput = {
    create?: XOR<WishlistCreateWithoutUserInput, WishlistUncheckedCreateWithoutUserInput> | WishlistCreateWithoutUserInput[] | WishlistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WishlistCreateOrConnectWithoutUserInput | WishlistCreateOrConnectWithoutUserInput[]
    upsert?: WishlistUpsertWithWhereUniqueWithoutUserInput | WishlistUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WishlistCreateManyUserInputEnvelope
    set?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    disconnect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    delete?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    connect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    update?: WishlistUpdateWithWhereUniqueWithoutUserInput | WishlistUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WishlistUpdateManyWithWhereWithoutUserInput | WishlistUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WishlistScalarWhereInput | WishlistScalarWhereInput[]
  }

  export type ProfileExportUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProfileExportCreateWithoutUserInput, ProfileExportUncheckedCreateWithoutUserInput> | ProfileExportCreateWithoutUserInput[] | ProfileExportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfileExportCreateOrConnectWithoutUserInput | ProfileExportCreateOrConnectWithoutUserInput[]
    upsert?: ProfileExportUpsertWithWhereUniqueWithoutUserInput | ProfileExportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProfileExportCreateManyUserInputEnvelope
    set?: ProfileExportWhereUniqueInput | ProfileExportWhereUniqueInput[]
    disconnect?: ProfileExportWhereUniqueInput | ProfileExportWhereUniqueInput[]
    delete?: ProfileExportWhereUniqueInput | ProfileExportWhereUniqueInput[]
    connect?: ProfileExportWhereUniqueInput | ProfileExportWhereUniqueInput[]
    update?: ProfileExportUpdateWithWhereUniqueWithoutUserInput | ProfileExportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProfileExportUpdateManyWithWhereWithoutUserInput | ProfileExportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProfileExportScalarWhereInput | ProfileExportScalarWhereInput[]
  }

  export type ServiceUpdateManyWithoutUserNestedInput = {
    create?: XOR<ServiceCreateWithoutUserInput, ServiceUncheckedCreateWithoutUserInput> | ServiceCreateWithoutUserInput[] | ServiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutUserInput | ServiceCreateOrConnectWithoutUserInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutUserInput | ServiceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ServiceCreateManyUserInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutUserInput | ServiceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutUserInput | ServiceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ServiceBookingUpdateManyWithoutUserNestedInput = {
    create?: XOR<ServiceBookingCreateWithoutUserInput, ServiceBookingUncheckedCreateWithoutUserInput> | ServiceBookingCreateWithoutUserInput[] | ServiceBookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceBookingCreateOrConnectWithoutUserInput | ServiceBookingCreateOrConnectWithoutUserInput[]
    upsert?: ServiceBookingUpsertWithWhereUniqueWithoutUserInput | ServiceBookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ServiceBookingCreateManyUserInputEnvelope
    set?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    disconnect?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    delete?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    connect?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    update?: ServiceBookingUpdateWithWhereUniqueWithoutUserInput | ServiceBookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ServiceBookingUpdateManyWithWhereWithoutUserInput | ServiceBookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ServiceBookingScalarWhereInput | ServiceBookingScalarWhereInput[]
  }

  export type ProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type InterestUncheckedUpdateManyWithoutFromUserNestedInput = {
    create?: XOR<InterestCreateWithoutFromUserInput, InterestUncheckedCreateWithoutFromUserInput> | InterestCreateWithoutFromUserInput[] | InterestUncheckedCreateWithoutFromUserInput[]
    connectOrCreate?: InterestCreateOrConnectWithoutFromUserInput | InterestCreateOrConnectWithoutFromUserInput[]
    upsert?: InterestUpsertWithWhereUniqueWithoutFromUserInput | InterestUpsertWithWhereUniqueWithoutFromUserInput[]
    createMany?: InterestCreateManyFromUserInputEnvelope
    set?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
    disconnect?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
    delete?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
    connect?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
    update?: InterestUpdateWithWhereUniqueWithoutFromUserInput | InterestUpdateWithWhereUniqueWithoutFromUserInput[]
    updateMany?: InterestUpdateManyWithWhereWithoutFromUserInput | InterestUpdateManyWithWhereWithoutFromUserInput[]
    deleteMany?: InterestScalarWhereInput | InterestScalarWhereInput[]
  }

  export type InterestUncheckedUpdateManyWithoutToUserNestedInput = {
    create?: XOR<InterestCreateWithoutToUserInput, InterestUncheckedCreateWithoutToUserInput> | InterestCreateWithoutToUserInput[] | InterestUncheckedCreateWithoutToUserInput[]
    connectOrCreate?: InterestCreateOrConnectWithoutToUserInput | InterestCreateOrConnectWithoutToUserInput[]
    upsert?: InterestUpsertWithWhereUniqueWithoutToUserInput | InterestUpsertWithWhereUniqueWithoutToUserInput[]
    createMany?: InterestCreateManyToUserInputEnvelope
    set?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
    disconnect?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
    delete?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
    connect?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
    update?: InterestUpdateWithWhereUniqueWithoutToUserInput | InterestUpdateWithWhereUniqueWithoutToUserInput[]
    updateMany?: InterestUpdateManyWithWhereWithoutToUserInput | InterestUpdateManyWithWhereWithoutToUserInput[]
    deleteMany?: InterestScalarWhereInput | InterestScalarWhereInput[]
  }

  export type ChatUncheckedUpdateManyWithoutUser1NestedInput = {
    create?: XOR<ChatCreateWithoutUser1Input, ChatUncheckedCreateWithoutUser1Input> | ChatCreateWithoutUser1Input[] | ChatUncheckedCreateWithoutUser1Input[]
    connectOrCreate?: ChatCreateOrConnectWithoutUser1Input | ChatCreateOrConnectWithoutUser1Input[]
    upsert?: ChatUpsertWithWhereUniqueWithoutUser1Input | ChatUpsertWithWhereUniqueWithoutUser1Input[]
    createMany?: ChatCreateManyUser1InputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutUser1Input | ChatUpdateWithWhereUniqueWithoutUser1Input[]
    updateMany?: ChatUpdateManyWithWhereWithoutUser1Input | ChatUpdateManyWithWhereWithoutUser1Input[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type ChatUncheckedUpdateManyWithoutUser2NestedInput = {
    create?: XOR<ChatCreateWithoutUser2Input, ChatUncheckedCreateWithoutUser2Input> | ChatCreateWithoutUser2Input[] | ChatUncheckedCreateWithoutUser2Input[]
    connectOrCreate?: ChatCreateOrConnectWithoutUser2Input | ChatCreateOrConnectWithoutUser2Input[]
    upsert?: ChatUpsertWithWhereUniqueWithoutUser2Input | ChatUpsertWithWhereUniqueWithoutUser2Input[]
    createMany?: ChatCreateManyUser2InputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutUser2Input | ChatUpdateWithWhereUniqueWithoutUser2Input[]
    updateMany?: ChatUpdateManyWithWhereWithoutUser2Input | ChatUpdateManyWithWhereWithoutUser2Input[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutUserInput | SubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutUserInput | SubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutUserInput | SubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput = {
    create?: XOR<ProfileViewCreateWithoutViewedByInput, ProfileViewUncheckedCreateWithoutViewedByInput> | ProfileViewCreateWithoutViewedByInput[] | ProfileViewUncheckedCreateWithoutViewedByInput[]
    connectOrCreate?: ProfileViewCreateOrConnectWithoutViewedByInput | ProfileViewCreateOrConnectWithoutViewedByInput[]
    upsert?: ProfileViewUpsertWithWhereUniqueWithoutViewedByInput | ProfileViewUpsertWithWhereUniqueWithoutViewedByInput[]
    createMany?: ProfileViewCreateManyViewedByInputEnvelope
    set?: ProfileViewWhereUniqueInput | ProfileViewWhereUniqueInput[]
    disconnect?: ProfileViewWhereUniqueInput | ProfileViewWhereUniqueInput[]
    delete?: ProfileViewWhereUniqueInput | ProfileViewWhereUniqueInput[]
    connect?: ProfileViewWhereUniqueInput | ProfileViewWhereUniqueInput[]
    update?: ProfileViewUpdateWithWhereUniqueWithoutViewedByInput | ProfileViewUpdateWithWhereUniqueWithoutViewedByInput[]
    updateMany?: ProfileViewUpdateManyWithWhereWithoutViewedByInput | ProfileViewUpdateManyWithWhereWithoutViewedByInput[]
    deleteMany?: ProfileViewScalarWhereInput | ProfileViewScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ShortlistUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ShortlistCreateWithoutUserInput, ShortlistUncheckedCreateWithoutUserInput> | ShortlistCreateWithoutUserInput[] | ShortlistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShortlistCreateOrConnectWithoutUserInput | ShortlistCreateOrConnectWithoutUserInput[]
    upsert?: ShortlistUpsertWithWhereUniqueWithoutUserInput | ShortlistUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ShortlistCreateManyUserInputEnvelope
    set?: ShortlistWhereUniqueInput | ShortlistWhereUniqueInput[]
    disconnect?: ShortlistWhereUniqueInput | ShortlistWhereUniqueInput[]
    delete?: ShortlistWhereUniqueInput | ShortlistWhereUniqueInput[]
    connect?: ShortlistWhereUniqueInput | ShortlistWhereUniqueInput[]
    update?: ShortlistUpdateWithWhereUniqueWithoutUserInput | ShortlistUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ShortlistUpdateManyWithWhereWithoutUserInput | ShortlistUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ShortlistScalarWhereInput | ShortlistScalarWhereInput[]
  }

  export type BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput = {
    create?: XOR<BlockedUserCreateWithoutBlockerInput, BlockedUserUncheckedCreateWithoutBlockerInput> | BlockedUserCreateWithoutBlockerInput[] | BlockedUserUncheckedCreateWithoutBlockerInput[]
    connectOrCreate?: BlockedUserCreateOrConnectWithoutBlockerInput | BlockedUserCreateOrConnectWithoutBlockerInput[]
    upsert?: BlockedUserUpsertWithWhereUniqueWithoutBlockerInput | BlockedUserUpsertWithWhereUniqueWithoutBlockerInput[]
    createMany?: BlockedUserCreateManyBlockerInputEnvelope
    set?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    disconnect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    delete?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    connect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    update?: BlockedUserUpdateWithWhereUniqueWithoutBlockerInput | BlockedUserUpdateWithWhereUniqueWithoutBlockerInput[]
    updateMany?: BlockedUserUpdateManyWithWhereWithoutBlockerInput | BlockedUserUpdateManyWithWhereWithoutBlockerInput[]
    deleteMany?: BlockedUserScalarWhereInput | BlockedUserScalarWhereInput[]
  }

  export type BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput = {
    create?: XOR<BlockedUserCreateWithoutBlockedInput, BlockedUserUncheckedCreateWithoutBlockedInput> | BlockedUserCreateWithoutBlockedInput[] | BlockedUserUncheckedCreateWithoutBlockedInput[]
    connectOrCreate?: BlockedUserCreateOrConnectWithoutBlockedInput | BlockedUserCreateOrConnectWithoutBlockedInput[]
    upsert?: BlockedUserUpsertWithWhereUniqueWithoutBlockedInput | BlockedUserUpsertWithWhereUniqueWithoutBlockedInput[]
    createMany?: BlockedUserCreateManyBlockedInputEnvelope
    set?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    disconnect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    delete?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    connect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    update?: BlockedUserUpdateWithWhereUniqueWithoutBlockedInput | BlockedUserUpdateWithWhereUniqueWithoutBlockedInput[]
    updateMany?: BlockedUserUpdateManyWithWhereWithoutBlockedInput | BlockedUserUpdateManyWithWhereWithoutBlockedInput[]
    deleteMany?: BlockedUserScalarWhereInput | BlockedUserScalarWhereInput[]
  }

  export type ReferralUncheckedUpdateManyWithoutReferrerNestedInput = {
    create?: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput> | ReferralCreateWithoutReferrerInput[] | ReferralUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferrerInput | ReferralCreateOrConnectWithoutReferrerInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutReferrerInput | ReferralUpsertWithWhereUniqueWithoutReferrerInput[]
    createMany?: ReferralCreateManyReferrerInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutReferrerInput | ReferralUpdateWithWhereUniqueWithoutReferrerInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutReferrerInput | ReferralUpdateManyWithWhereWithoutReferrerInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type ReferralUncheckedUpdateManyWithoutReferredNestedInput = {
    create?: XOR<ReferralCreateWithoutReferredInput, ReferralUncheckedCreateWithoutReferredInput> | ReferralCreateWithoutReferredInput[] | ReferralUncheckedCreateWithoutReferredInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferredInput | ReferralCreateOrConnectWithoutReferredInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutReferredInput | ReferralUpsertWithWhereUniqueWithoutReferredInput[]
    createMany?: ReferralCreateManyReferredInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutReferredInput | ReferralUpdateWithWhereUniqueWithoutReferredInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutReferredInput | ReferralUpdateManyWithWhereWithoutReferredInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutReferrerNestedInput = {
    create?: XOR<UserCreateWithoutReferrerInput, UserUncheckedCreateWithoutReferrerInput> | UserCreateWithoutReferrerInput[] | UserUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutReferrerInput | UserCreateOrConnectWithoutReferrerInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutReferrerInput | UserUpsertWithWhereUniqueWithoutReferrerInput[]
    createMany?: UserCreateManyReferrerInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutReferrerInput | UserUpdateWithWhereUniqueWithoutReferrerInput[]
    updateMany?: UserUpdateManyWithWhereWithoutReferrerInput | UserUpdateManyWithWhereWithoutReferrerInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AchievementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AchievementCreateWithoutUserInput, AchievementUncheckedCreateWithoutUserInput> | AchievementCreateWithoutUserInput[] | AchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutUserInput | AchievementCreateOrConnectWithoutUserInput[]
    upsert?: AchievementUpsertWithWhereUniqueWithoutUserInput | AchievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AchievementCreateManyUserInputEnvelope
    set?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    disconnect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    delete?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    update?: AchievementUpdateWithWhereUniqueWithoutUserInput | AchievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AchievementUpdateManyWithWhereWithoutUserInput | AchievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
  }

  export type HoroscopeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<HoroscopeCreateWithoutUserInput, HoroscopeUncheckedCreateWithoutUserInput> | HoroscopeCreateWithoutUserInput[] | HoroscopeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HoroscopeCreateOrConnectWithoutUserInput | HoroscopeCreateOrConnectWithoutUserInput[]
    upsert?: HoroscopeUpsertWithWhereUniqueWithoutUserInput | HoroscopeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: HoroscopeCreateManyUserInputEnvelope
    set?: HoroscopeWhereUniqueInput | HoroscopeWhereUniqueInput[]
    disconnect?: HoroscopeWhereUniqueInput | HoroscopeWhereUniqueInput[]
    delete?: HoroscopeWhereUniqueInput | HoroscopeWhereUniqueInput[]
    connect?: HoroscopeWhereUniqueInput | HoroscopeWhereUniqueInput[]
    update?: HoroscopeUpdateWithWhereUniqueWithoutUserInput | HoroscopeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: HoroscopeUpdateManyWithWhereWithoutUserInput | HoroscopeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: HoroscopeScalarWhereInput | HoroscopeScalarWhereInput[]
  }

  export type FamilyMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FamilyMemberCreateWithoutUserInput, FamilyMemberUncheckedCreateWithoutUserInput> | FamilyMemberCreateWithoutUserInput[] | FamilyMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutUserInput | FamilyMemberCreateOrConnectWithoutUserInput[]
    upsert?: FamilyMemberUpsertWithWhereUniqueWithoutUserInput | FamilyMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FamilyMemberCreateManyUserInputEnvelope
    set?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    disconnect?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    delete?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    connect?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    update?: FamilyMemberUpdateWithWhereUniqueWithoutUserInput | FamilyMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FamilyMemberUpdateManyWithWhereWithoutUserInput | FamilyMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FamilyMemberScalarWhereInput | FamilyMemberScalarWhereInput[]
  }

  export type SuccessStoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SuccessStoryCreateWithoutUserInput, SuccessStoryUncheckedCreateWithoutUserInput> | SuccessStoryCreateWithoutUserInput[] | SuccessStoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SuccessStoryCreateOrConnectWithoutUserInput | SuccessStoryCreateOrConnectWithoutUserInput[]
    upsert?: SuccessStoryUpsertWithWhereUniqueWithoutUserInput | SuccessStoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SuccessStoryCreateManyUserInputEnvelope
    set?: SuccessStoryWhereUniqueInput | SuccessStoryWhereUniqueInput[]
    disconnect?: SuccessStoryWhereUniqueInput | SuccessStoryWhereUniqueInput[]
    delete?: SuccessStoryWhereUniqueInput | SuccessStoryWhereUniqueInput[]
    connect?: SuccessStoryWhereUniqueInput | SuccessStoryWhereUniqueInput[]
    update?: SuccessStoryUpdateWithWhereUniqueWithoutUserInput | SuccessStoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SuccessStoryUpdateManyWithWhereWithoutUserInput | SuccessStoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SuccessStoryScalarWhereInput | SuccessStoryScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput> | DocumentCreateWithoutUserInput[] | DocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUserInput | DocumentCreateOrConnectWithoutUserInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutUserInput | DocumentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentCreateManyUserInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutUserInput | DocumentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutUserInput | DocumentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type VideoCallUncheckedUpdateManyWithoutCallerNestedInput = {
    create?: XOR<VideoCallCreateWithoutCallerInput, VideoCallUncheckedCreateWithoutCallerInput> | VideoCallCreateWithoutCallerInput[] | VideoCallUncheckedCreateWithoutCallerInput[]
    connectOrCreate?: VideoCallCreateOrConnectWithoutCallerInput | VideoCallCreateOrConnectWithoutCallerInput[]
    upsert?: VideoCallUpsertWithWhereUniqueWithoutCallerInput | VideoCallUpsertWithWhereUniqueWithoutCallerInput[]
    createMany?: VideoCallCreateManyCallerInputEnvelope
    set?: VideoCallWhereUniqueInput | VideoCallWhereUniqueInput[]
    disconnect?: VideoCallWhereUniqueInput | VideoCallWhereUniqueInput[]
    delete?: VideoCallWhereUniqueInput | VideoCallWhereUniqueInput[]
    connect?: VideoCallWhereUniqueInput | VideoCallWhereUniqueInput[]
    update?: VideoCallUpdateWithWhereUniqueWithoutCallerInput | VideoCallUpdateWithWhereUniqueWithoutCallerInput[]
    updateMany?: VideoCallUpdateManyWithWhereWithoutCallerInput | VideoCallUpdateManyWithWhereWithoutCallerInput[]
    deleteMany?: VideoCallScalarWhereInput | VideoCallScalarWhereInput[]
  }

  export type VideoCallUncheckedUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<VideoCallCreateWithoutParticipantInput, VideoCallUncheckedCreateWithoutParticipantInput> | VideoCallCreateWithoutParticipantInput[] | VideoCallUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: VideoCallCreateOrConnectWithoutParticipantInput | VideoCallCreateOrConnectWithoutParticipantInput[]
    upsert?: VideoCallUpsertWithWhereUniqueWithoutParticipantInput | VideoCallUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: VideoCallCreateManyParticipantInputEnvelope
    set?: VideoCallWhereUniqueInput | VideoCallWhereUniqueInput[]
    disconnect?: VideoCallWhereUniqueInput | VideoCallWhereUniqueInput[]
    delete?: VideoCallWhereUniqueInput | VideoCallWhereUniqueInput[]
    connect?: VideoCallWhereUniqueInput | VideoCallWhereUniqueInput[]
    update?: VideoCallUpdateWithWhereUniqueWithoutParticipantInput | VideoCallUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: VideoCallUpdateManyWithWhereWithoutParticipantInput | VideoCallUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: VideoCallScalarWhereInput | VideoCallScalarWhereInput[]
  }

  export type ForumPostUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ForumPostCreateWithoutUserInput, ForumPostUncheckedCreateWithoutUserInput> | ForumPostCreateWithoutUserInput[] | ForumPostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ForumPostCreateOrConnectWithoutUserInput | ForumPostCreateOrConnectWithoutUserInput[]
    upsert?: ForumPostUpsertWithWhereUniqueWithoutUserInput | ForumPostUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ForumPostCreateManyUserInputEnvelope
    set?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    disconnect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    delete?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    connect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    update?: ForumPostUpdateWithWhereUniqueWithoutUserInput | ForumPostUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ForumPostUpdateManyWithWhereWithoutUserInput | ForumPostUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ForumPostScalarWhereInput | ForumPostScalarWhereInput[]
  }

  export type ForumCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ForumCommentCreateWithoutUserInput, ForumCommentUncheckedCreateWithoutUserInput> | ForumCommentCreateWithoutUserInput[] | ForumCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ForumCommentCreateOrConnectWithoutUserInput | ForumCommentCreateOrConnectWithoutUserInput[]
    upsert?: ForumCommentUpsertWithWhereUniqueWithoutUserInput | ForumCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ForumCommentCreateManyUserInputEnvelope
    set?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    disconnect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    delete?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    connect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    update?: ForumCommentUpdateWithWhereUniqueWithoutUserInput | ForumCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ForumCommentUpdateManyWithWhereWithoutUserInput | ForumCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ForumCommentScalarWhereInput | ForumCommentScalarWhereInput[]
  }

  export type GroupMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput> | GroupMemberCreateWithoutUserInput[] | GroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutUserInput | GroupMemberCreateOrConnectWithoutUserInput[]
    upsert?: GroupMemberUpsertWithWhereUniqueWithoutUserInput | GroupMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GroupMemberCreateManyUserInputEnvelope
    set?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    disconnect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    delete?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    update?: GroupMemberUpdateWithWhereUniqueWithoutUserInput | GroupMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GroupMemberUpdateManyWithWhereWithoutUserInput | GroupMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
  }

  export type EventParticipantUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EventParticipantCreateWithoutUserInput, EventParticipantUncheckedCreateWithoutUserInput> | EventParticipantCreateWithoutUserInput[] | EventParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventParticipantCreateOrConnectWithoutUserInput | EventParticipantCreateOrConnectWithoutUserInput[]
    upsert?: EventParticipantUpsertWithWhereUniqueWithoutUserInput | EventParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EventParticipantCreateManyUserInputEnvelope
    set?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
    disconnect?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
    delete?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
    connect?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
    update?: EventParticipantUpdateWithWhereUniqueWithoutUserInput | EventParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EventParticipantUpdateManyWithWhereWithoutUserInput | EventParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EventParticipantScalarWhereInput | EventParticipantScalarWhereInput[]
  }

  export type BlogPostUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BlogPostCreateWithoutUserInput, BlogPostUncheckedCreateWithoutUserInput> | BlogPostCreateWithoutUserInput[] | BlogPostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutUserInput | BlogPostCreateOrConnectWithoutUserInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutUserInput | BlogPostUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BlogPostCreateManyUserInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutUserInput | BlogPostUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutUserInput | BlogPostUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type MatchScoreUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MatchScoreCreateWithoutUserInput, MatchScoreUncheckedCreateWithoutUserInput> | MatchScoreCreateWithoutUserInput[] | MatchScoreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MatchScoreCreateOrConnectWithoutUserInput | MatchScoreCreateOrConnectWithoutUserInput[]
    upsert?: MatchScoreUpsertWithWhereUniqueWithoutUserInput | MatchScoreUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MatchScoreCreateManyUserInputEnvelope
    set?: MatchScoreWhereUniqueInput | MatchScoreWhereUniqueInput[]
    disconnect?: MatchScoreWhereUniqueInput | MatchScoreWhereUniqueInput[]
    delete?: MatchScoreWhereUniqueInput | MatchScoreWhereUniqueInput[]
    connect?: MatchScoreWhereUniqueInput | MatchScoreWhereUniqueInput[]
    update?: MatchScoreUpdateWithWhereUniqueWithoutUserInput | MatchScoreUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MatchScoreUpdateManyWithWhereWithoutUserInput | MatchScoreUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MatchScoreScalarWhereInput | MatchScoreScalarWhereInput[]
  }

  export type MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput = {
    create?: XOR<MatchScoreCreateWithoutMatchedUserInput, MatchScoreUncheckedCreateWithoutMatchedUserInput> | MatchScoreCreateWithoutMatchedUserInput[] | MatchScoreUncheckedCreateWithoutMatchedUserInput[]
    connectOrCreate?: MatchScoreCreateOrConnectWithoutMatchedUserInput | MatchScoreCreateOrConnectWithoutMatchedUserInput[]
    upsert?: MatchScoreUpsertWithWhereUniqueWithoutMatchedUserInput | MatchScoreUpsertWithWhereUniqueWithoutMatchedUserInput[]
    createMany?: MatchScoreCreateManyMatchedUserInputEnvelope
    set?: MatchScoreWhereUniqueInput | MatchScoreWhereUniqueInput[]
    disconnect?: MatchScoreWhereUniqueInput | MatchScoreWhereUniqueInput[]
    delete?: MatchScoreWhereUniqueInput | MatchScoreWhereUniqueInput[]
    connect?: MatchScoreWhereUniqueInput | MatchScoreWhereUniqueInput[]
    update?: MatchScoreUpdateWithWhereUniqueWithoutMatchedUserInput | MatchScoreUpdateWithWhereUniqueWithoutMatchedUserInput[]
    updateMany?: MatchScoreUpdateManyWithWhereWithoutMatchedUserInput | MatchScoreUpdateManyWithWhereWithoutMatchedUserInput[]
    deleteMany?: MatchScoreScalarWhereInput | MatchScoreScalarWhereInput[]
  }

  export type SearchHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SearchHistoryCreateWithoutUserInput, SearchHistoryUncheckedCreateWithoutUserInput> | SearchHistoryCreateWithoutUserInput[] | SearchHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SearchHistoryCreateOrConnectWithoutUserInput | SearchHistoryCreateOrConnectWithoutUserInput[]
    upsert?: SearchHistoryUpsertWithWhereUniqueWithoutUserInput | SearchHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SearchHistoryCreateManyUserInputEnvelope
    set?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    disconnect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    delete?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    connect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    update?: SearchHistoryUpdateWithWhereUniqueWithoutUserInput | SearchHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SearchHistoryUpdateManyWithWhereWithoutUserInput | SearchHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SearchHistoryScalarWhereInput | SearchHistoryScalarWhereInput[]
  }

  export type MessageTemplateUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageTemplateCreateWithoutUserInput, MessageTemplateUncheckedCreateWithoutUserInput> | MessageTemplateCreateWithoutUserInput[] | MessageTemplateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageTemplateCreateOrConnectWithoutUserInput | MessageTemplateCreateOrConnectWithoutUserInput[]
    upsert?: MessageTemplateUpsertWithWhereUniqueWithoutUserInput | MessageTemplateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageTemplateCreateManyUserInputEnvelope
    set?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
    disconnect?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
    delete?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
    connect?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
    update?: MessageTemplateUpdateWithWhereUniqueWithoutUserInput | MessageTemplateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageTemplateUpdateManyWithWhereWithoutUserInput | MessageTemplateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageTemplateScalarWhereInput | MessageTemplateScalarWhereInput[]
  }

  export type IceBreakerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<IceBreakerCreateWithoutUserInput, IceBreakerUncheckedCreateWithoutUserInput> | IceBreakerCreateWithoutUserInput[] | IceBreakerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IceBreakerCreateOrConnectWithoutUserInput | IceBreakerCreateOrConnectWithoutUserInput[]
    upsert?: IceBreakerUpsertWithWhereUniqueWithoutUserInput | IceBreakerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: IceBreakerCreateManyUserInputEnvelope
    set?: IceBreakerWhereUniqueInput | IceBreakerWhereUniqueInput[]
    disconnect?: IceBreakerWhereUniqueInput | IceBreakerWhereUniqueInput[]
    delete?: IceBreakerWhereUniqueInput | IceBreakerWhereUniqueInput[]
    connect?: IceBreakerWhereUniqueInput | IceBreakerWhereUniqueInput[]
    update?: IceBreakerUpdateWithWhereUniqueWithoutUserInput | IceBreakerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: IceBreakerUpdateManyWithWhereWithoutUserInput | IceBreakerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: IceBreakerScalarWhereInput | IceBreakerScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutUserInput | ActivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutUserInput | ActivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutUserInput | ActivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type LeaderboardUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LeaderboardCreateWithoutUserInput, LeaderboardUncheckedCreateWithoutUserInput> | LeaderboardCreateWithoutUserInput[] | LeaderboardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaderboardCreateOrConnectWithoutUserInput | LeaderboardCreateOrConnectWithoutUserInput[]
    upsert?: LeaderboardUpsertWithWhereUniqueWithoutUserInput | LeaderboardUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LeaderboardCreateManyUserInputEnvelope
    set?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
    disconnect?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
    delete?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
    connect?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
    update?: LeaderboardUpdateWithWhereUniqueWithoutUserInput | LeaderboardUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LeaderboardUpdateManyWithWhereWithoutUserInput | LeaderboardUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LeaderboardScalarWhereInput | LeaderboardScalarWhereInput[]
  }

  export type WishlistUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WishlistCreateWithoutUserInput, WishlistUncheckedCreateWithoutUserInput> | WishlistCreateWithoutUserInput[] | WishlistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WishlistCreateOrConnectWithoutUserInput | WishlistCreateOrConnectWithoutUserInput[]
    upsert?: WishlistUpsertWithWhereUniqueWithoutUserInput | WishlistUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WishlistCreateManyUserInputEnvelope
    set?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    disconnect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    delete?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    connect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    update?: WishlistUpdateWithWhereUniqueWithoutUserInput | WishlistUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WishlistUpdateManyWithWhereWithoutUserInput | WishlistUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WishlistScalarWhereInput | WishlistScalarWhereInput[]
  }

  export type ProfileExportUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProfileExportCreateWithoutUserInput, ProfileExportUncheckedCreateWithoutUserInput> | ProfileExportCreateWithoutUserInput[] | ProfileExportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfileExportCreateOrConnectWithoutUserInput | ProfileExportCreateOrConnectWithoutUserInput[]
    upsert?: ProfileExportUpsertWithWhereUniqueWithoutUserInput | ProfileExportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProfileExportCreateManyUserInputEnvelope
    set?: ProfileExportWhereUniqueInput | ProfileExportWhereUniqueInput[]
    disconnect?: ProfileExportWhereUniqueInput | ProfileExportWhereUniqueInput[]
    delete?: ProfileExportWhereUniqueInput | ProfileExportWhereUniqueInput[]
    connect?: ProfileExportWhereUniqueInput | ProfileExportWhereUniqueInput[]
    update?: ProfileExportUpdateWithWhereUniqueWithoutUserInput | ProfileExportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProfileExportUpdateManyWithWhereWithoutUserInput | ProfileExportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProfileExportScalarWhereInput | ProfileExportScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ServiceCreateWithoutUserInput, ServiceUncheckedCreateWithoutUserInput> | ServiceCreateWithoutUserInput[] | ServiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutUserInput | ServiceCreateOrConnectWithoutUserInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutUserInput | ServiceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ServiceCreateManyUserInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutUserInput | ServiceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutUserInput | ServiceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ServiceBookingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ServiceBookingCreateWithoutUserInput, ServiceBookingUncheckedCreateWithoutUserInput> | ServiceBookingCreateWithoutUserInput[] | ServiceBookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceBookingCreateOrConnectWithoutUserInput | ServiceBookingCreateOrConnectWithoutUserInput[]
    upsert?: ServiceBookingUpsertWithWhereUniqueWithoutUserInput | ServiceBookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ServiceBookingCreateManyUserInputEnvelope
    set?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    disconnect?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    delete?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    connect?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    update?: ServiceBookingUpdateWithWhereUniqueWithoutUserInput | ServiceBookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ServiceBookingUpdateManyWithWhereWithoutUserInput | ServiceBookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ServiceBookingScalarWhereInput | ServiceBookingScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type PhotoCreateNestedManyWithoutProfileInput = {
    create?: XOR<PhotoCreateWithoutProfileInput, PhotoUncheckedCreateWithoutProfileInput> | PhotoCreateWithoutProfileInput[] | PhotoUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PhotoCreateOrConnectWithoutProfileInput | PhotoCreateOrConnectWithoutProfileInput[]
    createMany?: PhotoCreateManyProfileInputEnvelope
    connect?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
  }

  export type ProfileViewCreateNestedManyWithoutProfileInput = {
    create?: XOR<ProfileViewCreateWithoutProfileInput, ProfileViewUncheckedCreateWithoutProfileInput> | ProfileViewCreateWithoutProfileInput[] | ProfileViewUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfileViewCreateOrConnectWithoutProfileInput | ProfileViewCreateOrConnectWithoutProfileInput[]
    createMany?: ProfileViewCreateManyProfileInputEnvelope
    connect?: ProfileViewWhereUniqueInput | ProfileViewWhereUniqueInput[]
  }

  export type ShortlistCreateNestedManyWithoutProfileInput = {
    create?: XOR<ShortlistCreateWithoutProfileInput, ShortlistUncheckedCreateWithoutProfileInput> | ShortlistCreateWithoutProfileInput[] | ShortlistUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ShortlistCreateOrConnectWithoutProfileInput | ShortlistCreateOrConnectWithoutProfileInput[]
    createMany?: ShortlistCreateManyProfileInputEnvelope
    connect?: ShortlistWhereUniqueInput | ShortlistWhereUniqueInput[]
  }

  export type HoroscopeCreateNestedOneWithoutProfileInput = {
    create?: XOR<HoroscopeCreateWithoutProfileInput, HoroscopeUncheckedCreateWithoutProfileInput>
    connectOrCreate?: HoroscopeCreateOrConnectWithoutProfileInput
    connect?: HoroscopeWhereUniqueInput
  }

  export type ProfileComparisonCreateNestedManyWithoutProfileInput = {
    create?: XOR<ProfileComparisonCreateWithoutProfileInput, ProfileComparisonUncheckedCreateWithoutProfileInput> | ProfileComparisonCreateWithoutProfileInput[] | ProfileComparisonUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfileComparisonCreateOrConnectWithoutProfileInput | ProfileComparisonCreateOrConnectWithoutProfileInput[]
    createMany?: ProfileComparisonCreateManyProfileInputEnvelope
    connect?: ProfileComparisonWhereUniqueInput | ProfileComparisonWhereUniqueInput[]
  }

  export type TestimonialCreateNestedManyWithoutProfileInput = {
    create?: XOR<TestimonialCreateWithoutProfileInput, TestimonialUncheckedCreateWithoutProfileInput> | TestimonialCreateWithoutProfileInput[] | TestimonialUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: TestimonialCreateOrConnectWithoutProfileInput | TestimonialCreateOrConnectWithoutProfileInput[]
    createMany?: TestimonialCreateManyProfileInputEnvelope
    connect?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type PhotoUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<PhotoCreateWithoutProfileInput, PhotoUncheckedCreateWithoutProfileInput> | PhotoCreateWithoutProfileInput[] | PhotoUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PhotoCreateOrConnectWithoutProfileInput | PhotoCreateOrConnectWithoutProfileInput[]
    createMany?: PhotoCreateManyProfileInputEnvelope
    connect?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
  }

  export type ProfileViewUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<ProfileViewCreateWithoutProfileInput, ProfileViewUncheckedCreateWithoutProfileInput> | ProfileViewCreateWithoutProfileInput[] | ProfileViewUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfileViewCreateOrConnectWithoutProfileInput | ProfileViewCreateOrConnectWithoutProfileInput[]
    createMany?: ProfileViewCreateManyProfileInputEnvelope
    connect?: ProfileViewWhereUniqueInput | ProfileViewWhereUniqueInput[]
  }

  export type ShortlistUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<ShortlistCreateWithoutProfileInput, ShortlistUncheckedCreateWithoutProfileInput> | ShortlistCreateWithoutProfileInput[] | ShortlistUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ShortlistCreateOrConnectWithoutProfileInput | ShortlistCreateOrConnectWithoutProfileInput[]
    createMany?: ShortlistCreateManyProfileInputEnvelope
    connect?: ShortlistWhereUniqueInput | ShortlistWhereUniqueInput[]
  }

  export type HoroscopeUncheckedCreateNestedOneWithoutProfileInput = {
    create?: XOR<HoroscopeCreateWithoutProfileInput, HoroscopeUncheckedCreateWithoutProfileInput>
    connectOrCreate?: HoroscopeCreateOrConnectWithoutProfileInput
    connect?: HoroscopeWhereUniqueInput
  }

  export type ProfileComparisonUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<ProfileComparisonCreateWithoutProfileInput, ProfileComparisonUncheckedCreateWithoutProfileInput> | ProfileComparisonCreateWithoutProfileInput[] | ProfileComparisonUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfileComparisonCreateOrConnectWithoutProfileInput | ProfileComparisonCreateOrConnectWithoutProfileInput[]
    createMany?: ProfileComparisonCreateManyProfileInputEnvelope
    connect?: ProfileComparisonWhereUniqueInput | ProfileComparisonWhereUniqueInput[]
  }

  export type TestimonialUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<TestimonialCreateWithoutProfileInput, TestimonialUncheckedCreateWithoutProfileInput> | TestimonialCreateWithoutProfileInput[] | TestimonialUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: TestimonialCreateOrConnectWithoutProfileInput | TestimonialCreateOrConnectWithoutProfileInput[]
    createMany?: TestimonialCreateManyProfileInputEnvelope
    connect?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
  }

  export type EnumProfileStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProfileStatus
  }

  export type NullableEnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumMaritalStatusFieldUpdateOperationsInput = {
    set?: $Enums.MaritalStatus | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableEnumFamilyTypeFieldUpdateOperationsInput = {
    set?: $Enums.FamilyType | null
  }

  export type NullableEnumDietFieldUpdateOperationsInput = {
    set?: $Enums.Diet | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PhotoUpdateManyWithoutProfileNestedInput = {
    create?: XOR<PhotoCreateWithoutProfileInput, PhotoUncheckedCreateWithoutProfileInput> | PhotoCreateWithoutProfileInput[] | PhotoUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PhotoCreateOrConnectWithoutProfileInput | PhotoCreateOrConnectWithoutProfileInput[]
    upsert?: PhotoUpsertWithWhereUniqueWithoutProfileInput | PhotoUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: PhotoCreateManyProfileInputEnvelope
    set?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
    disconnect?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
    delete?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
    connect?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
    update?: PhotoUpdateWithWhereUniqueWithoutProfileInput | PhotoUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: PhotoUpdateManyWithWhereWithoutProfileInput | PhotoUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: PhotoScalarWhereInput | PhotoScalarWhereInput[]
  }

  export type ProfileViewUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ProfileViewCreateWithoutProfileInput, ProfileViewUncheckedCreateWithoutProfileInput> | ProfileViewCreateWithoutProfileInput[] | ProfileViewUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfileViewCreateOrConnectWithoutProfileInput | ProfileViewCreateOrConnectWithoutProfileInput[]
    upsert?: ProfileViewUpsertWithWhereUniqueWithoutProfileInput | ProfileViewUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ProfileViewCreateManyProfileInputEnvelope
    set?: ProfileViewWhereUniqueInput | ProfileViewWhereUniqueInput[]
    disconnect?: ProfileViewWhereUniqueInput | ProfileViewWhereUniqueInput[]
    delete?: ProfileViewWhereUniqueInput | ProfileViewWhereUniqueInput[]
    connect?: ProfileViewWhereUniqueInput | ProfileViewWhereUniqueInput[]
    update?: ProfileViewUpdateWithWhereUniqueWithoutProfileInput | ProfileViewUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ProfileViewUpdateManyWithWhereWithoutProfileInput | ProfileViewUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ProfileViewScalarWhereInput | ProfileViewScalarWhereInput[]
  }

  export type ShortlistUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ShortlistCreateWithoutProfileInput, ShortlistUncheckedCreateWithoutProfileInput> | ShortlistCreateWithoutProfileInput[] | ShortlistUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ShortlistCreateOrConnectWithoutProfileInput | ShortlistCreateOrConnectWithoutProfileInput[]
    upsert?: ShortlistUpsertWithWhereUniqueWithoutProfileInput | ShortlistUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ShortlistCreateManyProfileInputEnvelope
    set?: ShortlistWhereUniqueInput | ShortlistWhereUniqueInput[]
    disconnect?: ShortlistWhereUniqueInput | ShortlistWhereUniqueInput[]
    delete?: ShortlistWhereUniqueInput | ShortlistWhereUniqueInput[]
    connect?: ShortlistWhereUniqueInput | ShortlistWhereUniqueInput[]
    update?: ShortlistUpdateWithWhereUniqueWithoutProfileInput | ShortlistUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ShortlistUpdateManyWithWhereWithoutProfileInput | ShortlistUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ShortlistScalarWhereInput | ShortlistScalarWhereInput[]
  }

  export type HoroscopeUpdateOneWithoutProfileNestedInput = {
    create?: XOR<HoroscopeCreateWithoutProfileInput, HoroscopeUncheckedCreateWithoutProfileInput>
    connectOrCreate?: HoroscopeCreateOrConnectWithoutProfileInput
    upsert?: HoroscopeUpsertWithoutProfileInput
    disconnect?: HoroscopeWhereInput | boolean
    delete?: HoroscopeWhereInput | boolean
    connect?: HoroscopeWhereUniqueInput
    update?: XOR<XOR<HoroscopeUpdateToOneWithWhereWithoutProfileInput, HoroscopeUpdateWithoutProfileInput>, HoroscopeUncheckedUpdateWithoutProfileInput>
  }

  export type ProfileComparisonUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ProfileComparisonCreateWithoutProfileInput, ProfileComparisonUncheckedCreateWithoutProfileInput> | ProfileComparisonCreateWithoutProfileInput[] | ProfileComparisonUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfileComparisonCreateOrConnectWithoutProfileInput | ProfileComparisonCreateOrConnectWithoutProfileInput[]
    upsert?: ProfileComparisonUpsertWithWhereUniqueWithoutProfileInput | ProfileComparisonUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ProfileComparisonCreateManyProfileInputEnvelope
    set?: ProfileComparisonWhereUniqueInput | ProfileComparisonWhereUniqueInput[]
    disconnect?: ProfileComparisonWhereUniqueInput | ProfileComparisonWhereUniqueInput[]
    delete?: ProfileComparisonWhereUniqueInput | ProfileComparisonWhereUniqueInput[]
    connect?: ProfileComparisonWhereUniqueInput | ProfileComparisonWhereUniqueInput[]
    update?: ProfileComparisonUpdateWithWhereUniqueWithoutProfileInput | ProfileComparisonUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ProfileComparisonUpdateManyWithWhereWithoutProfileInput | ProfileComparisonUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ProfileComparisonScalarWhereInput | ProfileComparisonScalarWhereInput[]
  }

  export type TestimonialUpdateManyWithoutProfileNestedInput = {
    create?: XOR<TestimonialCreateWithoutProfileInput, TestimonialUncheckedCreateWithoutProfileInput> | TestimonialCreateWithoutProfileInput[] | TestimonialUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: TestimonialCreateOrConnectWithoutProfileInput | TestimonialCreateOrConnectWithoutProfileInput[]
    upsert?: TestimonialUpsertWithWhereUniqueWithoutProfileInput | TestimonialUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: TestimonialCreateManyProfileInputEnvelope
    set?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
    disconnect?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
    delete?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
    connect?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
    update?: TestimonialUpdateWithWhereUniqueWithoutProfileInput | TestimonialUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: TestimonialUpdateManyWithWhereWithoutProfileInput | TestimonialUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: TestimonialScalarWhereInput | TestimonialScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfileInput, UserUpdateWithoutProfileInput>, UserUncheckedUpdateWithoutProfileInput>
  }

  export type PhotoUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<PhotoCreateWithoutProfileInput, PhotoUncheckedCreateWithoutProfileInput> | PhotoCreateWithoutProfileInput[] | PhotoUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PhotoCreateOrConnectWithoutProfileInput | PhotoCreateOrConnectWithoutProfileInput[]
    upsert?: PhotoUpsertWithWhereUniqueWithoutProfileInput | PhotoUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: PhotoCreateManyProfileInputEnvelope
    set?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
    disconnect?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
    delete?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
    connect?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
    update?: PhotoUpdateWithWhereUniqueWithoutProfileInput | PhotoUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: PhotoUpdateManyWithWhereWithoutProfileInput | PhotoUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: PhotoScalarWhereInput | PhotoScalarWhereInput[]
  }

  export type ProfileViewUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ProfileViewCreateWithoutProfileInput, ProfileViewUncheckedCreateWithoutProfileInput> | ProfileViewCreateWithoutProfileInput[] | ProfileViewUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfileViewCreateOrConnectWithoutProfileInput | ProfileViewCreateOrConnectWithoutProfileInput[]
    upsert?: ProfileViewUpsertWithWhereUniqueWithoutProfileInput | ProfileViewUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ProfileViewCreateManyProfileInputEnvelope
    set?: ProfileViewWhereUniqueInput | ProfileViewWhereUniqueInput[]
    disconnect?: ProfileViewWhereUniqueInput | ProfileViewWhereUniqueInput[]
    delete?: ProfileViewWhereUniqueInput | ProfileViewWhereUniqueInput[]
    connect?: ProfileViewWhereUniqueInput | ProfileViewWhereUniqueInput[]
    update?: ProfileViewUpdateWithWhereUniqueWithoutProfileInput | ProfileViewUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ProfileViewUpdateManyWithWhereWithoutProfileInput | ProfileViewUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ProfileViewScalarWhereInput | ProfileViewScalarWhereInput[]
  }

  export type ShortlistUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ShortlistCreateWithoutProfileInput, ShortlistUncheckedCreateWithoutProfileInput> | ShortlistCreateWithoutProfileInput[] | ShortlistUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ShortlistCreateOrConnectWithoutProfileInput | ShortlistCreateOrConnectWithoutProfileInput[]
    upsert?: ShortlistUpsertWithWhereUniqueWithoutProfileInput | ShortlistUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ShortlistCreateManyProfileInputEnvelope
    set?: ShortlistWhereUniqueInput | ShortlistWhereUniqueInput[]
    disconnect?: ShortlistWhereUniqueInput | ShortlistWhereUniqueInput[]
    delete?: ShortlistWhereUniqueInput | ShortlistWhereUniqueInput[]
    connect?: ShortlistWhereUniqueInput | ShortlistWhereUniqueInput[]
    update?: ShortlistUpdateWithWhereUniqueWithoutProfileInput | ShortlistUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ShortlistUpdateManyWithWhereWithoutProfileInput | ShortlistUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ShortlistScalarWhereInput | ShortlistScalarWhereInput[]
  }

  export type HoroscopeUncheckedUpdateOneWithoutProfileNestedInput = {
    create?: XOR<HoroscopeCreateWithoutProfileInput, HoroscopeUncheckedCreateWithoutProfileInput>
    connectOrCreate?: HoroscopeCreateOrConnectWithoutProfileInput
    upsert?: HoroscopeUpsertWithoutProfileInput
    disconnect?: HoroscopeWhereInput | boolean
    delete?: HoroscopeWhereInput | boolean
    connect?: HoroscopeWhereUniqueInput
    update?: XOR<XOR<HoroscopeUpdateToOneWithWhereWithoutProfileInput, HoroscopeUpdateWithoutProfileInput>, HoroscopeUncheckedUpdateWithoutProfileInput>
  }

  export type ProfileComparisonUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ProfileComparisonCreateWithoutProfileInput, ProfileComparisonUncheckedCreateWithoutProfileInput> | ProfileComparisonCreateWithoutProfileInput[] | ProfileComparisonUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfileComparisonCreateOrConnectWithoutProfileInput | ProfileComparisonCreateOrConnectWithoutProfileInput[]
    upsert?: ProfileComparisonUpsertWithWhereUniqueWithoutProfileInput | ProfileComparisonUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ProfileComparisonCreateManyProfileInputEnvelope
    set?: ProfileComparisonWhereUniqueInput | ProfileComparisonWhereUniqueInput[]
    disconnect?: ProfileComparisonWhereUniqueInput | ProfileComparisonWhereUniqueInput[]
    delete?: ProfileComparisonWhereUniqueInput | ProfileComparisonWhereUniqueInput[]
    connect?: ProfileComparisonWhereUniqueInput | ProfileComparisonWhereUniqueInput[]
    update?: ProfileComparisonUpdateWithWhereUniqueWithoutProfileInput | ProfileComparisonUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ProfileComparisonUpdateManyWithWhereWithoutProfileInput | ProfileComparisonUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ProfileComparisonScalarWhereInput | ProfileComparisonScalarWhereInput[]
  }

  export type TestimonialUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<TestimonialCreateWithoutProfileInput, TestimonialUncheckedCreateWithoutProfileInput> | TestimonialCreateWithoutProfileInput[] | TestimonialUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: TestimonialCreateOrConnectWithoutProfileInput | TestimonialCreateOrConnectWithoutProfileInput[]
    upsert?: TestimonialUpsertWithWhereUniqueWithoutProfileInput | TestimonialUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: TestimonialCreateManyProfileInputEnvelope
    set?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
    disconnect?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
    delete?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
    connect?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
    update?: TestimonialUpdateWithWhereUniqueWithoutProfileInput | TestimonialUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: TestimonialUpdateManyWithWhereWithoutProfileInput | TestimonialUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: TestimonialScalarWhereInput | TestimonialScalarWhereInput[]
  }

  export type ProfileCreateNestedOneWithoutPhotosInput = {
    create?: XOR<ProfileCreateWithoutPhotosInput, ProfileUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutPhotosInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutPhotosNestedInput = {
    create?: XOR<ProfileCreateWithoutPhotosInput, ProfileUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutPhotosInput
    upsert?: ProfileUpsertWithoutPhotosInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutPhotosInput, ProfileUpdateWithoutPhotosInput>, ProfileUncheckedUpdateWithoutPhotosInput>
  }

  export type UserCreateNestedOneWithoutInterestsInput = {
    create?: XOR<UserCreateWithoutInterestsInput, UserUncheckedCreateWithoutInterestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInterestsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedInterestsInput = {
    create?: XOR<UserCreateWithoutReceivedInterestsInput, UserUncheckedCreateWithoutReceivedInterestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedInterestsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumInterestStatusFieldUpdateOperationsInput = {
    set?: $Enums.InterestStatus
  }

  export type UserUpdateOneRequiredWithoutInterestsNestedInput = {
    create?: XOR<UserCreateWithoutInterestsInput, UserUncheckedCreateWithoutInterestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInterestsInput
    upsert?: UserUpsertWithoutInterestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInterestsInput, UserUpdateWithoutInterestsInput>, UserUncheckedUpdateWithoutInterestsInput>
  }

  export type UserUpdateOneRequiredWithoutReceivedInterestsNestedInput = {
    create?: XOR<UserCreateWithoutReceivedInterestsInput, UserUncheckedCreateWithoutReceivedInterestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedInterestsInput
    upsert?: UserUpsertWithoutReceivedInterestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedInterestsInput, UserUpdateWithoutReceivedInterestsInput>, UserUncheckedUpdateWithoutReceivedInterestsInput>
  }

  export type UserCreateNestedOneWithoutChatsInput = {
    create?: XOR<UserCreateWithoutChatsInput, UserUncheckedCreateWithoutChatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutChats2Input = {
    create?: XOR<UserCreateWithoutChats2Input, UserUncheckedCreateWithoutChats2Input>
    connectOrCreate?: UserCreateOrConnectWithoutChats2Input
    connect?: UserWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutChatInput = {
    create?: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput> | MessageCreateWithoutChatInput[] | MessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatInput | MessageCreateOrConnectWithoutChatInput[]
    createMany?: MessageCreateManyChatInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutChatInput = {
    create?: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput> | MessageCreateWithoutChatInput[] | MessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatInput | MessageCreateOrConnectWithoutChatInput[]
    createMany?: MessageCreateManyChatInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutChatsNestedInput = {
    create?: XOR<UserCreateWithoutChatsInput, UserUncheckedCreateWithoutChatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatsInput
    upsert?: UserUpsertWithoutChatsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChatsInput, UserUpdateWithoutChatsInput>, UserUncheckedUpdateWithoutChatsInput>
  }

  export type UserUpdateOneRequiredWithoutChats2NestedInput = {
    create?: XOR<UserCreateWithoutChats2Input, UserUncheckedCreateWithoutChats2Input>
    connectOrCreate?: UserCreateOrConnectWithoutChats2Input
    upsert?: UserUpsertWithoutChats2Input
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChats2Input, UserUpdateWithoutChats2Input>, UserUncheckedUpdateWithoutChats2Input>
  }

  export type MessageUpdateManyWithoutChatNestedInput = {
    create?: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput> | MessageCreateWithoutChatInput[] | MessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatInput | MessageCreateOrConnectWithoutChatInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutChatInput | MessageUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: MessageCreateManyChatInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutChatInput | MessageUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutChatInput | MessageUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutChatNestedInput = {
    create?: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput> | MessageCreateWithoutChatInput[] | MessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatInput | MessageCreateOrConnectWithoutChatInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutChatInput | MessageUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: MessageCreateManyChatInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutChatInput | MessageUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutChatInput | MessageUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageCreatedeletedByInput = {
    set: string[]
  }

  export type ChatCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatCreateOrConnectWithoutMessagesInput
    connect?: ChatWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessagesInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type MessageUpdatedeletedByInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ChatUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatCreateOrConnectWithoutMessagesInput
    upsert?: ChatUpsertWithoutMessagesInput
    connect?: ChatWhereUniqueInput
    update?: XOR<XOR<ChatUpdateToOneWithWhereWithoutMessagesInput, ChatUpdateWithoutMessagesInput>, ChatUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    upsert?: UserUpsertWithoutMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessagesInput, UserUpdateWithoutMessagesInput>, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type ProfileCreateNestedOneWithoutProfileViewsInput = {
    create?: XOR<ProfileCreateWithoutProfileViewsInput, ProfileUncheckedCreateWithoutProfileViewsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutProfileViewsInput
    connect?: ProfileWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProfileViewsInput = {
    create?: XOR<UserCreateWithoutProfileViewsInput, UserUncheckedCreateWithoutProfileViewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileViewsInput
    connect?: UserWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutProfileViewsNestedInput = {
    create?: XOR<ProfileCreateWithoutProfileViewsInput, ProfileUncheckedCreateWithoutProfileViewsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutProfileViewsInput
    upsert?: ProfileUpsertWithoutProfileViewsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutProfileViewsInput, ProfileUpdateWithoutProfileViewsInput>, ProfileUncheckedUpdateWithoutProfileViewsInput>
  }

  export type UserUpdateOneRequiredWithoutProfileViewsNestedInput = {
    create?: XOR<UserCreateWithoutProfileViewsInput, UserUncheckedCreateWithoutProfileViewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileViewsInput
    upsert?: UserUpsertWithoutProfileViewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfileViewsInput, UserUpdateWithoutProfileViewsInput>, UserUncheckedUpdateWithoutProfileViewsInput>
  }

  export type SubscriptionCreateNestedOneWithoutContactViewsInput = {
    create?: XOR<SubscriptionCreateWithoutContactViewsInput, SubscriptionUncheckedCreateWithoutContactViewsInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutContactViewsInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type SubscriptionUpdateOneRequiredWithoutContactViewsNestedInput = {
    create?: XOR<SubscriptionCreateWithoutContactViewsInput, SubscriptionUncheckedCreateWithoutContactViewsInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutContactViewsInput
    upsert?: SubscriptionUpsertWithoutContactViewsInput
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutContactViewsInput, SubscriptionUpdateWithoutContactViewsInput>, SubscriptionUncheckedUpdateWithoutContactViewsInput>
  }

  export type UserCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionsInput
    connect?: UserWhereUniqueInput
  }

  export type ContactViewCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<ContactViewCreateWithoutSubscriptionInput, ContactViewUncheckedCreateWithoutSubscriptionInput> | ContactViewCreateWithoutSubscriptionInput[] | ContactViewUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: ContactViewCreateOrConnectWithoutSubscriptionInput | ContactViewCreateOrConnectWithoutSubscriptionInput[]
    createMany?: ContactViewCreateManySubscriptionInputEnvelope
    connect?: ContactViewWhereUniqueInput | ContactViewWhereUniqueInput[]
  }

  export type ContactViewUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<ContactViewCreateWithoutSubscriptionInput, ContactViewUncheckedCreateWithoutSubscriptionInput> | ContactViewCreateWithoutSubscriptionInput[] | ContactViewUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: ContactViewCreateOrConnectWithoutSubscriptionInput | ContactViewCreateOrConnectWithoutSubscriptionInput[]
    createMany?: ContactViewCreateManySubscriptionInputEnvelope
    connect?: ContactViewWhereUniqueInput | ContactViewWhereUniqueInput[]
  }

  export type EnumSubscriptionPlanFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionPlan
  }

  export type UserUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionsInput
    upsert?: UserUpsertWithoutSubscriptionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubscriptionsInput, UserUpdateWithoutSubscriptionsInput>, UserUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type ContactViewUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<ContactViewCreateWithoutSubscriptionInput, ContactViewUncheckedCreateWithoutSubscriptionInput> | ContactViewCreateWithoutSubscriptionInput[] | ContactViewUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: ContactViewCreateOrConnectWithoutSubscriptionInput | ContactViewCreateOrConnectWithoutSubscriptionInput[]
    upsert?: ContactViewUpsertWithWhereUniqueWithoutSubscriptionInput | ContactViewUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: ContactViewCreateManySubscriptionInputEnvelope
    set?: ContactViewWhereUniqueInput | ContactViewWhereUniqueInput[]
    disconnect?: ContactViewWhereUniqueInput | ContactViewWhereUniqueInput[]
    delete?: ContactViewWhereUniqueInput | ContactViewWhereUniqueInput[]
    connect?: ContactViewWhereUniqueInput | ContactViewWhereUniqueInput[]
    update?: ContactViewUpdateWithWhereUniqueWithoutSubscriptionInput | ContactViewUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: ContactViewUpdateManyWithWhereWithoutSubscriptionInput | ContactViewUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: ContactViewScalarWhereInput | ContactViewScalarWhereInput[]
  }

  export type ContactViewUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<ContactViewCreateWithoutSubscriptionInput, ContactViewUncheckedCreateWithoutSubscriptionInput> | ContactViewCreateWithoutSubscriptionInput[] | ContactViewUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: ContactViewCreateOrConnectWithoutSubscriptionInput | ContactViewCreateOrConnectWithoutSubscriptionInput[]
    upsert?: ContactViewUpsertWithWhereUniqueWithoutSubscriptionInput | ContactViewUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: ContactViewCreateManySubscriptionInputEnvelope
    set?: ContactViewWhereUniqueInput | ContactViewWhereUniqueInput[]
    disconnect?: ContactViewWhereUniqueInput | ContactViewWhereUniqueInput[]
    delete?: ContactViewWhereUniqueInput | ContactViewWhereUniqueInput[]
    connect?: ContactViewWhereUniqueInput | ContactViewWhereUniqueInput[]
    update?: ContactViewUpdateWithWhereUniqueWithoutSubscriptionInput | ContactViewUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: ContactViewUpdateManyWithWhereWithoutSubscriptionInput | ContactViewUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: ContactViewScalarWhereInput | ContactViewScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type AddOnCreateNestedManyWithoutPaymentInput = {
    create?: XOR<AddOnCreateWithoutPaymentInput, AddOnUncheckedCreateWithoutPaymentInput> | AddOnCreateWithoutPaymentInput[] | AddOnUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: AddOnCreateOrConnectWithoutPaymentInput | AddOnCreateOrConnectWithoutPaymentInput[]
    createMany?: AddOnCreateManyPaymentInputEnvelope
    connect?: AddOnWhereUniqueInput | AddOnWhereUniqueInput[]
  }

  export type ServiceCreateNestedManyWithoutPaymentInput = {
    create?: XOR<ServiceCreateWithoutPaymentInput, ServiceUncheckedCreateWithoutPaymentInput> | ServiceCreateWithoutPaymentInput[] | ServiceUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutPaymentInput | ServiceCreateOrConnectWithoutPaymentInput[]
    createMany?: ServiceCreateManyPaymentInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type AddOnUncheckedCreateNestedManyWithoutPaymentInput = {
    create?: XOR<AddOnCreateWithoutPaymentInput, AddOnUncheckedCreateWithoutPaymentInput> | AddOnCreateWithoutPaymentInput[] | AddOnUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: AddOnCreateOrConnectWithoutPaymentInput | AddOnCreateOrConnectWithoutPaymentInput[]
    createMany?: AddOnCreateManyPaymentInputEnvelope
    connect?: AddOnWhereUniqueInput | AddOnWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutPaymentInput = {
    create?: XOR<ServiceCreateWithoutPaymentInput, ServiceUncheckedCreateWithoutPaymentInput> | ServiceCreateWithoutPaymentInput[] | ServiceUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutPaymentInput | ServiceCreateOrConnectWithoutPaymentInput[]
    createMany?: ServiceCreateManyPaymentInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type NullableEnumAddOnTypeFieldUpdateOperationsInput = {
    set?: $Enums.AddOnType | null
  }

  export type UserUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    upsert?: UserUpsertWithoutPaymentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentsInput, UserUpdateWithoutPaymentsInput>, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type AddOnUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<AddOnCreateWithoutPaymentInput, AddOnUncheckedCreateWithoutPaymentInput> | AddOnCreateWithoutPaymentInput[] | AddOnUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: AddOnCreateOrConnectWithoutPaymentInput | AddOnCreateOrConnectWithoutPaymentInput[]
    upsert?: AddOnUpsertWithWhereUniqueWithoutPaymentInput | AddOnUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: AddOnCreateManyPaymentInputEnvelope
    set?: AddOnWhereUniqueInput | AddOnWhereUniqueInput[]
    disconnect?: AddOnWhereUniqueInput | AddOnWhereUniqueInput[]
    delete?: AddOnWhereUniqueInput | AddOnWhereUniqueInput[]
    connect?: AddOnWhereUniqueInput | AddOnWhereUniqueInput[]
    update?: AddOnUpdateWithWhereUniqueWithoutPaymentInput | AddOnUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: AddOnUpdateManyWithWhereWithoutPaymentInput | AddOnUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: AddOnScalarWhereInput | AddOnScalarWhereInput[]
  }

  export type ServiceUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<ServiceCreateWithoutPaymentInput, ServiceUncheckedCreateWithoutPaymentInput> | ServiceCreateWithoutPaymentInput[] | ServiceUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutPaymentInput | ServiceCreateOrConnectWithoutPaymentInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutPaymentInput | ServiceUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: ServiceCreateManyPaymentInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutPaymentInput | ServiceUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutPaymentInput | ServiceUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type AddOnUncheckedUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<AddOnCreateWithoutPaymentInput, AddOnUncheckedCreateWithoutPaymentInput> | AddOnCreateWithoutPaymentInput[] | AddOnUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: AddOnCreateOrConnectWithoutPaymentInput | AddOnCreateOrConnectWithoutPaymentInput[]
    upsert?: AddOnUpsertWithWhereUniqueWithoutPaymentInput | AddOnUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: AddOnCreateManyPaymentInputEnvelope
    set?: AddOnWhereUniqueInput | AddOnWhereUniqueInput[]
    disconnect?: AddOnWhereUniqueInput | AddOnWhereUniqueInput[]
    delete?: AddOnWhereUniqueInput | AddOnWhereUniqueInput[]
    connect?: AddOnWhereUniqueInput | AddOnWhereUniqueInput[]
    update?: AddOnUpdateWithWhereUniqueWithoutPaymentInput | AddOnUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: AddOnUpdateManyWithWhereWithoutPaymentInput | AddOnUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: AddOnScalarWhereInput | AddOnScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<ServiceCreateWithoutPaymentInput, ServiceUncheckedCreateWithoutPaymentInput> | ServiceCreateWithoutPaymentInput[] | ServiceUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutPaymentInput | ServiceCreateOrConnectWithoutPaymentInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutPaymentInput | ServiceUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: ServiceCreateManyPaymentInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutPaymentInput | ServiceUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutPaymentInput | ServiceUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type PaymentCreateNestedOneWithoutAddOnsInput = {
    create?: XOR<PaymentCreateWithoutAddOnsInput, PaymentUncheckedCreateWithoutAddOnsInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutAddOnsInput
    connect?: PaymentWhereUniqueInput
  }

  export type EnumAddOnTypeFieldUpdateOperationsInput = {
    set?: $Enums.AddOnType
  }

  export type PaymentUpdateOneWithoutAddOnsNestedInput = {
    create?: XOR<PaymentCreateWithoutAddOnsInput, PaymentUncheckedCreateWithoutAddOnsInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutAddOnsInput
    upsert?: PaymentUpsertWithoutAddOnsInput
    disconnect?: PaymentWhereInput | boolean
    delete?: PaymentWhereInput | boolean
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutAddOnsInput, PaymentUpdateWithoutAddOnsInput>, PaymentUncheckedUpdateWithoutAddOnsInput>
  }

  export type UserCreateNestedOneWithoutServicesInput = {
    create?: XOR<UserCreateWithoutServicesInput, UserUncheckedCreateWithoutServicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutServicesInput
    connect?: UserWhereUniqueInput
  }

  export type PaymentCreateNestedOneWithoutServicesInput = {
    create?: XOR<PaymentCreateWithoutServicesInput, PaymentUncheckedCreateWithoutServicesInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutServicesInput
    connect?: PaymentWhereUniqueInput
  }

  export type ServiceBookingCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceBookingCreateWithoutServiceInput, ServiceBookingUncheckedCreateWithoutServiceInput> | ServiceBookingCreateWithoutServiceInput[] | ServiceBookingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceBookingCreateOrConnectWithoutServiceInput | ServiceBookingCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceBookingCreateManyServiceInputEnvelope
    connect?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
  }

  export type ServiceBookingUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceBookingCreateWithoutServiceInput, ServiceBookingUncheckedCreateWithoutServiceInput> | ServiceBookingCreateWithoutServiceInput[] | ServiceBookingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceBookingCreateOrConnectWithoutServiceInput | ServiceBookingCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceBookingCreateManyServiceInputEnvelope
    connect?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
  }

  export type EnumServiceTypeFieldUpdateOperationsInput = {
    set?: $Enums.ServiceType
  }

  export type EnumServiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.ServiceStatus
  }

  export type UserUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<UserCreateWithoutServicesInput, UserUncheckedCreateWithoutServicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutServicesInput
    upsert?: UserUpsertWithoutServicesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutServicesInput, UserUpdateWithoutServicesInput>, UserUncheckedUpdateWithoutServicesInput>
  }

  export type PaymentUpdateOneWithoutServicesNestedInput = {
    create?: XOR<PaymentCreateWithoutServicesInput, PaymentUncheckedCreateWithoutServicesInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutServicesInput
    upsert?: PaymentUpsertWithoutServicesInput
    disconnect?: PaymentWhereInput | boolean
    delete?: PaymentWhereInput | boolean
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutServicesInput, PaymentUpdateWithoutServicesInput>, PaymentUncheckedUpdateWithoutServicesInput>
  }

  export type ServiceBookingUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceBookingCreateWithoutServiceInput, ServiceBookingUncheckedCreateWithoutServiceInput> | ServiceBookingCreateWithoutServiceInput[] | ServiceBookingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceBookingCreateOrConnectWithoutServiceInput | ServiceBookingCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceBookingUpsertWithWhereUniqueWithoutServiceInput | ServiceBookingUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceBookingCreateManyServiceInputEnvelope
    set?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    disconnect?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    delete?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    connect?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    update?: ServiceBookingUpdateWithWhereUniqueWithoutServiceInput | ServiceBookingUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceBookingUpdateManyWithWhereWithoutServiceInput | ServiceBookingUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceBookingScalarWhereInput | ServiceBookingScalarWhereInput[]
  }

  export type ServiceBookingUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceBookingCreateWithoutServiceInput, ServiceBookingUncheckedCreateWithoutServiceInput> | ServiceBookingCreateWithoutServiceInput[] | ServiceBookingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceBookingCreateOrConnectWithoutServiceInput | ServiceBookingCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceBookingUpsertWithWhereUniqueWithoutServiceInput | ServiceBookingUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceBookingCreateManyServiceInputEnvelope
    set?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    disconnect?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    delete?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    connect?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    update?: ServiceBookingUpdateWithWhereUniqueWithoutServiceInput | ServiceBookingUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceBookingUpdateManyWithWhereWithoutServiceInput | ServiceBookingUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceBookingScalarWhereInput | ServiceBookingScalarWhereInput[]
  }

  export type ServiceBookingCreateNestedManyWithoutProviderInput = {
    create?: XOR<ServiceBookingCreateWithoutProviderInput, ServiceBookingUncheckedCreateWithoutProviderInput> | ServiceBookingCreateWithoutProviderInput[] | ServiceBookingUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ServiceBookingCreateOrConnectWithoutProviderInput | ServiceBookingCreateOrConnectWithoutProviderInput[]
    createMany?: ServiceBookingCreateManyProviderInputEnvelope
    connect?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
  }

  export type ServiceBookingUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<ServiceBookingCreateWithoutProviderInput, ServiceBookingUncheckedCreateWithoutProviderInput> | ServiceBookingCreateWithoutProviderInput[] | ServiceBookingUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ServiceBookingCreateOrConnectWithoutProviderInput | ServiceBookingCreateOrConnectWithoutProviderInput[]
    createMany?: ServiceBookingCreateManyProviderInputEnvelope
    connect?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ServiceBookingUpdateManyWithoutProviderNestedInput = {
    create?: XOR<ServiceBookingCreateWithoutProviderInput, ServiceBookingUncheckedCreateWithoutProviderInput> | ServiceBookingCreateWithoutProviderInput[] | ServiceBookingUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ServiceBookingCreateOrConnectWithoutProviderInput | ServiceBookingCreateOrConnectWithoutProviderInput[]
    upsert?: ServiceBookingUpsertWithWhereUniqueWithoutProviderInput | ServiceBookingUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: ServiceBookingCreateManyProviderInputEnvelope
    set?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    disconnect?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    delete?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    connect?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    update?: ServiceBookingUpdateWithWhereUniqueWithoutProviderInput | ServiceBookingUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: ServiceBookingUpdateManyWithWhereWithoutProviderInput | ServiceBookingUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: ServiceBookingScalarWhereInput | ServiceBookingScalarWhereInput[]
  }

  export type ServiceBookingUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<ServiceBookingCreateWithoutProviderInput, ServiceBookingUncheckedCreateWithoutProviderInput> | ServiceBookingCreateWithoutProviderInput[] | ServiceBookingUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ServiceBookingCreateOrConnectWithoutProviderInput | ServiceBookingCreateOrConnectWithoutProviderInput[]
    upsert?: ServiceBookingUpsertWithWhereUniqueWithoutProviderInput | ServiceBookingUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: ServiceBookingCreateManyProviderInputEnvelope
    set?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    disconnect?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    delete?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    connect?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    update?: ServiceBookingUpdateWithWhereUniqueWithoutProviderInput | ServiceBookingUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: ServiceBookingUpdateManyWithWhereWithoutProviderInput | ServiceBookingUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: ServiceBookingScalarWhereInput | ServiceBookingScalarWhereInput[]
  }

  export type ServiceCreateNestedOneWithoutBookingsInput = {
    create?: XOR<ServiceCreateWithoutBookingsInput, ServiceUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutBookingsInput
    connect?: ServiceWhereUniqueInput
  }

  export type ServiceProviderCreateNestedOneWithoutBookingsInput = {
    create?: XOR<ServiceProviderCreateWithoutBookingsInput, ServiceProviderUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutBookingsInput
    connect?: ServiceProviderWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutServiceBookingsInput = {
    create?: XOR<UserCreateWithoutServiceBookingsInput, UserUncheckedCreateWithoutServiceBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutServiceBookingsInput
    connect?: UserWhereUniqueInput
  }

  export type ServiceUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<ServiceCreateWithoutBookingsInput, ServiceUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutBookingsInput
    upsert?: ServiceUpsertWithoutBookingsInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutBookingsInput, ServiceUpdateWithoutBookingsInput>, ServiceUncheckedUpdateWithoutBookingsInput>
  }

  export type ServiceProviderUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<ServiceProviderCreateWithoutBookingsInput, ServiceProviderUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutBookingsInput
    upsert?: ServiceProviderUpsertWithoutBookingsInput
    disconnect?: ServiceProviderWhereInput | boolean
    delete?: ServiceProviderWhereInput | boolean
    connect?: ServiceProviderWhereUniqueInput
    update?: XOR<XOR<ServiceProviderUpdateToOneWithWhereWithoutBookingsInput, ServiceProviderUpdateWithoutBookingsInput>, ServiceProviderUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateOneRequiredWithoutServiceBookingsNestedInput = {
    create?: XOR<UserCreateWithoutServiceBookingsInput, UserUncheckedCreateWithoutServiceBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutServiceBookingsInput
    upsert?: UserUpsertWithoutServiceBookingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutServiceBookingsInput, UserUpdateWithoutServiceBookingsInput>, UserUncheckedUpdateWithoutServiceBookingsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutShortlistsInput = {
    create?: XOR<UserCreateWithoutShortlistsInput, UserUncheckedCreateWithoutShortlistsInput>
    connectOrCreate?: UserCreateOrConnectWithoutShortlistsInput
    connect?: UserWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutShortlistedByInput = {
    create?: XOR<ProfileCreateWithoutShortlistedByInput, ProfileUncheckedCreateWithoutShortlistedByInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutShortlistedByInput
    connect?: ProfileWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutShortlistsNestedInput = {
    create?: XOR<UserCreateWithoutShortlistsInput, UserUncheckedCreateWithoutShortlistsInput>
    connectOrCreate?: UserCreateOrConnectWithoutShortlistsInput
    upsert?: UserUpsertWithoutShortlistsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutShortlistsInput, UserUpdateWithoutShortlistsInput>, UserUncheckedUpdateWithoutShortlistsInput>
  }

  export type ProfileUpdateOneRequiredWithoutShortlistedByNestedInput = {
    create?: XOR<ProfileCreateWithoutShortlistedByInput, ProfileUncheckedCreateWithoutShortlistedByInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutShortlistedByInput
    upsert?: ProfileUpsertWithoutShortlistedByInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutShortlistedByInput, ProfileUpdateWithoutShortlistedByInput>, ProfileUncheckedUpdateWithoutShortlistedByInput>
  }

  export type UserCreateNestedOneWithoutBlockedUsersInput = {
    create?: XOR<UserCreateWithoutBlockedUsersInput, UserUncheckedCreateWithoutBlockedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlockedUsersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBlockedByInput = {
    create?: XOR<UserCreateWithoutBlockedByInput, UserUncheckedCreateWithoutBlockedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlockedByInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBlockedUsersNestedInput = {
    create?: XOR<UserCreateWithoutBlockedUsersInput, UserUncheckedCreateWithoutBlockedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlockedUsersInput
    upsert?: UserUpsertWithoutBlockedUsersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlockedUsersInput, UserUpdateWithoutBlockedUsersInput>, UserUncheckedUpdateWithoutBlockedUsersInput>
  }

  export type UserUpdateOneRequiredWithoutBlockedByNestedInput = {
    create?: XOR<UserCreateWithoutBlockedByInput, UserUncheckedCreateWithoutBlockedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlockedByInput
    upsert?: UserUpsertWithoutBlockedByInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlockedByInput, UserUpdateWithoutBlockedByInput>, UserUncheckedUpdateWithoutBlockedByInput>
  }

  export type UserCreateNestedOneWithoutHoroscopesInput = {
    create?: XOR<UserCreateWithoutHoroscopesInput, UserUncheckedCreateWithoutHoroscopesInput>
    connectOrCreate?: UserCreateOrConnectWithoutHoroscopesInput
    connect?: UserWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutHoroscopeInput = {
    create?: XOR<ProfileCreateWithoutHoroscopeInput, ProfileUncheckedCreateWithoutHoroscopeInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutHoroscopeInput
    connect?: ProfileWhereUniqueInput
  }

  export type HoroscopeMatchCreateNestedManyWithoutHoroscope1Input = {
    create?: XOR<HoroscopeMatchCreateWithoutHoroscope1Input, HoroscopeMatchUncheckedCreateWithoutHoroscope1Input> | HoroscopeMatchCreateWithoutHoroscope1Input[] | HoroscopeMatchUncheckedCreateWithoutHoroscope1Input[]
    connectOrCreate?: HoroscopeMatchCreateOrConnectWithoutHoroscope1Input | HoroscopeMatchCreateOrConnectWithoutHoroscope1Input[]
    createMany?: HoroscopeMatchCreateManyHoroscope1InputEnvelope
    connect?: HoroscopeMatchWhereUniqueInput | HoroscopeMatchWhereUniqueInput[]
  }

  export type HoroscopeMatchCreateNestedManyWithoutHoroscope2Input = {
    create?: XOR<HoroscopeMatchCreateWithoutHoroscope2Input, HoroscopeMatchUncheckedCreateWithoutHoroscope2Input> | HoroscopeMatchCreateWithoutHoroscope2Input[] | HoroscopeMatchUncheckedCreateWithoutHoroscope2Input[]
    connectOrCreate?: HoroscopeMatchCreateOrConnectWithoutHoroscope2Input | HoroscopeMatchCreateOrConnectWithoutHoroscope2Input[]
    createMany?: HoroscopeMatchCreateManyHoroscope2InputEnvelope
    connect?: HoroscopeMatchWhereUniqueInput | HoroscopeMatchWhereUniqueInput[]
  }

  export type HoroscopeMatchUncheckedCreateNestedManyWithoutHoroscope1Input = {
    create?: XOR<HoroscopeMatchCreateWithoutHoroscope1Input, HoroscopeMatchUncheckedCreateWithoutHoroscope1Input> | HoroscopeMatchCreateWithoutHoroscope1Input[] | HoroscopeMatchUncheckedCreateWithoutHoroscope1Input[]
    connectOrCreate?: HoroscopeMatchCreateOrConnectWithoutHoroscope1Input | HoroscopeMatchCreateOrConnectWithoutHoroscope1Input[]
    createMany?: HoroscopeMatchCreateManyHoroscope1InputEnvelope
    connect?: HoroscopeMatchWhereUniqueInput | HoroscopeMatchWhereUniqueInput[]
  }

  export type HoroscopeMatchUncheckedCreateNestedManyWithoutHoroscope2Input = {
    create?: XOR<HoroscopeMatchCreateWithoutHoroscope2Input, HoroscopeMatchUncheckedCreateWithoutHoroscope2Input> | HoroscopeMatchCreateWithoutHoroscope2Input[] | HoroscopeMatchUncheckedCreateWithoutHoroscope2Input[]
    connectOrCreate?: HoroscopeMatchCreateOrConnectWithoutHoroscope2Input | HoroscopeMatchCreateOrConnectWithoutHoroscope2Input[]
    createMany?: HoroscopeMatchCreateManyHoroscope2InputEnvelope
    connect?: HoroscopeMatchWhereUniqueInput | HoroscopeMatchWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutHoroscopesNestedInput = {
    create?: XOR<UserCreateWithoutHoroscopesInput, UserUncheckedCreateWithoutHoroscopesInput>
    connectOrCreate?: UserCreateOrConnectWithoutHoroscopesInput
    upsert?: UserUpsertWithoutHoroscopesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHoroscopesInput, UserUpdateWithoutHoroscopesInput>, UserUncheckedUpdateWithoutHoroscopesInput>
  }

  export type ProfileUpdateOneRequiredWithoutHoroscopeNestedInput = {
    create?: XOR<ProfileCreateWithoutHoroscopeInput, ProfileUncheckedCreateWithoutHoroscopeInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutHoroscopeInput
    upsert?: ProfileUpsertWithoutHoroscopeInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutHoroscopeInput, ProfileUpdateWithoutHoroscopeInput>, ProfileUncheckedUpdateWithoutHoroscopeInput>
  }

  export type HoroscopeMatchUpdateManyWithoutHoroscope1NestedInput = {
    create?: XOR<HoroscopeMatchCreateWithoutHoroscope1Input, HoroscopeMatchUncheckedCreateWithoutHoroscope1Input> | HoroscopeMatchCreateWithoutHoroscope1Input[] | HoroscopeMatchUncheckedCreateWithoutHoroscope1Input[]
    connectOrCreate?: HoroscopeMatchCreateOrConnectWithoutHoroscope1Input | HoroscopeMatchCreateOrConnectWithoutHoroscope1Input[]
    upsert?: HoroscopeMatchUpsertWithWhereUniqueWithoutHoroscope1Input | HoroscopeMatchUpsertWithWhereUniqueWithoutHoroscope1Input[]
    createMany?: HoroscopeMatchCreateManyHoroscope1InputEnvelope
    set?: HoroscopeMatchWhereUniqueInput | HoroscopeMatchWhereUniqueInput[]
    disconnect?: HoroscopeMatchWhereUniqueInput | HoroscopeMatchWhereUniqueInput[]
    delete?: HoroscopeMatchWhereUniqueInput | HoroscopeMatchWhereUniqueInput[]
    connect?: HoroscopeMatchWhereUniqueInput | HoroscopeMatchWhereUniqueInput[]
    update?: HoroscopeMatchUpdateWithWhereUniqueWithoutHoroscope1Input | HoroscopeMatchUpdateWithWhereUniqueWithoutHoroscope1Input[]
    updateMany?: HoroscopeMatchUpdateManyWithWhereWithoutHoroscope1Input | HoroscopeMatchUpdateManyWithWhereWithoutHoroscope1Input[]
    deleteMany?: HoroscopeMatchScalarWhereInput | HoroscopeMatchScalarWhereInput[]
  }

  export type HoroscopeMatchUpdateManyWithoutHoroscope2NestedInput = {
    create?: XOR<HoroscopeMatchCreateWithoutHoroscope2Input, HoroscopeMatchUncheckedCreateWithoutHoroscope2Input> | HoroscopeMatchCreateWithoutHoroscope2Input[] | HoroscopeMatchUncheckedCreateWithoutHoroscope2Input[]
    connectOrCreate?: HoroscopeMatchCreateOrConnectWithoutHoroscope2Input | HoroscopeMatchCreateOrConnectWithoutHoroscope2Input[]
    upsert?: HoroscopeMatchUpsertWithWhereUniqueWithoutHoroscope2Input | HoroscopeMatchUpsertWithWhereUniqueWithoutHoroscope2Input[]
    createMany?: HoroscopeMatchCreateManyHoroscope2InputEnvelope
    set?: HoroscopeMatchWhereUniqueInput | HoroscopeMatchWhereUniqueInput[]
    disconnect?: HoroscopeMatchWhereUniqueInput | HoroscopeMatchWhereUniqueInput[]
    delete?: HoroscopeMatchWhereUniqueInput | HoroscopeMatchWhereUniqueInput[]
    connect?: HoroscopeMatchWhereUniqueInput | HoroscopeMatchWhereUniqueInput[]
    update?: HoroscopeMatchUpdateWithWhereUniqueWithoutHoroscope2Input | HoroscopeMatchUpdateWithWhereUniqueWithoutHoroscope2Input[]
    updateMany?: HoroscopeMatchUpdateManyWithWhereWithoutHoroscope2Input | HoroscopeMatchUpdateManyWithWhereWithoutHoroscope2Input[]
    deleteMany?: HoroscopeMatchScalarWhereInput | HoroscopeMatchScalarWhereInput[]
  }

  export type HoroscopeMatchUncheckedUpdateManyWithoutHoroscope1NestedInput = {
    create?: XOR<HoroscopeMatchCreateWithoutHoroscope1Input, HoroscopeMatchUncheckedCreateWithoutHoroscope1Input> | HoroscopeMatchCreateWithoutHoroscope1Input[] | HoroscopeMatchUncheckedCreateWithoutHoroscope1Input[]
    connectOrCreate?: HoroscopeMatchCreateOrConnectWithoutHoroscope1Input | HoroscopeMatchCreateOrConnectWithoutHoroscope1Input[]
    upsert?: HoroscopeMatchUpsertWithWhereUniqueWithoutHoroscope1Input | HoroscopeMatchUpsertWithWhereUniqueWithoutHoroscope1Input[]
    createMany?: HoroscopeMatchCreateManyHoroscope1InputEnvelope
    set?: HoroscopeMatchWhereUniqueInput | HoroscopeMatchWhereUniqueInput[]
    disconnect?: HoroscopeMatchWhereUniqueInput | HoroscopeMatchWhereUniqueInput[]
    delete?: HoroscopeMatchWhereUniqueInput | HoroscopeMatchWhereUniqueInput[]
    connect?: HoroscopeMatchWhereUniqueInput | HoroscopeMatchWhereUniqueInput[]
    update?: HoroscopeMatchUpdateWithWhereUniqueWithoutHoroscope1Input | HoroscopeMatchUpdateWithWhereUniqueWithoutHoroscope1Input[]
    updateMany?: HoroscopeMatchUpdateManyWithWhereWithoutHoroscope1Input | HoroscopeMatchUpdateManyWithWhereWithoutHoroscope1Input[]
    deleteMany?: HoroscopeMatchScalarWhereInput | HoroscopeMatchScalarWhereInput[]
  }

  export type HoroscopeMatchUncheckedUpdateManyWithoutHoroscope2NestedInput = {
    create?: XOR<HoroscopeMatchCreateWithoutHoroscope2Input, HoroscopeMatchUncheckedCreateWithoutHoroscope2Input> | HoroscopeMatchCreateWithoutHoroscope2Input[] | HoroscopeMatchUncheckedCreateWithoutHoroscope2Input[]
    connectOrCreate?: HoroscopeMatchCreateOrConnectWithoutHoroscope2Input | HoroscopeMatchCreateOrConnectWithoutHoroscope2Input[]
    upsert?: HoroscopeMatchUpsertWithWhereUniqueWithoutHoroscope2Input | HoroscopeMatchUpsertWithWhereUniqueWithoutHoroscope2Input[]
    createMany?: HoroscopeMatchCreateManyHoroscope2InputEnvelope
    set?: HoroscopeMatchWhereUniqueInput | HoroscopeMatchWhereUniqueInput[]
    disconnect?: HoroscopeMatchWhereUniqueInput | HoroscopeMatchWhereUniqueInput[]
    delete?: HoroscopeMatchWhereUniqueInput | HoroscopeMatchWhereUniqueInput[]
    connect?: HoroscopeMatchWhereUniqueInput | HoroscopeMatchWhereUniqueInput[]
    update?: HoroscopeMatchUpdateWithWhereUniqueWithoutHoroscope2Input | HoroscopeMatchUpdateWithWhereUniqueWithoutHoroscope2Input[]
    updateMany?: HoroscopeMatchUpdateManyWithWhereWithoutHoroscope2Input | HoroscopeMatchUpdateManyWithWhereWithoutHoroscope2Input[]
    deleteMany?: HoroscopeMatchScalarWhereInput | HoroscopeMatchScalarWhereInput[]
  }

  export type HoroscopeCreateNestedOneWithoutMatches1Input = {
    create?: XOR<HoroscopeCreateWithoutMatches1Input, HoroscopeUncheckedCreateWithoutMatches1Input>
    connectOrCreate?: HoroscopeCreateOrConnectWithoutMatches1Input
    connect?: HoroscopeWhereUniqueInput
  }

  export type HoroscopeCreateNestedOneWithoutMatches2Input = {
    create?: XOR<HoroscopeCreateWithoutMatches2Input, HoroscopeUncheckedCreateWithoutMatches2Input>
    connectOrCreate?: HoroscopeCreateOrConnectWithoutMatches2Input
    connect?: HoroscopeWhereUniqueInput
  }

  export type HoroscopeUpdateOneRequiredWithoutMatches1NestedInput = {
    create?: XOR<HoroscopeCreateWithoutMatches1Input, HoroscopeUncheckedCreateWithoutMatches1Input>
    connectOrCreate?: HoroscopeCreateOrConnectWithoutMatches1Input
    upsert?: HoroscopeUpsertWithoutMatches1Input
    connect?: HoroscopeWhereUniqueInput
    update?: XOR<XOR<HoroscopeUpdateToOneWithWhereWithoutMatches1Input, HoroscopeUpdateWithoutMatches1Input>, HoroscopeUncheckedUpdateWithoutMatches1Input>
  }

  export type HoroscopeUpdateOneRequiredWithoutMatches2NestedInput = {
    create?: XOR<HoroscopeCreateWithoutMatches2Input, HoroscopeUncheckedCreateWithoutMatches2Input>
    connectOrCreate?: HoroscopeCreateOrConnectWithoutMatches2Input
    upsert?: HoroscopeUpsertWithoutMatches2Input
    connect?: HoroscopeWhereUniqueInput
    update?: XOR<XOR<HoroscopeUpdateToOneWithWhereWithoutMatches2Input, HoroscopeUpdateWithoutMatches2Input>, HoroscopeUncheckedUpdateWithoutMatches2Input>
  }

  export type UserCreateNestedOneWithoutSuccessStoriesInput = {
    create?: XOR<UserCreateWithoutSuccessStoriesInput, UserUncheckedCreateWithoutSuccessStoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSuccessStoriesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSuccessStoriesNestedInput = {
    create?: XOR<UserCreateWithoutSuccessStoriesInput, UserUncheckedCreateWithoutSuccessStoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSuccessStoriesInput
    upsert?: UserUpsertWithoutSuccessStoriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSuccessStoriesInput, UserUpdateWithoutSuccessStoriesInput>, UserUncheckedUpdateWithoutSuccessStoriesInput>
  }

  export type UserCreateNestedOneWithoutFamilyMembersInput = {
    create?: XOR<UserCreateWithoutFamilyMembersInput, UserUncheckedCreateWithoutFamilyMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutFamilyMembersInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFamilyMembersNestedInput = {
    create?: XOR<UserCreateWithoutFamilyMembersInput, UserUncheckedCreateWithoutFamilyMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutFamilyMembersInput
    upsert?: UserUpsertWithoutFamilyMembersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFamilyMembersInput, UserUpdateWithoutFamilyMembersInput>, UserUncheckedUpdateWithoutFamilyMembersInput>
  }

  export type UserCreateNestedOneWithoutReferralsInput = {
    create?: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReferredByRefInput = {
    create?: XOR<UserCreateWithoutReferredByRefInput, UserUncheckedCreateWithoutReferredByRefInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferredByRefInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReferralsNestedInput = {
    create?: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsInput
    upsert?: UserUpsertWithoutReferralsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReferralsInput, UserUpdateWithoutReferralsInput>, UserUncheckedUpdateWithoutReferralsInput>
  }

  export type UserUpdateOneRequiredWithoutReferredByRefNestedInput = {
    create?: XOR<UserCreateWithoutReferredByRefInput, UserUncheckedCreateWithoutReferredByRefInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferredByRefInput
    upsert?: UserUpsertWithoutReferredByRefInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReferredByRefInput, UserUpdateWithoutReferredByRefInput>, UserUncheckedUpdateWithoutReferredByRefInput>
  }

  export type UserCreateNestedOneWithoutAchievementsInput = {
    create?: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAchievementsNestedInput = {
    create?: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementsInput
    upsert?: UserUpsertWithoutAchievementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAchievementsInput, UserUpdateWithoutAchievementsInput>, UserUncheckedUpdateWithoutAchievementsInput>
  }

  export type UserCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentsInput
    upsert?: UserUpsertWithoutDocumentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDocumentsInput, UserUpdateWithoutDocumentsInput>, UserUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserCreateNestedOneWithoutVideoCallsAsCallerInput = {
    create?: XOR<UserCreateWithoutVideoCallsAsCallerInput, UserUncheckedCreateWithoutVideoCallsAsCallerInput>
    connectOrCreate?: UserCreateOrConnectWithoutVideoCallsAsCallerInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVideoCallsAsParticipantInput = {
    create?: XOR<UserCreateWithoutVideoCallsAsParticipantInput, UserUncheckedCreateWithoutVideoCallsAsParticipantInput>
    connectOrCreate?: UserCreateOrConnectWithoutVideoCallsAsParticipantInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutVideoCallsAsCallerNestedInput = {
    create?: XOR<UserCreateWithoutVideoCallsAsCallerInput, UserUncheckedCreateWithoutVideoCallsAsCallerInput>
    connectOrCreate?: UserCreateOrConnectWithoutVideoCallsAsCallerInput
    upsert?: UserUpsertWithoutVideoCallsAsCallerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVideoCallsAsCallerInput, UserUpdateWithoutVideoCallsAsCallerInput>, UserUncheckedUpdateWithoutVideoCallsAsCallerInput>
  }

  export type UserUpdateOneRequiredWithoutVideoCallsAsParticipantNestedInput = {
    create?: XOR<UserCreateWithoutVideoCallsAsParticipantInput, UserUncheckedCreateWithoutVideoCallsAsParticipantInput>
    connectOrCreate?: UserCreateOrConnectWithoutVideoCallsAsParticipantInput
    upsert?: UserUpsertWithoutVideoCallsAsParticipantInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVideoCallsAsParticipantInput, UserUpdateWithoutVideoCallsAsParticipantInput>, UserUncheckedUpdateWithoutVideoCallsAsParticipantInput>
  }

  export type ProfileCreateNestedOneWithoutComparisonsInput = {
    create?: XOR<ProfileCreateWithoutComparisonsInput, ProfileUncheckedCreateWithoutComparisonsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutComparisonsInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutComparisonsNestedInput = {
    create?: XOR<ProfileCreateWithoutComparisonsInput, ProfileUncheckedCreateWithoutComparisonsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutComparisonsInput
    upsert?: ProfileUpsertWithoutComparisonsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutComparisonsInput, ProfileUpdateWithoutComparisonsInput>, ProfileUncheckedUpdateWithoutComparisonsInput>
  }

  export type ForumPostCreatetagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutForumPostsInput = {
    create?: XOR<UserCreateWithoutForumPostsInput, UserUncheckedCreateWithoutForumPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutForumPostsInput
    connect?: UserWhereUniqueInput
  }

  export type ForumCommentCreateNestedManyWithoutPostInput = {
    create?: XOR<ForumCommentCreateWithoutPostInput, ForumCommentUncheckedCreateWithoutPostInput> | ForumCommentCreateWithoutPostInput[] | ForumCommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ForumCommentCreateOrConnectWithoutPostInput | ForumCommentCreateOrConnectWithoutPostInput[]
    createMany?: ForumCommentCreateManyPostInputEnvelope
    connect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
  }

  export type ForumCommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<ForumCommentCreateWithoutPostInput, ForumCommentUncheckedCreateWithoutPostInput> | ForumCommentCreateWithoutPostInput[] | ForumCommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ForumCommentCreateOrConnectWithoutPostInput | ForumCommentCreateOrConnectWithoutPostInput[]
    createMany?: ForumCommentCreateManyPostInputEnvelope
    connect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
  }

  export type ForumPostUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutForumPostsNestedInput = {
    create?: XOR<UserCreateWithoutForumPostsInput, UserUncheckedCreateWithoutForumPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutForumPostsInput
    upsert?: UserUpsertWithoutForumPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutForumPostsInput, UserUpdateWithoutForumPostsInput>, UserUncheckedUpdateWithoutForumPostsInput>
  }

  export type ForumCommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<ForumCommentCreateWithoutPostInput, ForumCommentUncheckedCreateWithoutPostInput> | ForumCommentCreateWithoutPostInput[] | ForumCommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ForumCommentCreateOrConnectWithoutPostInput | ForumCommentCreateOrConnectWithoutPostInput[]
    upsert?: ForumCommentUpsertWithWhereUniqueWithoutPostInput | ForumCommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: ForumCommentCreateManyPostInputEnvelope
    set?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    disconnect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    delete?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    connect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    update?: ForumCommentUpdateWithWhereUniqueWithoutPostInput | ForumCommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: ForumCommentUpdateManyWithWhereWithoutPostInput | ForumCommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: ForumCommentScalarWhereInput | ForumCommentScalarWhereInput[]
  }

  export type ForumCommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<ForumCommentCreateWithoutPostInput, ForumCommentUncheckedCreateWithoutPostInput> | ForumCommentCreateWithoutPostInput[] | ForumCommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ForumCommentCreateOrConnectWithoutPostInput | ForumCommentCreateOrConnectWithoutPostInput[]
    upsert?: ForumCommentUpsertWithWhereUniqueWithoutPostInput | ForumCommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: ForumCommentCreateManyPostInputEnvelope
    set?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    disconnect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    delete?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    connect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    update?: ForumCommentUpdateWithWhereUniqueWithoutPostInput | ForumCommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: ForumCommentUpdateManyWithWhereWithoutPostInput | ForumCommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: ForumCommentScalarWhereInput | ForumCommentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutForumCommentsInput = {
    create?: XOR<UserCreateWithoutForumCommentsInput, UserUncheckedCreateWithoutForumCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutForumCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type ForumPostCreateNestedOneWithoutCommentsInput = {
    create?: XOR<ForumPostCreateWithoutCommentsInput, ForumPostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ForumPostCreateOrConnectWithoutCommentsInput
    connect?: ForumPostWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutForumCommentsNestedInput = {
    create?: XOR<UserCreateWithoutForumCommentsInput, UserUncheckedCreateWithoutForumCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutForumCommentsInput
    upsert?: UserUpsertWithoutForumCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutForumCommentsInput, UserUpdateWithoutForumCommentsInput>, UserUncheckedUpdateWithoutForumCommentsInput>
  }

  export type ForumPostUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<ForumPostCreateWithoutCommentsInput, ForumPostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ForumPostCreateOrConnectWithoutCommentsInput
    upsert?: ForumPostUpsertWithoutCommentsInput
    connect?: ForumPostWhereUniqueInput
    update?: XOR<XOR<ForumPostUpdateToOneWithWhereWithoutCommentsInput, ForumPostUpdateWithoutCommentsInput>, ForumPostUncheckedUpdateWithoutCommentsInput>
  }

  export type GroupMemberCreateNestedManyWithoutGroupInput = {
    create?: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput> | GroupMemberCreateWithoutGroupInput[] | GroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutGroupInput | GroupMemberCreateOrConnectWithoutGroupInput[]
    createMany?: GroupMemberCreateManyGroupInputEnvelope
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
  }

  export type GroupMemberUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput> | GroupMemberCreateWithoutGroupInput[] | GroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutGroupInput | GroupMemberCreateOrConnectWithoutGroupInput[]
    createMany?: GroupMemberCreateManyGroupInputEnvelope
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
  }

  export type GroupMemberUpdateManyWithoutGroupNestedInput = {
    create?: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput> | GroupMemberCreateWithoutGroupInput[] | GroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutGroupInput | GroupMemberCreateOrConnectWithoutGroupInput[]
    upsert?: GroupMemberUpsertWithWhereUniqueWithoutGroupInput | GroupMemberUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: GroupMemberCreateManyGroupInputEnvelope
    set?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    disconnect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    delete?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    update?: GroupMemberUpdateWithWhereUniqueWithoutGroupInput | GroupMemberUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: GroupMemberUpdateManyWithWhereWithoutGroupInput | GroupMemberUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
  }

  export type GroupMemberUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput> | GroupMemberCreateWithoutGroupInput[] | GroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutGroupInput | GroupMemberCreateOrConnectWithoutGroupInput[]
    upsert?: GroupMemberUpsertWithWhereUniqueWithoutGroupInput | GroupMemberUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: GroupMemberCreateManyGroupInputEnvelope
    set?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    disconnect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    delete?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    update?: GroupMemberUpdateWithWhereUniqueWithoutGroupInput | GroupMemberUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: GroupMemberUpdateManyWithWhereWithoutGroupInput | GroupMemberUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
  }

  export type CommunityGroupCreateNestedOneWithoutMembersInput = {
    create?: XOR<CommunityGroupCreateWithoutMembersInput, CommunityGroupUncheckedCreateWithoutMembersInput>
    connectOrCreate?: CommunityGroupCreateOrConnectWithoutMembersInput
    connect?: CommunityGroupWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGroupMembersInput = {
    create?: XOR<UserCreateWithoutGroupMembersInput, UserUncheckedCreateWithoutGroupMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutGroupMembersInput
    connect?: UserWhereUniqueInput
  }

  export type CommunityGroupUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<CommunityGroupCreateWithoutMembersInput, CommunityGroupUncheckedCreateWithoutMembersInput>
    connectOrCreate?: CommunityGroupCreateOrConnectWithoutMembersInput
    upsert?: CommunityGroupUpsertWithoutMembersInput
    connect?: CommunityGroupWhereUniqueInput
    update?: XOR<XOR<CommunityGroupUpdateToOneWithWhereWithoutMembersInput, CommunityGroupUpdateWithoutMembersInput>, CommunityGroupUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutGroupMembersNestedInput = {
    create?: XOR<UserCreateWithoutGroupMembersInput, UserUncheckedCreateWithoutGroupMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutGroupMembersInput
    upsert?: UserUpsertWithoutGroupMembersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGroupMembersInput, UserUpdateWithoutGroupMembersInput>, UserUncheckedUpdateWithoutGroupMembersInput>
  }

  export type EventParticipantCreateNestedManyWithoutEventInput = {
    create?: XOR<EventParticipantCreateWithoutEventInput, EventParticipantUncheckedCreateWithoutEventInput> | EventParticipantCreateWithoutEventInput[] | EventParticipantUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventParticipantCreateOrConnectWithoutEventInput | EventParticipantCreateOrConnectWithoutEventInput[]
    createMany?: EventParticipantCreateManyEventInputEnvelope
    connect?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
  }

  export type EventParticipantUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<EventParticipantCreateWithoutEventInput, EventParticipantUncheckedCreateWithoutEventInput> | EventParticipantCreateWithoutEventInput[] | EventParticipantUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventParticipantCreateOrConnectWithoutEventInput | EventParticipantCreateOrConnectWithoutEventInput[]
    createMany?: EventParticipantCreateManyEventInputEnvelope
    connect?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
  }

  export type EventParticipantUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventParticipantCreateWithoutEventInput, EventParticipantUncheckedCreateWithoutEventInput> | EventParticipantCreateWithoutEventInput[] | EventParticipantUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventParticipantCreateOrConnectWithoutEventInput | EventParticipantCreateOrConnectWithoutEventInput[]
    upsert?: EventParticipantUpsertWithWhereUniqueWithoutEventInput | EventParticipantUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventParticipantCreateManyEventInputEnvelope
    set?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
    disconnect?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
    delete?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
    connect?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
    update?: EventParticipantUpdateWithWhereUniqueWithoutEventInput | EventParticipantUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventParticipantUpdateManyWithWhereWithoutEventInput | EventParticipantUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventParticipantScalarWhereInput | EventParticipantScalarWhereInput[]
  }

  export type EventParticipantUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventParticipantCreateWithoutEventInput, EventParticipantUncheckedCreateWithoutEventInput> | EventParticipantCreateWithoutEventInput[] | EventParticipantUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventParticipantCreateOrConnectWithoutEventInput | EventParticipantCreateOrConnectWithoutEventInput[]
    upsert?: EventParticipantUpsertWithWhereUniqueWithoutEventInput | EventParticipantUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventParticipantCreateManyEventInputEnvelope
    set?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
    disconnect?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
    delete?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
    connect?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
    update?: EventParticipantUpdateWithWhereUniqueWithoutEventInput | EventParticipantUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventParticipantUpdateManyWithWhereWithoutEventInput | EventParticipantUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventParticipantScalarWhereInput | EventParticipantScalarWhereInput[]
  }

  export type CommunityEventCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<CommunityEventCreateWithoutParticipantsInput, CommunityEventUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: CommunityEventCreateOrConnectWithoutParticipantsInput
    connect?: CommunityEventWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEventParticipantsInput = {
    create?: XOR<UserCreateWithoutEventParticipantsInput, UserUncheckedCreateWithoutEventParticipantsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventParticipantsInput
    connect?: UserWhereUniqueInput
  }

  export type CommunityEventUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<CommunityEventCreateWithoutParticipantsInput, CommunityEventUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: CommunityEventCreateOrConnectWithoutParticipantsInput
    upsert?: CommunityEventUpsertWithoutParticipantsInput
    connect?: CommunityEventWhereUniqueInput
    update?: XOR<XOR<CommunityEventUpdateToOneWithWhereWithoutParticipantsInput, CommunityEventUpdateWithoutParticipantsInput>, CommunityEventUncheckedUpdateWithoutParticipantsInput>
  }

  export type UserUpdateOneRequiredWithoutEventParticipantsNestedInput = {
    create?: XOR<UserCreateWithoutEventParticipantsInput, UserUncheckedCreateWithoutEventParticipantsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventParticipantsInput
    upsert?: UserUpsertWithoutEventParticipantsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEventParticipantsInput, UserUpdateWithoutEventParticipantsInput>, UserUncheckedUpdateWithoutEventParticipantsInput>
  }

  export type BlogPostCreatetagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutBlogPostsInput = {
    create?: XOR<UserCreateWithoutBlogPostsInput, UserUncheckedCreateWithoutBlogPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogPostsInput
    connect?: UserWhereUniqueInput
  }

  export type BlogPostUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutBlogPostsNestedInput = {
    create?: XOR<UserCreateWithoutBlogPostsInput, UserUncheckedCreateWithoutBlogPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogPostsInput
    upsert?: UserUpsertWithoutBlogPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlogPostsInput, UserUpdateWithoutBlogPostsInput>, UserUncheckedUpdateWithoutBlogPostsInput>
  }

  export type UserCreateNestedOneWithoutMatchScoresInput = {
    create?: XOR<UserCreateWithoutMatchScoresInput, UserUncheckedCreateWithoutMatchScoresInput>
    connectOrCreate?: UserCreateOrConnectWithoutMatchScoresInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMatchedByInput = {
    create?: XOR<UserCreateWithoutMatchedByInput, UserUncheckedCreateWithoutMatchedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutMatchedByInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMatchScoresNestedInput = {
    create?: XOR<UserCreateWithoutMatchScoresInput, UserUncheckedCreateWithoutMatchScoresInput>
    connectOrCreate?: UserCreateOrConnectWithoutMatchScoresInput
    upsert?: UserUpsertWithoutMatchScoresInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMatchScoresInput, UserUpdateWithoutMatchScoresInput>, UserUncheckedUpdateWithoutMatchScoresInput>
  }

  export type UserUpdateOneRequiredWithoutMatchedByNestedInput = {
    create?: XOR<UserCreateWithoutMatchedByInput, UserUncheckedCreateWithoutMatchedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutMatchedByInput
    upsert?: UserUpsertWithoutMatchedByInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMatchedByInput, UserUpdateWithoutMatchedByInput>, UserUncheckedUpdateWithoutMatchedByInput>
  }

  export type UserCreateNestedOneWithoutSearchHistoryInput = {
    create?: XOR<UserCreateWithoutSearchHistoryInput, UserUncheckedCreateWithoutSearchHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutSearchHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSearchHistoryNestedInput = {
    create?: XOR<UserCreateWithoutSearchHistoryInput, UserUncheckedCreateWithoutSearchHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutSearchHistoryInput
    upsert?: UserUpsertWithoutSearchHistoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSearchHistoryInput, UserUpdateWithoutSearchHistoryInput>, UserUncheckedUpdateWithoutSearchHistoryInput>
  }

  export type UserCreateNestedOneWithoutMessageTemplatesInput = {
    create?: XOR<UserCreateWithoutMessageTemplatesInput, UserUncheckedCreateWithoutMessageTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessageTemplatesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMessageTemplatesNestedInput = {
    create?: XOR<UserCreateWithoutMessageTemplatesInput, UserUncheckedCreateWithoutMessageTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessageTemplatesInput
    upsert?: UserUpsertWithoutMessageTemplatesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessageTemplatesInput, UserUpdateWithoutMessageTemplatesInput>, UserUncheckedUpdateWithoutMessageTemplatesInput>
  }

  export type UserCreateNestedOneWithoutIceBreakersInput = {
    create?: XOR<UserCreateWithoutIceBreakersInput, UserUncheckedCreateWithoutIceBreakersInput>
    connectOrCreate?: UserCreateOrConnectWithoutIceBreakersInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutIceBreakersNestedInput = {
    create?: XOR<UserCreateWithoutIceBreakersInput, UserUncheckedCreateWithoutIceBreakersInput>
    connectOrCreate?: UserCreateOrConnectWithoutIceBreakersInput
    upsert?: UserUpsertWithoutIceBreakersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIceBreakersInput, UserUpdateWithoutIceBreakersInput>, UserUncheckedUpdateWithoutIceBreakersInput>
  }

  export type ProfileCreateNestedOneWithoutTestimonialsInput = {
    create?: XOR<ProfileCreateWithoutTestimonialsInput, ProfileUncheckedCreateWithoutTestimonialsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutTestimonialsInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutTestimonialsNestedInput = {
    create?: XOR<ProfileCreateWithoutTestimonialsInput, ProfileUncheckedCreateWithoutTestimonialsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutTestimonialsInput
    upsert?: ProfileUpsertWithoutTestimonialsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutTestimonialsInput, ProfileUpdateWithoutTestimonialsInput>, ProfileUncheckedUpdateWithoutTestimonialsInput>
  }

  export type UserCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    upsert?: UserUpsertWithoutActivitiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivitiesInput, UserUpdateWithoutActivitiesInput>, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type UserCreateNestedOneWithoutLeaderboardInput = {
    create?: XOR<UserCreateWithoutLeaderboardInput, UserUncheckedCreateWithoutLeaderboardInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaderboardInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLeaderboardNestedInput = {
    create?: XOR<UserCreateWithoutLeaderboardInput, UserUncheckedCreateWithoutLeaderboardInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaderboardInput
    upsert?: UserUpsertWithoutLeaderboardInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLeaderboardInput, UserUpdateWithoutLeaderboardInput>, UserUncheckedUpdateWithoutLeaderboardInput>
  }

  export type UserCreateNestedOneWithoutWishlistsInput = {
    create?: XOR<UserCreateWithoutWishlistsInput, UserUncheckedCreateWithoutWishlistsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWishlistsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutWishlistsNestedInput = {
    create?: XOR<UserCreateWithoutWishlistsInput, UserUncheckedCreateWithoutWishlistsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWishlistsInput
    upsert?: UserUpsertWithoutWishlistsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWishlistsInput, UserUpdateWithoutWishlistsInput>, UserUncheckedUpdateWithoutWishlistsInput>
  }

  export type UserCreateNestedOneWithoutProfileExportsInput = {
    create?: XOR<UserCreateWithoutProfileExportsInput, UserUncheckedCreateWithoutProfileExportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileExportsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProfileExportsNestedInput = {
    create?: XOR<UserCreateWithoutProfileExportsInput, UserUncheckedCreateWithoutProfileExportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileExportsInput
    upsert?: UserUpsertWithoutProfileExportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfileExportsInput, UserUpdateWithoutProfileExportsInput>, UserUncheckedUpdateWithoutProfileExportsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumProfileStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProfileStatus | EnumProfileStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProfileStatus[] | ListEnumProfileStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProfileStatus[] | ListEnumProfileStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProfileStatusFilter<$PrismaModel> | $Enums.ProfileStatus
  }

  export type NestedEnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type NestedEnumMaritalStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.MaritalStatus | EnumMaritalStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMaritalStatusNullableFilter<$PrismaModel> | $Enums.MaritalStatus | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumFamilyTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.FamilyType | EnumFamilyTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.FamilyType[] | ListEnumFamilyTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FamilyType[] | ListEnumFamilyTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFamilyTypeNullableFilter<$PrismaModel> | $Enums.FamilyType | null
  }

  export type NestedEnumDietNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Diet | EnumDietFieldRefInput<$PrismaModel> | null
    in?: $Enums.Diet[] | ListEnumDietFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Diet[] | ListEnumDietFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDietNullableFilter<$PrismaModel> | $Enums.Diet | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumProfileStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProfileStatus | EnumProfileStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProfileStatus[] | ListEnumProfileStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProfileStatus[] | ListEnumProfileStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProfileStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProfileStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProfileStatusFilter<$PrismaModel>
    _max?: NestedEnumProfileStatusFilter<$PrismaModel>
  }

  export type NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumMaritalStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaritalStatus | EnumMaritalStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMaritalStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.MaritalStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumMaritalStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumMaritalStatusNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumFamilyTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FamilyType | EnumFamilyTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.FamilyType[] | ListEnumFamilyTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FamilyType[] | ListEnumFamilyTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFamilyTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.FamilyType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumFamilyTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumFamilyTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumDietNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Diet | EnumDietFieldRefInput<$PrismaModel> | null
    in?: $Enums.Diet[] | ListEnumDietFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Diet[] | ListEnumDietFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDietNullableWithAggregatesFilter<$PrismaModel> | $Enums.Diet | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDietNullableFilter<$PrismaModel>
    _max?: NestedEnumDietNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumInterestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InterestStatus | EnumInterestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InterestStatus[] | ListEnumInterestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterestStatus[] | ListEnumInterestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInterestStatusFilter<$PrismaModel> | $Enums.InterestStatus
  }

  export type NestedEnumInterestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InterestStatus | EnumInterestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InterestStatus[] | ListEnumInterestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterestStatus[] | ListEnumInterestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInterestStatusWithAggregatesFilter<$PrismaModel> | $Enums.InterestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInterestStatusFilter<$PrismaModel>
    _max?: NestedEnumInterestStatusFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionPlanFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionPlanFilter<$PrismaModel> | $Enums.SubscriptionPlan
  }

  export type NestedEnumSubscriptionPlanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionPlanWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionPlan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumAddOnTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AddOnType | EnumAddOnTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.AddOnType[] | ListEnumAddOnTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AddOnType[] | ListEnumAddOnTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAddOnTypeNullableFilter<$PrismaModel> | $Enums.AddOnType | null
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumAddOnTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AddOnType | EnumAddOnTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.AddOnType[] | ListEnumAddOnTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AddOnType[] | ListEnumAddOnTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAddOnTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.AddOnType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAddOnTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumAddOnTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumAddOnTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AddOnType | EnumAddOnTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AddOnType[] | ListEnumAddOnTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AddOnType[] | ListEnumAddOnTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAddOnTypeFilter<$PrismaModel> | $Enums.AddOnType
  }

  export type NestedEnumAddOnTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AddOnType | EnumAddOnTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AddOnType[] | ListEnumAddOnTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AddOnType[] | ListEnumAddOnTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAddOnTypeWithAggregatesFilter<$PrismaModel> | $Enums.AddOnType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAddOnTypeFilter<$PrismaModel>
    _max?: NestedEnumAddOnTypeFilter<$PrismaModel>
  }

  export type NestedEnumServiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceTypeFilter<$PrismaModel> | $Enums.ServiceType
  }

  export type NestedEnumServiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceStatus | EnumServiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceStatusFilter<$PrismaModel> | $Enums.ServiceStatus
  }

  export type NestedEnumServiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ServiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceTypeFilter<$PrismaModel>
    _max?: NestedEnumServiceTypeFilter<$PrismaModel>
  }

  export type NestedEnumServiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceStatus | EnumServiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.ServiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceStatusFilter<$PrismaModel>
    _max?: NestedEnumServiceStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ProfileCreateWithoutUserInput = {
    id?: string
    status?: $Enums.ProfileStatus
    firstName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    dateOfBirth?: Date | string | null
    height?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    religion?: string | null
    caste?: string | null
    motherTongue?: string | null
    manglik?: boolean | null
    gothra?: string | null
    country?: string | null
    state?: string | null
    city?: string | null
    citizenship?: string | null
    education?: string | null
    college?: string | null
    occupation?: string | null
    income?: number | null
    incomeCurrency?: string | null
    fatherOccupation?: string | null
    motherOccupation?: string | null
    siblings?: number | null
    familyType?: $Enums.FamilyType | null
    diet?: $Enums.Diet | null
    smoking?: boolean | null
    drinking?: boolean | null
    hobbies?: string | null
    partnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    videoIntroUrl?: string | null
    biodataUrl?: string | null
    aboutMe?: string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    privacySettings?: NullableJsonNullValueInput | InputJsonValue
    isHiddenFromSearch?: boolean
    isAnonymousViewing?: boolean
    contactPrivacyLevel?: string | null
    photoPrivacyLevel?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    trustScore?: number
    completenessScore?: number
    isHighlighted?: boolean
    slug?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: PhotoCreateNestedManyWithoutProfileInput
    profileViews?: ProfileViewCreateNestedManyWithoutProfileInput
    shortlistedBy?: ShortlistCreateNestedManyWithoutProfileInput
    horoscope?: HoroscopeCreateNestedOneWithoutProfileInput
    comparisons?: ProfileComparisonCreateNestedManyWithoutProfileInput
    testimonials?: TestimonialCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutUserInput = {
    id?: string
    status?: $Enums.ProfileStatus
    firstName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    dateOfBirth?: Date | string | null
    height?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    religion?: string | null
    caste?: string | null
    motherTongue?: string | null
    manglik?: boolean | null
    gothra?: string | null
    country?: string | null
    state?: string | null
    city?: string | null
    citizenship?: string | null
    education?: string | null
    college?: string | null
    occupation?: string | null
    income?: number | null
    incomeCurrency?: string | null
    fatherOccupation?: string | null
    motherOccupation?: string | null
    siblings?: number | null
    familyType?: $Enums.FamilyType | null
    diet?: $Enums.Diet | null
    smoking?: boolean | null
    drinking?: boolean | null
    hobbies?: string | null
    partnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    videoIntroUrl?: string | null
    biodataUrl?: string | null
    aboutMe?: string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    privacySettings?: NullableJsonNullValueInput | InputJsonValue
    isHiddenFromSearch?: boolean
    isAnonymousViewing?: boolean
    contactPrivacyLevel?: string | null
    photoPrivacyLevel?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    trustScore?: number
    completenessScore?: number
    isHighlighted?: boolean
    slug?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: PhotoUncheckedCreateNestedManyWithoutProfileInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutProfileInput
    shortlistedBy?: ShortlistUncheckedCreateNestedManyWithoutProfileInput
    horoscope?: HoroscopeUncheckedCreateNestedOneWithoutProfileInput
    comparisons?: ProfileComparisonUncheckedCreateNestedManyWithoutProfileInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutUserInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type InterestCreateWithoutFromUserInput = {
    id?: string
    status?: $Enums.InterestStatus
    message?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    toUser: UserCreateNestedOneWithoutReceivedInterestsInput
  }

  export type InterestUncheckedCreateWithoutFromUserInput = {
    id?: string
    toUserId: string
    status?: $Enums.InterestStatus
    message?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterestCreateOrConnectWithoutFromUserInput = {
    where: InterestWhereUniqueInput
    create: XOR<InterestCreateWithoutFromUserInput, InterestUncheckedCreateWithoutFromUserInput>
  }

  export type InterestCreateManyFromUserInputEnvelope = {
    data: InterestCreateManyFromUserInput | InterestCreateManyFromUserInput[]
    skipDuplicates?: boolean
  }

  export type InterestCreateWithoutToUserInput = {
    id?: string
    status?: $Enums.InterestStatus
    message?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fromUser: UserCreateNestedOneWithoutInterestsInput
  }

  export type InterestUncheckedCreateWithoutToUserInput = {
    id?: string
    fromUserId: string
    status?: $Enums.InterestStatus
    message?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterestCreateOrConnectWithoutToUserInput = {
    where: InterestWhereUniqueInput
    create: XOR<InterestCreateWithoutToUserInput, InterestUncheckedCreateWithoutToUserInput>
  }

  export type InterestCreateManyToUserInputEnvelope = {
    data: InterestCreateManyToUserInput | InterestCreateManyToUserInput[]
    skipDuplicates?: boolean
  }

  export type ChatCreateWithoutUser1Input = {
    id?: string
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user2: UserCreateNestedOneWithoutChats2Input
    messages?: MessageCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateWithoutUser1Input = {
    id?: string
    user2Id: string
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatCreateOrConnectWithoutUser1Input = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutUser1Input, ChatUncheckedCreateWithoutUser1Input>
  }

  export type ChatCreateManyUser1InputEnvelope = {
    data: ChatCreateManyUser1Input | ChatCreateManyUser1Input[]
    skipDuplicates?: boolean
  }

  export type ChatCreateWithoutUser2Input = {
    id?: string
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user1: UserCreateNestedOneWithoutChatsInput
    messages?: MessageCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateWithoutUser2Input = {
    id?: string
    user1Id: string
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatCreateOrConnectWithoutUser2Input = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutUser2Input, ChatUncheckedCreateWithoutUser2Input>
  }

  export type ChatCreateManyUser2InputEnvelope = {
    data: ChatCreateManyUser2Input | ChatCreateManyUser2Input[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    content?: string | null
    imageUrl?: string | null
    videoUrl?: string | null
    audioUrl?: string | null
    fileUrl?: string | null
    fileName?: string | null
    messageType?: string
    isRead?: boolean
    isDeleted?: boolean
    deletedBy?: MessageCreatedeletedByInput | string[]
    isReported?: boolean
    createdAt?: Date | string
    chat: ChatCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    chatId: string
    content?: string | null
    imageUrl?: string | null
    videoUrl?: string | null
    audioUrl?: string | null
    fileUrl?: string | null
    fileName?: string | null
    messageType?: string
    isRead?: boolean
    isDeleted?: boolean
    deletedBy?: MessageCreatedeletedByInput | string[]
    isReported?: boolean
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutUserInput = {
    id?: string
    plan: $Enums.SubscriptionPlan
    razorpaySubscriptionId?: string | null
    razorpayPlanId?: string | null
    status?: string
    startDate: Date | string
    endDate: Date | string
    contactViewsUsed?: number
    contactViewsLimit?: number | null
    profileBoostCredits?: number
    verifiedBadgeIncluded?: boolean
    horoscopeReportsIncluded?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    contactViews?: ContactViewCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    plan: $Enums.SubscriptionPlan
    razorpaySubscriptionId?: string | null
    razorpayPlanId?: string | null
    status?: string
    startDate: Date | string
    endDate: Date | string
    contactViewsUsed?: number
    contactViewsLimit?: number | null
    profileBoostCredits?: number
    verifiedBadgeIncluded?: boolean
    horoscopeReportsIncluded?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    contactViews?: ContactViewUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
  }

  export type SubscriptionCreateManyUserInputEnvelope = {
    data: SubscriptionCreateManyUserInput | SubscriptionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutUserInput = {
    id?: string
    razorpayOrderId?: string | null
    razorpayPaymentId?: string | null
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    type: string
    addOnType?: $Enums.AddOnType | null
    subscriptionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    addOns?: AddOnCreateNestedManyWithoutPaymentInput
    services?: ServiceCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutUserInput = {
    id?: string
    razorpayOrderId?: string | null
    razorpayPaymentId?: string | null
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    type: string
    addOnType?: $Enums.AddOnType | null
    subscriptionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    addOns?: AddOnUncheckedCreateNestedManyWithoutPaymentInput
    services?: ServiceUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutUserInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentCreateManyUserInputEnvelope = {
    data: PaymentCreateManyUserInput | PaymentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProfileViewCreateWithoutViewedByInput = {
    id?: string
    createdAt?: Date | string
    profile: ProfileCreateNestedOneWithoutProfileViewsInput
  }

  export type ProfileViewUncheckedCreateWithoutViewedByInput = {
    id?: string
    profileId: string
    createdAt?: Date | string
  }

  export type ProfileViewCreateOrConnectWithoutViewedByInput = {
    where: ProfileViewWhereUniqueInput
    create: XOR<ProfileViewCreateWithoutViewedByInput, ProfileViewUncheckedCreateWithoutViewedByInput>
  }

  export type ProfileViewCreateManyViewedByInputEnvelope = {
    data: ProfileViewCreateManyViewedByInput | ProfileViewCreateManyViewedByInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    message: string
    isRead?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    message: string
    isRead?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ShortlistCreateWithoutUserInput = {
    id?: string
    folderName?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutShortlistedByInput
  }

  export type ShortlistUncheckedCreateWithoutUserInput = {
    id?: string
    profileId: string
    folderName?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShortlistCreateOrConnectWithoutUserInput = {
    where: ShortlistWhereUniqueInput
    create: XOR<ShortlistCreateWithoutUserInput, ShortlistUncheckedCreateWithoutUserInput>
  }

  export type ShortlistCreateManyUserInputEnvelope = {
    data: ShortlistCreateManyUserInput | ShortlistCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BlockedUserCreateWithoutBlockerInput = {
    id?: string
    reason?: string | null
    createdAt?: Date | string
    blocked: UserCreateNestedOneWithoutBlockedByInput
  }

  export type BlockedUserUncheckedCreateWithoutBlockerInput = {
    id?: string
    blockedId: string
    reason?: string | null
    createdAt?: Date | string
  }

  export type BlockedUserCreateOrConnectWithoutBlockerInput = {
    where: BlockedUserWhereUniqueInput
    create: XOR<BlockedUserCreateWithoutBlockerInput, BlockedUserUncheckedCreateWithoutBlockerInput>
  }

  export type BlockedUserCreateManyBlockerInputEnvelope = {
    data: BlockedUserCreateManyBlockerInput | BlockedUserCreateManyBlockerInput[]
    skipDuplicates?: boolean
  }

  export type BlockedUserCreateWithoutBlockedInput = {
    id?: string
    reason?: string | null
    createdAt?: Date | string
    blocker: UserCreateNestedOneWithoutBlockedUsersInput
  }

  export type BlockedUserUncheckedCreateWithoutBlockedInput = {
    id?: string
    blockerId: string
    reason?: string | null
    createdAt?: Date | string
  }

  export type BlockedUserCreateOrConnectWithoutBlockedInput = {
    where: BlockedUserWhereUniqueInput
    create: XOR<BlockedUserCreateWithoutBlockedInput, BlockedUserUncheckedCreateWithoutBlockedInput>
  }

  export type BlockedUserCreateManyBlockedInputEnvelope = {
    data: BlockedUserCreateManyBlockedInput | BlockedUserCreateManyBlockedInput[]
    skipDuplicates?: boolean
  }

  export type ReferralCreateWithoutReferrerInput = {
    id?: string
    rewardAmount?: number | null
    status?: string
    completedAt?: Date | string | null
    createdAt?: Date | string
    referred: UserCreateNestedOneWithoutReferredByRefInput
  }

  export type ReferralUncheckedCreateWithoutReferrerInput = {
    id?: string
    referredId: string
    rewardAmount?: number | null
    status?: string
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ReferralCreateOrConnectWithoutReferrerInput = {
    where: ReferralWhereUniqueInput
    create: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput>
  }

  export type ReferralCreateManyReferrerInputEnvelope = {
    data: ReferralCreateManyReferrerInput | ReferralCreateManyReferrerInput[]
    skipDuplicates?: boolean
  }

  export type ReferralCreateWithoutReferredInput = {
    id?: string
    rewardAmount?: number | null
    status?: string
    completedAt?: Date | string | null
    createdAt?: Date | string
    referrer: UserCreateNestedOneWithoutReferralsInput
  }

  export type ReferralUncheckedCreateWithoutReferredInput = {
    id?: string
    referrerId: string
    rewardAmount?: number | null
    status?: string
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ReferralCreateOrConnectWithoutReferredInput = {
    where: ReferralWhereUniqueInput
    create: XOR<ReferralCreateWithoutReferredInput, ReferralUncheckedCreateWithoutReferredInput>
  }

  export type ReferralCreateManyReferredInputEnvelope = {
    data: ReferralCreateManyReferredInput | ReferralCreateManyReferredInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutReferredUsersInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    interests?: InterestCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    chats2?: ChatCreateNestedManyWithoutUser2Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReferredUsersInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReferredUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferredUsersInput, UserUncheckedCreateWithoutReferredUsersInput>
  }

  export type UserCreateWithoutReferrerInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    interests?: InterestCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    chats2?: ChatCreateNestedManyWithoutUser2Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReferrerInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReferrerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferrerInput, UserUncheckedCreateWithoutReferrerInput>
  }

  export type UserCreateManyReferrerInputEnvelope = {
    data: UserCreateManyReferrerInput | UserCreateManyReferrerInput[]
    skipDuplicates?: boolean
  }

  export type AchievementCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    description?: string | null
    points?: number
    icon?: string | null
    unlockedAt?: Date | string
  }

  export type AchievementUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    description?: string | null
    points?: number
    icon?: string | null
    unlockedAt?: Date | string
  }

  export type AchievementCreateOrConnectWithoutUserInput = {
    where: AchievementWhereUniqueInput
    create: XOR<AchievementCreateWithoutUserInput, AchievementUncheckedCreateWithoutUserInput>
  }

  export type AchievementCreateManyUserInputEnvelope = {
    data: AchievementCreateManyUserInput | AchievementCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type HoroscopeCreateWithoutUserInput = {
    id?: string
    horoscopeUrl?: string | null
    birthTime?: string | null
    birthPlace?: string | null
    rashi?: string | null
    nakshatra?: string | null
    mangalDosha?: boolean | null
    horoscopeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutHoroscopeInput
    matches1?: HoroscopeMatchCreateNestedManyWithoutHoroscope1Input
    matches2?: HoroscopeMatchCreateNestedManyWithoutHoroscope2Input
  }

  export type HoroscopeUncheckedCreateWithoutUserInput = {
    id?: string
    profileId: string
    horoscopeUrl?: string | null
    birthTime?: string | null
    birthPlace?: string | null
    rashi?: string | null
    nakshatra?: string | null
    mangalDosha?: boolean | null
    horoscopeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    matches1?: HoroscopeMatchUncheckedCreateNestedManyWithoutHoroscope1Input
    matches2?: HoroscopeMatchUncheckedCreateNestedManyWithoutHoroscope2Input
  }

  export type HoroscopeCreateOrConnectWithoutUserInput = {
    where: HoroscopeWhereUniqueInput
    create: XOR<HoroscopeCreateWithoutUserInput, HoroscopeUncheckedCreateWithoutUserInput>
  }

  export type HoroscopeCreateManyUserInputEnvelope = {
    data: HoroscopeCreateManyUserInput | HoroscopeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FamilyMemberCreateWithoutUserInput = {
    id?: string
    name: string
    relation: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    canViewMatches?: boolean
    canSendInterests?: boolean
    canChat?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FamilyMemberUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    relation: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    canViewMatches?: boolean
    canSendInterests?: boolean
    canChat?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FamilyMemberCreateOrConnectWithoutUserInput = {
    where: FamilyMemberWhereUniqueInput
    create: XOR<FamilyMemberCreateWithoutUserInput, FamilyMemberUncheckedCreateWithoutUserInput>
  }

  export type FamilyMemberCreateManyUserInputEnvelope = {
    data: FamilyMemberCreateManyUserInput | FamilyMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SuccessStoryCreateWithoutUserInput = {
    id?: string
    partnerId: string
    title: string
    story: string
    weddingDate?: Date | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: boolean
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SuccessStoryUncheckedCreateWithoutUserInput = {
    id?: string
    partnerId: string
    title: string
    story: string
    weddingDate?: Date | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: boolean
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SuccessStoryCreateOrConnectWithoutUserInput = {
    where: SuccessStoryWhereUniqueInput
    create: XOR<SuccessStoryCreateWithoutUserInput, SuccessStoryUncheckedCreateWithoutUserInput>
  }

  export type SuccessStoryCreateManyUserInputEnvelope = {
    data: SuccessStoryCreateManyUserInput | SuccessStoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutUserInput = {
    id?: string
    type: string
    name: string
    url: string
    expiryDate?: Date | string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    name: string
    url: string
    expiryDate?: Date | string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateOrConnectWithoutUserInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput>
  }

  export type DocumentCreateManyUserInputEnvelope = {
    data: DocumentCreateManyUserInput | DocumentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type VideoCallCreateWithoutCallerInput = {
    id?: string
    status?: string
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    cancelledAt?: Date | string | null
    duration?: number | null
    roomId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    participant: UserCreateNestedOneWithoutVideoCallsAsParticipantInput
  }

  export type VideoCallUncheckedCreateWithoutCallerInput = {
    id?: string
    participantId: string
    status?: string
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    cancelledAt?: Date | string | null
    duration?: number | null
    roomId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCallCreateOrConnectWithoutCallerInput = {
    where: VideoCallWhereUniqueInput
    create: XOR<VideoCallCreateWithoutCallerInput, VideoCallUncheckedCreateWithoutCallerInput>
  }

  export type VideoCallCreateManyCallerInputEnvelope = {
    data: VideoCallCreateManyCallerInput | VideoCallCreateManyCallerInput[]
    skipDuplicates?: boolean
  }

  export type VideoCallCreateWithoutParticipantInput = {
    id?: string
    status?: string
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    cancelledAt?: Date | string | null
    duration?: number | null
    roomId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    caller: UserCreateNestedOneWithoutVideoCallsAsCallerInput
  }

  export type VideoCallUncheckedCreateWithoutParticipantInput = {
    id?: string
    callerId: string
    status?: string
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    cancelledAt?: Date | string | null
    duration?: number | null
    roomId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCallCreateOrConnectWithoutParticipantInput = {
    where: VideoCallWhereUniqueInput
    create: XOR<VideoCallCreateWithoutParticipantInput, VideoCallUncheckedCreateWithoutParticipantInput>
  }

  export type VideoCallCreateManyParticipantInputEnvelope = {
    data: VideoCallCreateManyParticipantInput | VideoCallCreateManyParticipantInput[]
    skipDuplicates?: boolean
  }

  export type ForumPostCreateWithoutUserInput = {
    id?: string
    title: string
    content: string
    category?: string | null
    tags?: ForumPostCreatetagsInput | string[]
    likes?: number
    views?: number
    isPinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ForumCommentCreateNestedManyWithoutPostInput
  }

  export type ForumPostUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    content: string
    category?: string | null
    tags?: ForumPostCreatetagsInput | string[]
    likes?: number
    views?: number
    isPinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ForumCommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type ForumPostCreateOrConnectWithoutUserInput = {
    where: ForumPostWhereUniqueInput
    create: XOR<ForumPostCreateWithoutUserInput, ForumPostUncheckedCreateWithoutUserInput>
  }

  export type ForumPostCreateManyUserInputEnvelope = {
    data: ForumPostCreateManyUserInput | ForumPostCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ForumCommentCreateWithoutUserInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    post: ForumPostCreateNestedOneWithoutCommentsInput
  }

  export type ForumCommentUncheckedCreateWithoutUserInput = {
    id?: string
    postId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumCommentCreateOrConnectWithoutUserInput = {
    where: ForumCommentWhereUniqueInput
    create: XOR<ForumCommentCreateWithoutUserInput, ForumCommentUncheckedCreateWithoutUserInput>
  }

  export type ForumCommentCreateManyUserInputEnvelope = {
    data: ForumCommentCreateManyUserInput | ForumCommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GroupMemberCreateWithoutUserInput = {
    id?: string
    role?: string
    joinedAt?: Date | string
    group: CommunityGroupCreateNestedOneWithoutMembersInput
  }

  export type GroupMemberUncheckedCreateWithoutUserInput = {
    id?: string
    groupId: string
    role?: string
    joinedAt?: Date | string
  }

  export type GroupMemberCreateOrConnectWithoutUserInput = {
    where: GroupMemberWhereUniqueInput
    create: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput>
  }

  export type GroupMemberCreateManyUserInputEnvelope = {
    data: GroupMemberCreateManyUserInput | GroupMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EventParticipantCreateWithoutUserInput = {
    id?: string
    joinedAt?: Date | string
    event: CommunityEventCreateNestedOneWithoutParticipantsInput
  }

  export type EventParticipantUncheckedCreateWithoutUserInput = {
    id?: string
    eventId: string
    joinedAt?: Date | string
  }

  export type EventParticipantCreateOrConnectWithoutUserInput = {
    where: EventParticipantWhereUniqueInput
    create: XOR<EventParticipantCreateWithoutUserInput, EventParticipantUncheckedCreateWithoutUserInput>
  }

  export type EventParticipantCreateManyUserInputEnvelope = {
    data: EventParticipantCreateManyUserInput | EventParticipantCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BlogPostCreateWithoutUserInput = {
    id?: string
    title: string
    content: string
    excerpt?: string | null
    photoUrl?: string | null
    tags?: BlogPostCreatetagsInput | string[]
    isPublished?: boolean
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogPostUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    content: string
    excerpt?: string | null
    photoUrl?: string | null
    tags?: BlogPostCreatetagsInput | string[]
    isPublished?: boolean
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogPostCreateOrConnectWithoutUserInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutUserInput, BlogPostUncheckedCreateWithoutUserInput>
  }

  export type BlogPostCreateManyUserInputEnvelope = {
    data: BlogPostCreateManyUserInput | BlogPostCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MatchScoreCreateWithoutUserInput = {
    id?: string
    overallScore: number
    religionScore?: number | null
    educationScore?: number | null
    lifestyleScore?: number | null
    locationScore?: number | null
    familyScore?: number | null
    matchReasons?: NullableJsonNullValueInput | InputJsonValue
    isReverseMatch?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    matchedUser: UserCreateNestedOneWithoutMatchedByInput
  }

  export type MatchScoreUncheckedCreateWithoutUserInput = {
    id?: string
    matchedUserId: string
    overallScore: number
    religionScore?: number | null
    educationScore?: number | null
    lifestyleScore?: number | null
    locationScore?: number | null
    familyScore?: number | null
    matchReasons?: NullableJsonNullValueInput | InputJsonValue
    isReverseMatch?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchScoreCreateOrConnectWithoutUserInput = {
    where: MatchScoreWhereUniqueInput
    create: XOR<MatchScoreCreateWithoutUserInput, MatchScoreUncheckedCreateWithoutUserInput>
  }

  export type MatchScoreCreateManyUserInputEnvelope = {
    data: MatchScoreCreateManyUserInput | MatchScoreCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MatchScoreCreateWithoutMatchedUserInput = {
    id?: string
    overallScore: number
    religionScore?: number | null
    educationScore?: number | null
    lifestyleScore?: number | null
    locationScore?: number | null
    familyScore?: number | null
    matchReasons?: NullableJsonNullValueInput | InputJsonValue
    isReverseMatch?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMatchScoresInput
  }

  export type MatchScoreUncheckedCreateWithoutMatchedUserInput = {
    id?: string
    userId: string
    overallScore: number
    religionScore?: number | null
    educationScore?: number | null
    lifestyleScore?: number | null
    locationScore?: number | null
    familyScore?: number | null
    matchReasons?: NullableJsonNullValueInput | InputJsonValue
    isReverseMatch?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchScoreCreateOrConnectWithoutMatchedUserInput = {
    where: MatchScoreWhereUniqueInput
    create: XOR<MatchScoreCreateWithoutMatchedUserInput, MatchScoreUncheckedCreateWithoutMatchedUserInput>
  }

  export type MatchScoreCreateManyMatchedUserInputEnvelope = {
    data: MatchScoreCreateManyMatchedUserInput | MatchScoreCreateManyMatchedUserInput[]
    skipDuplicates?: boolean
  }

  export type SearchHistoryCreateWithoutUserInput = {
    id?: string
    profileId?: string | null
    searchQuery?: string | null
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SearchHistoryUncheckedCreateWithoutUserInput = {
    id?: string
    profileId?: string | null
    searchQuery?: string | null
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SearchHistoryCreateOrConnectWithoutUserInput = {
    where: SearchHistoryWhereUniqueInput
    create: XOR<SearchHistoryCreateWithoutUserInput, SearchHistoryUncheckedCreateWithoutUserInput>
  }

  export type SearchHistoryCreateManyUserInputEnvelope = {
    data: SearchHistoryCreateManyUserInput | SearchHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageTemplateCreateWithoutUserInput = {
    id?: string
    name: string
    content: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageTemplateUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    content: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageTemplateCreateOrConnectWithoutUserInput = {
    where: MessageTemplateWhereUniqueInput
    create: XOR<MessageTemplateCreateWithoutUserInput, MessageTemplateUncheckedCreateWithoutUserInput>
  }

  export type MessageTemplateCreateManyUserInputEnvelope = {
    data: MessageTemplateCreateManyUserInput | MessageTemplateCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type IceBreakerCreateWithoutUserInput = {
    id?: string
    profileId: string
    question: string
    answer?: string | null
    createdAt?: Date | string
  }

  export type IceBreakerUncheckedCreateWithoutUserInput = {
    id?: string
    profileId: string
    question: string
    answer?: string | null
    createdAt?: Date | string
  }

  export type IceBreakerCreateOrConnectWithoutUserInput = {
    where: IceBreakerWhereUniqueInput
    create: XOR<IceBreakerCreateWithoutUserInput, IceBreakerUncheckedCreateWithoutUserInput>
  }

  export type IceBreakerCreateManyUserInputEnvelope = {
    data: IceBreakerCreateManyUserInput | IceBreakerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ActivityCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ActivityUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ActivityCreateOrConnectWithoutUserInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput>
  }

  export type ActivityCreateManyUserInputEnvelope = {
    data: ActivityCreateManyUserInput | ActivityCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LeaderboardCreateWithoutUserInput = {
    id?: string
    category: string
    rank: number
    score: number
    period: string
    periodStart: Date | string
    periodEnd?: Date | string | null
    createdAt?: Date | string
  }

  export type LeaderboardUncheckedCreateWithoutUserInput = {
    id?: string
    category: string
    rank: number
    score: number
    period: string
    periodStart: Date | string
    periodEnd?: Date | string | null
    createdAt?: Date | string
  }

  export type LeaderboardCreateOrConnectWithoutUserInput = {
    where: LeaderboardWhereUniqueInput
    create: XOR<LeaderboardCreateWithoutUserInput, LeaderboardUncheckedCreateWithoutUserInput>
  }

  export type LeaderboardCreateManyUserInputEnvelope = {
    data: LeaderboardCreateManyUserInput | LeaderboardCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WishlistCreateWithoutUserInput = {
    id?: string
    criteria: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WishlistUncheckedCreateWithoutUserInput = {
    id?: string
    criteria: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WishlistCreateOrConnectWithoutUserInput = {
    where: WishlistWhereUniqueInput
    create: XOR<WishlistCreateWithoutUserInput, WishlistUncheckedCreateWithoutUserInput>
  }

  export type WishlistCreateManyUserInputEnvelope = {
    data: WishlistCreateManyUserInput | WishlistCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProfileExportCreateWithoutUserInput = {
    id?: string
    format: string
    url: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type ProfileExportUncheckedCreateWithoutUserInput = {
    id?: string
    format: string
    url: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type ProfileExportCreateOrConnectWithoutUserInput = {
    where: ProfileExportWhereUniqueInput
    create: XOR<ProfileExportCreateWithoutUserInput, ProfileExportUncheckedCreateWithoutUserInput>
  }

  export type ProfileExportCreateManyUserInputEnvelope = {
    data: ProfileExportCreateManyUserInput | ProfileExportCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ServiceCreateWithoutUserInput = {
    id?: string
    type: $Enums.ServiceType
    status?: $Enums.ServiceStatus
    amount: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    notes?: string | null
    rating?: number | null
    review?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payment?: PaymentCreateNestedOneWithoutServicesInput
    bookings?: ServiceBookingCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.ServiceType
    status?: $Enums.ServiceStatus
    paymentId?: string | null
    amount: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    notes?: string | null
    rating?: number | null
    review?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: ServiceBookingUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutUserInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutUserInput, ServiceUncheckedCreateWithoutUserInput>
  }

  export type ServiceCreateManyUserInputEnvelope = {
    data: ServiceCreateManyUserInput | ServiceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ServiceBookingCreateWithoutUserInput = {
    id?: string
    scheduledAt?: Date | string | null
    duration?: number | null
    status?: $Enums.ServiceStatus
    meetingLink?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service: ServiceCreateNestedOneWithoutBookingsInput
    provider?: ServiceProviderCreateNestedOneWithoutBookingsInput
  }

  export type ServiceBookingUncheckedCreateWithoutUserInput = {
    id?: string
    serviceId: string
    providerId?: string | null
    scheduledAt?: Date | string | null
    duration?: number | null
    status?: $Enums.ServiceStatus
    meetingLink?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceBookingCreateOrConnectWithoutUserInput = {
    where: ServiceBookingWhereUniqueInput
    create: XOR<ServiceBookingCreateWithoutUserInput, ServiceBookingUncheckedCreateWithoutUserInput>
  }

  export type ServiceBookingCreateManyUserInputEnvelope = {
    data: ServiceBookingCreateManyUserInput | ServiceBookingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProfileUpsertWithoutUserInput = {
    update: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type ProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    caste?: NullableStringFieldUpdateOperationsInput | string | null
    motherTongue?: NullableStringFieldUpdateOperationsInput | string | null
    manglik?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gothra?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableIntFieldUpdateOperationsInput | number | null
    incomeCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    fatherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    motherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    siblings?: NullableIntFieldUpdateOperationsInput | number | null
    familyType?: NullableEnumFamilyTypeFieldUpdateOperationsInput | $Enums.FamilyType | null
    diet?: NullableEnumDietFieldUpdateOperationsInput | $Enums.Diet | null
    smoking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    drinking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hobbies?: NullableStringFieldUpdateOperationsInput | string | null
    partnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    videoIntroUrl?: NullableStringFieldUpdateOperationsInput | string | null
    biodataUrl?: NullableStringFieldUpdateOperationsInput | string | null
    aboutMe?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    privacySettings?: NullableJsonNullValueInput | InputJsonValue
    isHiddenFromSearch?: BoolFieldUpdateOperationsInput | boolean
    isAnonymousViewing?: BoolFieldUpdateOperationsInput | boolean
    contactPrivacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    photoPrivacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    completenessScore?: IntFieldUpdateOperationsInput | number
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: PhotoUpdateManyWithoutProfileNestedInput
    profileViews?: ProfileViewUpdateManyWithoutProfileNestedInput
    shortlistedBy?: ShortlistUpdateManyWithoutProfileNestedInput
    horoscope?: HoroscopeUpdateOneWithoutProfileNestedInput
    comparisons?: ProfileComparisonUpdateManyWithoutProfileNestedInput
    testimonials?: TestimonialUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    caste?: NullableStringFieldUpdateOperationsInput | string | null
    motherTongue?: NullableStringFieldUpdateOperationsInput | string | null
    manglik?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gothra?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableIntFieldUpdateOperationsInput | number | null
    incomeCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    fatherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    motherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    siblings?: NullableIntFieldUpdateOperationsInput | number | null
    familyType?: NullableEnumFamilyTypeFieldUpdateOperationsInput | $Enums.FamilyType | null
    diet?: NullableEnumDietFieldUpdateOperationsInput | $Enums.Diet | null
    smoking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    drinking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hobbies?: NullableStringFieldUpdateOperationsInput | string | null
    partnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    videoIntroUrl?: NullableStringFieldUpdateOperationsInput | string | null
    biodataUrl?: NullableStringFieldUpdateOperationsInput | string | null
    aboutMe?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    privacySettings?: NullableJsonNullValueInput | InputJsonValue
    isHiddenFromSearch?: BoolFieldUpdateOperationsInput | boolean
    isAnonymousViewing?: BoolFieldUpdateOperationsInput | boolean
    contactPrivacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    photoPrivacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    completenessScore?: IntFieldUpdateOperationsInput | number
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: PhotoUncheckedUpdateManyWithoutProfileNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutProfileNestedInput
    shortlistedBy?: ShortlistUncheckedUpdateManyWithoutProfileNestedInput
    horoscope?: HoroscopeUncheckedUpdateOneWithoutProfileNestedInput
    comparisons?: ProfileComparisonUncheckedUpdateManyWithoutProfileNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type InterestUpsertWithWhereUniqueWithoutFromUserInput = {
    where: InterestWhereUniqueInput
    update: XOR<InterestUpdateWithoutFromUserInput, InterestUncheckedUpdateWithoutFromUserInput>
    create: XOR<InterestCreateWithoutFromUserInput, InterestUncheckedCreateWithoutFromUserInput>
  }

  export type InterestUpdateWithWhereUniqueWithoutFromUserInput = {
    where: InterestWhereUniqueInput
    data: XOR<InterestUpdateWithoutFromUserInput, InterestUncheckedUpdateWithoutFromUserInput>
  }

  export type InterestUpdateManyWithWhereWithoutFromUserInput = {
    where: InterestScalarWhereInput
    data: XOR<InterestUpdateManyMutationInput, InterestUncheckedUpdateManyWithoutFromUserInput>
  }

  export type InterestScalarWhereInput = {
    AND?: InterestScalarWhereInput | InterestScalarWhereInput[]
    OR?: InterestScalarWhereInput[]
    NOT?: InterestScalarWhereInput | InterestScalarWhereInput[]
    id?: StringFilter<"Interest"> | string
    fromUserId?: StringFilter<"Interest"> | string
    toUserId?: StringFilter<"Interest"> | string
    status?: EnumInterestStatusFilter<"Interest"> | $Enums.InterestStatus
    message?: StringNullableFilter<"Interest"> | string | null
    createdAt?: DateTimeFilter<"Interest"> | Date | string
    updatedAt?: DateTimeFilter<"Interest"> | Date | string
  }

  export type InterestUpsertWithWhereUniqueWithoutToUserInput = {
    where: InterestWhereUniqueInput
    update: XOR<InterestUpdateWithoutToUserInput, InterestUncheckedUpdateWithoutToUserInput>
    create: XOR<InterestCreateWithoutToUserInput, InterestUncheckedCreateWithoutToUserInput>
  }

  export type InterestUpdateWithWhereUniqueWithoutToUserInput = {
    where: InterestWhereUniqueInput
    data: XOR<InterestUpdateWithoutToUserInput, InterestUncheckedUpdateWithoutToUserInput>
  }

  export type InterestUpdateManyWithWhereWithoutToUserInput = {
    where: InterestScalarWhereInput
    data: XOR<InterestUpdateManyMutationInput, InterestUncheckedUpdateManyWithoutToUserInput>
  }

  export type ChatUpsertWithWhereUniqueWithoutUser1Input = {
    where: ChatWhereUniqueInput
    update: XOR<ChatUpdateWithoutUser1Input, ChatUncheckedUpdateWithoutUser1Input>
    create: XOR<ChatCreateWithoutUser1Input, ChatUncheckedCreateWithoutUser1Input>
  }

  export type ChatUpdateWithWhereUniqueWithoutUser1Input = {
    where: ChatWhereUniqueInput
    data: XOR<ChatUpdateWithoutUser1Input, ChatUncheckedUpdateWithoutUser1Input>
  }

  export type ChatUpdateManyWithWhereWithoutUser1Input = {
    where: ChatScalarWhereInput
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyWithoutUser1Input>
  }

  export type ChatScalarWhereInput = {
    AND?: ChatScalarWhereInput | ChatScalarWhereInput[]
    OR?: ChatScalarWhereInput[]
    NOT?: ChatScalarWhereInput | ChatScalarWhereInput[]
    id?: StringFilter<"Chat"> | string
    user1Id?: StringFilter<"Chat"> | string
    user2Id?: StringFilter<"Chat"> | string
    lastMessageAt?: DateTimeNullableFilter<"Chat"> | Date | string | null
    createdAt?: DateTimeFilter<"Chat"> | Date | string
    updatedAt?: DateTimeFilter<"Chat"> | Date | string
  }

  export type ChatUpsertWithWhereUniqueWithoutUser2Input = {
    where: ChatWhereUniqueInput
    update: XOR<ChatUpdateWithoutUser2Input, ChatUncheckedUpdateWithoutUser2Input>
    create: XOR<ChatCreateWithoutUser2Input, ChatUncheckedCreateWithoutUser2Input>
  }

  export type ChatUpdateWithWhereUniqueWithoutUser2Input = {
    where: ChatWhereUniqueInput
    data: XOR<ChatUpdateWithoutUser2Input, ChatUncheckedUpdateWithoutUser2Input>
  }

  export type ChatUpdateManyWithWhereWithoutUser2Input = {
    where: ChatScalarWhereInput
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyWithoutUser2Input>
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    chatId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    content?: StringNullableFilter<"Message"> | string | null
    imageUrl?: StringNullableFilter<"Message"> | string | null
    videoUrl?: StringNullableFilter<"Message"> | string | null
    audioUrl?: StringNullableFilter<"Message"> | string | null
    fileUrl?: StringNullableFilter<"Message"> | string | null
    fileName?: StringNullableFilter<"Message"> | string | null
    messageType?: StringFilter<"Message"> | string
    isRead?: BoolFilter<"Message"> | boolean
    isDeleted?: BoolFilter<"Message"> | boolean
    deletedBy?: StringNullableListFilter<"Message">
    isReported?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutUserInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutUserInput>
  }

  export type SubscriptionScalarWhereInput = {
    AND?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    OR?: SubscriptionScalarWhereInput[]
    NOT?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    id?: StringFilter<"Subscription"> | string
    userId?: StringFilter<"Subscription"> | string
    plan?: EnumSubscriptionPlanFilter<"Subscription"> | $Enums.SubscriptionPlan
    razorpaySubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    razorpayPlanId?: StringNullableFilter<"Subscription"> | string | null
    status?: StringFilter<"Subscription"> | string
    startDate?: DateTimeFilter<"Subscription"> | Date | string
    endDate?: DateTimeFilter<"Subscription"> | Date | string
    contactViewsUsed?: IntFilter<"Subscription"> | number
    contactViewsLimit?: IntNullableFilter<"Subscription"> | number | null
    profileBoostCredits?: IntFilter<"Subscription"> | number
    verifiedBadgeIncluded?: BoolFilter<"Subscription"> | boolean
    horoscopeReportsIncluded?: IntFilter<"Subscription"> | number
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
  }

  export type PaymentUpdateManyWithWhereWithoutUserInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutUserInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    razorpayOrderId?: StringNullableFilter<"Payment"> | string | null
    razorpayPaymentId?: StringNullableFilter<"Payment"> | string | null
    amount?: IntFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    type?: StringFilter<"Payment"> | string
    addOnType?: EnumAddOnTypeNullableFilter<"Payment"> | $Enums.AddOnType | null
    subscriptionId?: StringNullableFilter<"Payment"> | string | null
    metadata?: JsonNullableFilter<"Payment">
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type ProfileViewUpsertWithWhereUniqueWithoutViewedByInput = {
    where: ProfileViewWhereUniqueInput
    update: XOR<ProfileViewUpdateWithoutViewedByInput, ProfileViewUncheckedUpdateWithoutViewedByInput>
    create: XOR<ProfileViewCreateWithoutViewedByInput, ProfileViewUncheckedCreateWithoutViewedByInput>
  }

  export type ProfileViewUpdateWithWhereUniqueWithoutViewedByInput = {
    where: ProfileViewWhereUniqueInput
    data: XOR<ProfileViewUpdateWithoutViewedByInput, ProfileViewUncheckedUpdateWithoutViewedByInput>
  }

  export type ProfileViewUpdateManyWithWhereWithoutViewedByInput = {
    where: ProfileViewScalarWhereInput
    data: XOR<ProfileViewUpdateManyMutationInput, ProfileViewUncheckedUpdateManyWithoutViewedByInput>
  }

  export type ProfileViewScalarWhereInput = {
    AND?: ProfileViewScalarWhereInput | ProfileViewScalarWhereInput[]
    OR?: ProfileViewScalarWhereInput[]
    NOT?: ProfileViewScalarWhereInput | ProfileViewScalarWhereInput[]
    id?: StringFilter<"ProfileView"> | string
    profileId?: StringFilter<"ProfileView"> | string
    viewedById?: StringFilter<"ProfileView"> | string
    createdAt?: DateTimeFilter<"ProfileView"> | Date | string
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type ShortlistUpsertWithWhereUniqueWithoutUserInput = {
    where: ShortlistWhereUniqueInput
    update: XOR<ShortlistUpdateWithoutUserInput, ShortlistUncheckedUpdateWithoutUserInput>
    create: XOR<ShortlistCreateWithoutUserInput, ShortlistUncheckedCreateWithoutUserInput>
  }

  export type ShortlistUpdateWithWhereUniqueWithoutUserInput = {
    where: ShortlistWhereUniqueInput
    data: XOR<ShortlistUpdateWithoutUserInput, ShortlistUncheckedUpdateWithoutUserInput>
  }

  export type ShortlistUpdateManyWithWhereWithoutUserInput = {
    where: ShortlistScalarWhereInput
    data: XOR<ShortlistUpdateManyMutationInput, ShortlistUncheckedUpdateManyWithoutUserInput>
  }

  export type ShortlistScalarWhereInput = {
    AND?: ShortlistScalarWhereInput | ShortlistScalarWhereInput[]
    OR?: ShortlistScalarWhereInput[]
    NOT?: ShortlistScalarWhereInput | ShortlistScalarWhereInput[]
    id?: StringFilter<"Shortlist"> | string
    userId?: StringFilter<"Shortlist"> | string
    profileId?: StringFilter<"Shortlist"> | string
    folderName?: StringNullableFilter<"Shortlist"> | string | null
    notes?: StringNullableFilter<"Shortlist"> | string | null
    createdAt?: DateTimeFilter<"Shortlist"> | Date | string
    updatedAt?: DateTimeFilter<"Shortlist"> | Date | string
  }

  export type BlockedUserUpsertWithWhereUniqueWithoutBlockerInput = {
    where: BlockedUserWhereUniqueInput
    update: XOR<BlockedUserUpdateWithoutBlockerInput, BlockedUserUncheckedUpdateWithoutBlockerInput>
    create: XOR<BlockedUserCreateWithoutBlockerInput, BlockedUserUncheckedCreateWithoutBlockerInput>
  }

  export type BlockedUserUpdateWithWhereUniqueWithoutBlockerInput = {
    where: BlockedUserWhereUniqueInput
    data: XOR<BlockedUserUpdateWithoutBlockerInput, BlockedUserUncheckedUpdateWithoutBlockerInput>
  }

  export type BlockedUserUpdateManyWithWhereWithoutBlockerInput = {
    where: BlockedUserScalarWhereInput
    data: XOR<BlockedUserUpdateManyMutationInput, BlockedUserUncheckedUpdateManyWithoutBlockerInput>
  }

  export type BlockedUserScalarWhereInput = {
    AND?: BlockedUserScalarWhereInput | BlockedUserScalarWhereInput[]
    OR?: BlockedUserScalarWhereInput[]
    NOT?: BlockedUserScalarWhereInput | BlockedUserScalarWhereInput[]
    id?: StringFilter<"BlockedUser"> | string
    blockerId?: StringFilter<"BlockedUser"> | string
    blockedId?: StringFilter<"BlockedUser"> | string
    reason?: StringNullableFilter<"BlockedUser"> | string | null
    createdAt?: DateTimeFilter<"BlockedUser"> | Date | string
  }

  export type BlockedUserUpsertWithWhereUniqueWithoutBlockedInput = {
    where: BlockedUserWhereUniqueInput
    update: XOR<BlockedUserUpdateWithoutBlockedInput, BlockedUserUncheckedUpdateWithoutBlockedInput>
    create: XOR<BlockedUserCreateWithoutBlockedInput, BlockedUserUncheckedCreateWithoutBlockedInput>
  }

  export type BlockedUserUpdateWithWhereUniqueWithoutBlockedInput = {
    where: BlockedUserWhereUniqueInput
    data: XOR<BlockedUserUpdateWithoutBlockedInput, BlockedUserUncheckedUpdateWithoutBlockedInput>
  }

  export type BlockedUserUpdateManyWithWhereWithoutBlockedInput = {
    where: BlockedUserScalarWhereInput
    data: XOR<BlockedUserUpdateManyMutationInput, BlockedUserUncheckedUpdateManyWithoutBlockedInput>
  }

  export type ReferralUpsertWithWhereUniqueWithoutReferrerInput = {
    where: ReferralWhereUniqueInput
    update: XOR<ReferralUpdateWithoutReferrerInput, ReferralUncheckedUpdateWithoutReferrerInput>
    create: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput>
  }

  export type ReferralUpdateWithWhereUniqueWithoutReferrerInput = {
    where: ReferralWhereUniqueInput
    data: XOR<ReferralUpdateWithoutReferrerInput, ReferralUncheckedUpdateWithoutReferrerInput>
  }

  export type ReferralUpdateManyWithWhereWithoutReferrerInput = {
    where: ReferralScalarWhereInput
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyWithoutReferrerInput>
  }

  export type ReferralScalarWhereInput = {
    AND?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
    OR?: ReferralScalarWhereInput[]
    NOT?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
    id?: StringFilter<"Referral"> | string
    referrerId?: StringFilter<"Referral"> | string
    referredId?: StringFilter<"Referral"> | string
    rewardAmount?: IntNullableFilter<"Referral"> | number | null
    status?: StringFilter<"Referral"> | string
    completedAt?: DateTimeNullableFilter<"Referral"> | Date | string | null
    createdAt?: DateTimeFilter<"Referral"> | Date | string
  }

  export type ReferralUpsertWithWhereUniqueWithoutReferredInput = {
    where: ReferralWhereUniqueInput
    update: XOR<ReferralUpdateWithoutReferredInput, ReferralUncheckedUpdateWithoutReferredInput>
    create: XOR<ReferralCreateWithoutReferredInput, ReferralUncheckedCreateWithoutReferredInput>
  }

  export type ReferralUpdateWithWhereUniqueWithoutReferredInput = {
    where: ReferralWhereUniqueInput
    data: XOR<ReferralUpdateWithoutReferredInput, ReferralUncheckedUpdateWithoutReferredInput>
  }

  export type ReferralUpdateManyWithWhereWithoutReferredInput = {
    where: ReferralScalarWhereInput
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyWithoutReferredInput>
  }

  export type UserUpsertWithoutReferredUsersInput = {
    update: XOR<UserUpdateWithoutReferredUsersInput, UserUncheckedUpdateWithoutReferredUsersInput>
    create: XOR<UserCreateWithoutReferredUsersInput, UserUncheckedCreateWithoutReferredUsersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReferredUsersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReferredUsersInput, UserUncheckedUpdateWithoutReferredUsersInput>
  }

  export type UserUpdateWithoutReferredUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReferredUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutReferrerInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutReferrerInput, UserUncheckedUpdateWithoutReferrerInput>
    create: XOR<UserCreateWithoutReferrerInput, UserUncheckedCreateWithoutReferrerInput>
  }

  export type UserUpdateWithWhereUniqueWithoutReferrerInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutReferrerInput, UserUncheckedUpdateWithoutReferrerInput>
  }

  export type UserUpdateManyWithWhereWithoutReferrerInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutReferrerInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    mobile?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isEmailVerified?: BoolFilter<"User"> | boolean
    isMobileVerified?: BoolFilter<"User"> | boolean
    googleId?: StringNullableFilter<"User"> | string | null
    appleId?: StringNullableFilter<"User"> | string | null
    fcmToken?: StringNullableFilter<"User"> | string | null
    referralCode?: StringNullableFilter<"User"> | string | null
    referredBy?: StringNullableFilter<"User"> | string | null
    points?: IntFilter<"User"> | number
    lastActiveAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isOnline?: BoolFilter<"User"> | boolean
    lastLoginDate?: DateTimeNullableFilter<"User"> | Date | string | null
    loginStreak?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    gdprConsent?: BoolFilter<"User"> | boolean
    gdprConsentAt?: DateTimeNullableFilter<"User"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    preferredLanguage?: StringNullableFilter<"User"> | string | null
    notificationPreferences?: JsonNullableFilter<"User">
  }

  export type AchievementUpsertWithWhereUniqueWithoutUserInput = {
    where: AchievementWhereUniqueInput
    update: XOR<AchievementUpdateWithoutUserInput, AchievementUncheckedUpdateWithoutUserInput>
    create: XOR<AchievementCreateWithoutUserInput, AchievementUncheckedCreateWithoutUserInput>
  }

  export type AchievementUpdateWithWhereUniqueWithoutUserInput = {
    where: AchievementWhereUniqueInput
    data: XOR<AchievementUpdateWithoutUserInput, AchievementUncheckedUpdateWithoutUserInput>
  }

  export type AchievementUpdateManyWithWhereWithoutUserInput = {
    where: AchievementScalarWhereInput
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyWithoutUserInput>
  }

  export type AchievementScalarWhereInput = {
    AND?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
    OR?: AchievementScalarWhereInput[]
    NOT?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
    id?: StringFilter<"Achievement"> | string
    userId?: StringFilter<"Achievement"> | string
    type?: StringFilter<"Achievement"> | string
    title?: StringFilter<"Achievement"> | string
    description?: StringNullableFilter<"Achievement"> | string | null
    points?: IntFilter<"Achievement"> | number
    icon?: StringNullableFilter<"Achievement"> | string | null
    unlockedAt?: DateTimeFilter<"Achievement"> | Date | string
  }

  export type HoroscopeUpsertWithWhereUniqueWithoutUserInput = {
    where: HoroscopeWhereUniqueInput
    update: XOR<HoroscopeUpdateWithoutUserInput, HoroscopeUncheckedUpdateWithoutUserInput>
    create: XOR<HoroscopeCreateWithoutUserInput, HoroscopeUncheckedCreateWithoutUserInput>
  }

  export type HoroscopeUpdateWithWhereUniqueWithoutUserInput = {
    where: HoroscopeWhereUniqueInput
    data: XOR<HoroscopeUpdateWithoutUserInput, HoroscopeUncheckedUpdateWithoutUserInput>
  }

  export type HoroscopeUpdateManyWithWhereWithoutUserInput = {
    where: HoroscopeScalarWhereInput
    data: XOR<HoroscopeUpdateManyMutationInput, HoroscopeUncheckedUpdateManyWithoutUserInput>
  }

  export type HoroscopeScalarWhereInput = {
    AND?: HoroscopeScalarWhereInput | HoroscopeScalarWhereInput[]
    OR?: HoroscopeScalarWhereInput[]
    NOT?: HoroscopeScalarWhereInput | HoroscopeScalarWhereInput[]
    id?: StringFilter<"Horoscope"> | string
    userId?: StringFilter<"Horoscope"> | string
    profileId?: StringFilter<"Horoscope"> | string
    horoscopeUrl?: StringNullableFilter<"Horoscope"> | string | null
    birthTime?: StringNullableFilter<"Horoscope"> | string | null
    birthPlace?: StringNullableFilter<"Horoscope"> | string | null
    rashi?: StringNullableFilter<"Horoscope"> | string | null
    nakshatra?: StringNullableFilter<"Horoscope"> | string | null
    mangalDosha?: BoolNullableFilter<"Horoscope"> | boolean | null
    horoscopeData?: JsonNullableFilter<"Horoscope">
    createdAt?: DateTimeFilter<"Horoscope"> | Date | string
    updatedAt?: DateTimeFilter<"Horoscope"> | Date | string
  }

  export type FamilyMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: FamilyMemberWhereUniqueInput
    update: XOR<FamilyMemberUpdateWithoutUserInput, FamilyMemberUncheckedUpdateWithoutUserInput>
    create: XOR<FamilyMemberCreateWithoutUserInput, FamilyMemberUncheckedCreateWithoutUserInput>
  }

  export type FamilyMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: FamilyMemberWhereUniqueInput
    data: XOR<FamilyMemberUpdateWithoutUserInput, FamilyMemberUncheckedUpdateWithoutUserInput>
  }

  export type FamilyMemberUpdateManyWithWhereWithoutUserInput = {
    where: FamilyMemberScalarWhereInput
    data: XOR<FamilyMemberUpdateManyMutationInput, FamilyMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type FamilyMemberScalarWhereInput = {
    AND?: FamilyMemberScalarWhereInput | FamilyMemberScalarWhereInput[]
    OR?: FamilyMemberScalarWhereInput[]
    NOT?: FamilyMemberScalarWhereInput | FamilyMemberScalarWhereInput[]
    id?: StringFilter<"FamilyMember"> | string
    userId?: StringFilter<"FamilyMember"> | string
    name?: StringFilter<"FamilyMember"> | string
    relation?: StringFilter<"FamilyMember"> | string
    email?: StringNullableFilter<"FamilyMember"> | string | null
    mobile?: StringNullableFilter<"FamilyMember"> | string | null
    password?: StringNullableFilter<"FamilyMember"> | string | null
    canViewMatches?: BoolFilter<"FamilyMember"> | boolean
    canSendInterests?: BoolFilter<"FamilyMember"> | boolean
    canChat?: BoolFilter<"FamilyMember"> | boolean
    createdAt?: DateTimeFilter<"FamilyMember"> | Date | string
    updatedAt?: DateTimeFilter<"FamilyMember"> | Date | string
  }

  export type SuccessStoryUpsertWithWhereUniqueWithoutUserInput = {
    where: SuccessStoryWhereUniqueInput
    update: XOR<SuccessStoryUpdateWithoutUserInput, SuccessStoryUncheckedUpdateWithoutUserInput>
    create: XOR<SuccessStoryCreateWithoutUserInput, SuccessStoryUncheckedCreateWithoutUserInput>
  }

  export type SuccessStoryUpdateWithWhereUniqueWithoutUserInput = {
    where: SuccessStoryWhereUniqueInput
    data: XOR<SuccessStoryUpdateWithoutUserInput, SuccessStoryUncheckedUpdateWithoutUserInput>
  }

  export type SuccessStoryUpdateManyWithWhereWithoutUserInput = {
    where: SuccessStoryScalarWhereInput
    data: XOR<SuccessStoryUpdateManyMutationInput, SuccessStoryUncheckedUpdateManyWithoutUserInput>
  }

  export type SuccessStoryScalarWhereInput = {
    AND?: SuccessStoryScalarWhereInput | SuccessStoryScalarWhereInput[]
    OR?: SuccessStoryScalarWhereInput[]
    NOT?: SuccessStoryScalarWhereInput | SuccessStoryScalarWhereInput[]
    id?: StringFilter<"SuccessStory"> | string
    userId?: StringFilter<"SuccessStory"> | string
    partnerId?: StringFilter<"SuccessStory"> | string
    title?: StringFilter<"SuccessStory"> | string
    story?: StringFilter<"SuccessStory"> | string
    weddingDate?: DateTimeNullableFilter<"SuccessStory"> | Date | string | null
    photos?: JsonNullableFilter<"SuccessStory">
    isApproved?: BoolFilter<"SuccessStory"> | boolean
    isFeatured?: BoolFilter<"SuccessStory"> | boolean
    createdAt?: DateTimeFilter<"SuccessStory"> | Date | string
    updatedAt?: DateTimeFilter<"SuccessStory"> | Date | string
  }

  export type DocumentUpsertWithWhereUniqueWithoutUserInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutUserInput, DocumentUncheckedUpdateWithoutUserInput>
    create: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutUserInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutUserInput, DocumentUncheckedUpdateWithoutUserInput>
  }

  export type DocumentUpdateManyWithWhereWithoutUserInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutUserInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter<"Document"> | string
    userId?: StringFilter<"Document"> | string
    type?: StringFilter<"Document"> | string
    name?: StringFilter<"Document"> | string
    url?: StringFilter<"Document"> | string
    expiryDate?: DateTimeNullableFilter<"Document"> | Date | string | null
    isVerified?: BoolFilter<"Document"> | boolean
    verifiedAt?: DateTimeNullableFilter<"Document"> | Date | string | null
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
  }

  export type VideoCallUpsertWithWhereUniqueWithoutCallerInput = {
    where: VideoCallWhereUniqueInput
    update: XOR<VideoCallUpdateWithoutCallerInput, VideoCallUncheckedUpdateWithoutCallerInput>
    create: XOR<VideoCallCreateWithoutCallerInput, VideoCallUncheckedCreateWithoutCallerInput>
  }

  export type VideoCallUpdateWithWhereUniqueWithoutCallerInput = {
    where: VideoCallWhereUniqueInput
    data: XOR<VideoCallUpdateWithoutCallerInput, VideoCallUncheckedUpdateWithoutCallerInput>
  }

  export type VideoCallUpdateManyWithWhereWithoutCallerInput = {
    where: VideoCallScalarWhereInput
    data: XOR<VideoCallUpdateManyMutationInput, VideoCallUncheckedUpdateManyWithoutCallerInput>
  }

  export type VideoCallScalarWhereInput = {
    AND?: VideoCallScalarWhereInput | VideoCallScalarWhereInput[]
    OR?: VideoCallScalarWhereInput[]
    NOT?: VideoCallScalarWhereInput | VideoCallScalarWhereInput[]
    id?: StringFilter<"VideoCall"> | string
    callerId?: StringFilter<"VideoCall"> | string
    participantId?: StringFilter<"VideoCall"> | string
    status?: StringFilter<"VideoCall"> | string
    scheduledAt?: DateTimeNullableFilter<"VideoCall"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"VideoCall"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"VideoCall"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"VideoCall"> | Date | string | null
    duration?: IntNullableFilter<"VideoCall"> | number | null
    roomId?: StringNullableFilter<"VideoCall"> | string | null
    notes?: StringNullableFilter<"VideoCall"> | string | null
    createdAt?: DateTimeFilter<"VideoCall"> | Date | string
    updatedAt?: DateTimeFilter<"VideoCall"> | Date | string
  }

  export type VideoCallUpsertWithWhereUniqueWithoutParticipantInput = {
    where: VideoCallWhereUniqueInput
    update: XOR<VideoCallUpdateWithoutParticipantInput, VideoCallUncheckedUpdateWithoutParticipantInput>
    create: XOR<VideoCallCreateWithoutParticipantInput, VideoCallUncheckedCreateWithoutParticipantInput>
  }

  export type VideoCallUpdateWithWhereUniqueWithoutParticipantInput = {
    where: VideoCallWhereUniqueInput
    data: XOR<VideoCallUpdateWithoutParticipantInput, VideoCallUncheckedUpdateWithoutParticipantInput>
  }

  export type VideoCallUpdateManyWithWhereWithoutParticipantInput = {
    where: VideoCallScalarWhereInput
    data: XOR<VideoCallUpdateManyMutationInput, VideoCallUncheckedUpdateManyWithoutParticipantInput>
  }

  export type ForumPostUpsertWithWhereUniqueWithoutUserInput = {
    where: ForumPostWhereUniqueInput
    update: XOR<ForumPostUpdateWithoutUserInput, ForumPostUncheckedUpdateWithoutUserInput>
    create: XOR<ForumPostCreateWithoutUserInput, ForumPostUncheckedCreateWithoutUserInput>
  }

  export type ForumPostUpdateWithWhereUniqueWithoutUserInput = {
    where: ForumPostWhereUniqueInput
    data: XOR<ForumPostUpdateWithoutUserInput, ForumPostUncheckedUpdateWithoutUserInput>
  }

  export type ForumPostUpdateManyWithWhereWithoutUserInput = {
    where: ForumPostScalarWhereInput
    data: XOR<ForumPostUpdateManyMutationInput, ForumPostUncheckedUpdateManyWithoutUserInput>
  }

  export type ForumPostScalarWhereInput = {
    AND?: ForumPostScalarWhereInput | ForumPostScalarWhereInput[]
    OR?: ForumPostScalarWhereInput[]
    NOT?: ForumPostScalarWhereInput | ForumPostScalarWhereInput[]
    id?: StringFilter<"ForumPost"> | string
    userId?: StringFilter<"ForumPost"> | string
    title?: StringFilter<"ForumPost"> | string
    content?: StringFilter<"ForumPost"> | string
    category?: StringNullableFilter<"ForumPost"> | string | null
    tags?: StringNullableListFilter<"ForumPost">
    likes?: IntFilter<"ForumPost"> | number
    views?: IntFilter<"ForumPost"> | number
    isPinned?: BoolFilter<"ForumPost"> | boolean
    createdAt?: DateTimeFilter<"ForumPost"> | Date | string
    updatedAt?: DateTimeFilter<"ForumPost"> | Date | string
  }

  export type ForumCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: ForumCommentWhereUniqueInput
    update: XOR<ForumCommentUpdateWithoutUserInput, ForumCommentUncheckedUpdateWithoutUserInput>
    create: XOR<ForumCommentCreateWithoutUserInput, ForumCommentUncheckedCreateWithoutUserInput>
  }

  export type ForumCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: ForumCommentWhereUniqueInput
    data: XOR<ForumCommentUpdateWithoutUserInput, ForumCommentUncheckedUpdateWithoutUserInput>
  }

  export type ForumCommentUpdateManyWithWhereWithoutUserInput = {
    where: ForumCommentScalarWhereInput
    data: XOR<ForumCommentUpdateManyMutationInput, ForumCommentUncheckedUpdateManyWithoutUserInput>
  }

  export type ForumCommentScalarWhereInput = {
    AND?: ForumCommentScalarWhereInput | ForumCommentScalarWhereInput[]
    OR?: ForumCommentScalarWhereInput[]
    NOT?: ForumCommentScalarWhereInput | ForumCommentScalarWhereInput[]
    id?: StringFilter<"ForumComment"> | string
    userId?: StringFilter<"ForumComment"> | string
    postId?: StringFilter<"ForumComment"> | string
    content?: StringFilter<"ForumComment"> | string
    createdAt?: DateTimeFilter<"ForumComment"> | Date | string
    updatedAt?: DateTimeFilter<"ForumComment"> | Date | string
  }

  export type GroupMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: GroupMemberWhereUniqueInput
    update: XOR<GroupMemberUpdateWithoutUserInput, GroupMemberUncheckedUpdateWithoutUserInput>
    create: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput>
  }

  export type GroupMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: GroupMemberWhereUniqueInput
    data: XOR<GroupMemberUpdateWithoutUserInput, GroupMemberUncheckedUpdateWithoutUserInput>
  }

  export type GroupMemberUpdateManyWithWhereWithoutUserInput = {
    where: GroupMemberScalarWhereInput
    data: XOR<GroupMemberUpdateManyMutationInput, GroupMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type GroupMemberScalarWhereInput = {
    AND?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
    OR?: GroupMemberScalarWhereInput[]
    NOT?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
    id?: StringFilter<"GroupMember"> | string
    groupId?: StringFilter<"GroupMember"> | string
    userId?: StringFilter<"GroupMember"> | string
    role?: StringFilter<"GroupMember"> | string
    joinedAt?: DateTimeFilter<"GroupMember"> | Date | string
  }

  export type EventParticipantUpsertWithWhereUniqueWithoutUserInput = {
    where: EventParticipantWhereUniqueInput
    update: XOR<EventParticipantUpdateWithoutUserInput, EventParticipantUncheckedUpdateWithoutUserInput>
    create: XOR<EventParticipantCreateWithoutUserInput, EventParticipantUncheckedCreateWithoutUserInput>
  }

  export type EventParticipantUpdateWithWhereUniqueWithoutUserInput = {
    where: EventParticipantWhereUniqueInput
    data: XOR<EventParticipantUpdateWithoutUserInput, EventParticipantUncheckedUpdateWithoutUserInput>
  }

  export type EventParticipantUpdateManyWithWhereWithoutUserInput = {
    where: EventParticipantScalarWhereInput
    data: XOR<EventParticipantUpdateManyMutationInput, EventParticipantUncheckedUpdateManyWithoutUserInput>
  }

  export type EventParticipantScalarWhereInput = {
    AND?: EventParticipantScalarWhereInput | EventParticipantScalarWhereInput[]
    OR?: EventParticipantScalarWhereInput[]
    NOT?: EventParticipantScalarWhereInput | EventParticipantScalarWhereInput[]
    id?: StringFilter<"EventParticipant"> | string
    eventId?: StringFilter<"EventParticipant"> | string
    userId?: StringFilter<"EventParticipant"> | string
    joinedAt?: DateTimeFilter<"EventParticipant"> | Date | string
  }

  export type BlogPostUpsertWithWhereUniqueWithoutUserInput = {
    where: BlogPostWhereUniqueInput
    update: XOR<BlogPostUpdateWithoutUserInput, BlogPostUncheckedUpdateWithoutUserInput>
    create: XOR<BlogPostCreateWithoutUserInput, BlogPostUncheckedCreateWithoutUserInput>
  }

  export type BlogPostUpdateWithWhereUniqueWithoutUserInput = {
    where: BlogPostWhereUniqueInput
    data: XOR<BlogPostUpdateWithoutUserInput, BlogPostUncheckedUpdateWithoutUserInput>
  }

  export type BlogPostUpdateManyWithWhereWithoutUserInput = {
    where: BlogPostScalarWhereInput
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyWithoutUserInput>
  }

  export type BlogPostScalarWhereInput = {
    AND?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
    OR?: BlogPostScalarWhereInput[]
    NOT?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
    id?: StringFilter<"BlogPost"> | string
    userId?: StringFilter<"BlogPost"> | string
    title?: StringFilter<"BlogPost"> | string
    content?: StringFilter<"BlogPost"> | string
    excerpt?: StringNullableFilter<"BlogPost"> | string | null
    photoUrl?: StringNullableFilter<"BlogPost"> | string | null
    tags?: StringNullableListFilter<"BlogPost">
    isPublished?: BoolFilter<"BlogPost"> | boolean
    views?: IntFilter<"BlogPost"> | number
    createdAt?: DateTimeFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeFilter<"BlogPost"> | Date | string
  }

  export type MatchScoreUpsertWithWhereUniqueWithoutUserInput = {
    where: MatchScoreWhereUniqueInput
    update: XOR<MatchScoreUpdateWithoutUserInput, MatchScoreUncheckedUpdateWithoutUserInput>
    create: XOR<MatchScoreCreateWithoutUserInput, MatchScoreUncheckedCreateWithoutUserInput>
  }

  export type MatchScoreUpdateWithWhereUniqueWithoutUserInput = {
    where: MatchScoreWhereUniqueInput
    data: XOR<MatchScoreUpdateWithoutUserInput, MatchScoreUncheckedUpdateWithoutUserInput>
  }

  export type MatchScoreUpdateManyWithWhereWithoutUserInput = {
    where: MatchScoreScalarWhereInput
    data: XOR<MatchScoreUpdateManyMutationInput, MatchScoreUncheckedUpdateManyWithoutUserInput>
  }

  export type MatchScoreScalarWhereInput = {
    AND?: MatchScoreScalarWhereInput | MatchScoreScalarWhereInput[]
    OR?: MatchScoreScalarWhereInput[]
    NOT?: MatchScoreScalarWhereInput | MatchScoreScalarWhereInput[]
    id?: StringFilter<"MatchScore"> | string
    userId?: StringFilter<"MatchScore"> | string
    matchedUserId?: StringFilter<"MatchScore"> | string
    overallScore?: IntFilter<"MatchScore"> | number
    religionScore?: IntNullableFilter<"MatchScore"> | number | null
    educationScore?: IntNullableFilter<"MatchScore"> | number | null
    lifestyleScore?: IntNullableFilter<"MatchScore"> | number | null
    locationScore?: IntNullableFilter<"MatchScore"> | number | null
    familyScore?: IntNullableFilter<"MatchScore"> | number | null
    matchReasons?: JsonNullableFilter<"MatchScore">
    isReverseMatch?: BoolFilter<"MatchScore"> | boolean
    createdAt?: DateTimeFilter<"MatchScore"> | Date | string
    updatedAt?: DateTimeFilter<"MatchScore"> | Date | string
  }

  export type MatchScoreUpsertWithWhereUniqueWithoutMatchedUserInput = {
    where: MatchScoreWhereUniqueInput
    update: XOR<MatchScoreUpdateWithoutMatchedUserInput, MatchScoreUncheckedUpdateWithoutMatchedUserInput>
    create: XOR<MatchScoreCreateWithoutMatchedUserInput, MatchScoreUncheckedCreateWithoutMatchedUserInput>
  }

  export type MatchScoreUpdateWithWhereUniqueWithoutMatchedUserInput = {
    where: MatchScoreWhereUniqueInput
    data: XOR<MatchScoreUpdateWithoutMatchedUserInput, MatchScoreUncheckedUpdateWithoutMatchedUserInput>
  }

  export type MatchScoreUpdateManyWithWhereWithoutMatchedUserInput = {
    where: MatchScoreScalarWhereInput
    data: XOR<MatchScoreUpdateManyMutationInput, MatchScoreUncheckedUpdateManyWithoutMatchedUserInput>
  }

  export type SearchHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: SearchHistoryWhereUniqueInput
    update: XOR<SearchHistoryUpdateWithoutUserInput, SearchHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<SearchHistoryCreateWithoutUserInput, SearchHistoryUncheckedCreateWithoutUserInput>
  }

  export type SearchHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: SearchHistoryWhereUniqueInput
    data: XOR<SearchHistoryUpdateWithoutUserInput, SearchHistoryUncheckedUpdateWithoutUserInput>
  }

  export type SearchHistoryUpdateManyWithWhereWithoutUserInput = {
    where: SearchHistoryScalarWhereInput
    data: XOR<SearchHistoryUpdateManyMutationInput, SearchHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type SearchHistoryScalarWhereInput = {
    AND?: SearchHistoryScalarWhereInput | SearchHistoryScalarWhereInput[]
    OR?: SearchHistoryScalarWhereInput[]
    NOT?: SearchHistoryScalarWhereInput | SearchHistoryScalarWhereInput[]
    id?: StringFilter<"SearchHistory"> | string
    userId?: StringFilter<"SearchHistory"> | string
    profileId?: StringNullableFilter<"SearchHistory"> | string | null
    searchQuery?: StringNullableFilter<"SearchHistory"> | string | null
    filters?: JsonNullableFilter<"SearchHistory">
    createdAt?: DateTimeFilter<"SearchHistory"> | Date | string
  }

  export type MessageTemplateUpsertWithWhereUniqueWithoutUserInput = {
    where: MessageTemplateWhereUniqueInput
    update: XOR<MessageTemplateUpdateWithoutUserInput, MessageTemplateUncheckedUpdateWithoutUserInput>
    create: XOR<MessageTemplateCreateWithoutUserInput, MessageTemplateUncheckedCreateWithoutUserInput>
  }

  export type MessageTemplateUpdateWithWhereUniqueWithoutUserInput = {
    where: MessageTemplateWhereUniqueInput
    data: XOR<MessageTemplateUpdateWithoutUserInput, MessageTemplateUncheckedUpdateWithoutUserInput>
  }

  export type MessageTemplateUpdateManyWithWhereWithoutUserInput = {
    where: MessageTemplateScalarWhereInput
    data: XOR<MessageTemplateUpdateManyMutationInput, MessageTemplateUncheckedUpdateManyWithoutUserInput>
  }

  export type MessageTemplateScalarWhereInput = {
    AND?: MessageTemplateScalarWhereInput | MessageTemplateScalarWhereInput[]
    OR?: MessageTemplateScalarWhereInput[]
    NOT?: MessageTemplateScalarWhereInput | MessageTemplateScalarWhereInput[]
    id?: StringFilter<"MessageTemplate"> | string
    userId?: StringFilter<"MessageTemplate"> | string
    name?: StringFilter<"MessageTemplate"> | string
    content?: StringFilter<"MessageTemplate"> | string
    category?: StringNullableFilter<"MessageTemplate"> | string | null
    createdAt?: DateTimeFilter<"MessageTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"MessageTemplate"> | Date | string
  }

  export type IceBreakerUpsertWithWhereUniqueWithoutUserInput = {
    where: IceBreakerWhereUniqueInput
    update: XOR<IceBreakerUpdateWithoutUserInput, IceBreakerUncheckedUpdateWithoutUserInput>
    create: XOR<IceBreakerCreateWithoutUserInput, IceBreakerUncheckedCreateWithoutUserInput>
  }

  export type IceBreakerUpdateWithWhereUniqueWithoutUserInput = {
    where: IceBreakerWhereUniqueInput
    data: XOR<IceBreakerUpdateWithoutUserInput, IceBreakerUncheckedUpdateWithoutUserInput>
  }

  export type IceBreakerUpdateManyWithWhereWithoutUserInput = {
    where: IceBreakerScalarWhereInput
    data: XOR<IceBreakerUpdateManyMutationInput, IceBreakerUncheckedUpdateManyWithoutUserInput>
  }

  export type IceBreakerScalarWhereInput = {
    AND?: IceBreakerScalarWhereInput | IceBreakerScalarWhereInput[]
    OR?: IceBreakerScalarWhereInput[]
    NOT?: IceBreakerScalarWhereInput | IceBreakerScalarWhereInput[]
    id?: StringFilter<"IceBreaker"> | string
    userId?: StringFilter<"IceBreaker"> | string
    profileId?: StringFilter<"IceBreaker"> | string
    question?: StringFilter<"IceBreaker"> | string
    answer?: StringNullableFilter<"IceBreaker"> | string | null
    createdAt?: DateTimeFilter<"IceBreaker"> | Date | string
  }

  export type ActivityUpsertWithWhereUniqueWithoutUserInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutUserInput, ActivityUncheckedUpdateWithoutUserInput>
    create: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutUserInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutUserInput, ActivityUncheckedUpdateWithoutUserInput>
  }

  export type ActivityUpdateManyWithWhereWithoutUserInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutUserInput>
  }

  export type ActivityScalarWhereInput = {
    AND?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    OR?: ActivityScalarWhereInput[]
    NOT?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    id?: StringFilter<"Activity"> | string
    userId?: StringFilter<"Activity"> | string
    type?: StringFilter<"Activity"> | string
    title?: StringFilter<"Activity"> | string
    description?: StringNullableFilter<"Activity"> | string | null
    metadata?: JsonNullableFilter<"Activity">
    createdAt?: DateTimeFilter<"Activity"> | Date | string
  }

  export type LeaderboardUpsertWithWhereUniqueWithoutUserInput = {
    where: LeaderboardWhereUniqueInput
    update: XOR<LeaderboardUpdateWithoutUserInput, LeaderboardUncheckedUpdateWithoutUserInput>
    create: XOR<LeaderboardCreateWithoutUserInput, LeaderboardUncheckedCreateWithoutUserInput>
  }

  export type LeaderboardUpdateWithWhereUniqueWithoutUserInput = {
    where: LeaderboardWhereUniqueInput
    data: XOR<LeaderboardUpdateWithoutUserInput, LeaderboardUncheckedUpdateWithoutUserInput>
  }

  export type LeaderboardUpdateManyWithWhereWithoutUserInput = {
    where: LeaderboardScalarWhereInput
    data: XOR<LeaderboardUpdateManyMutationInput, LeaderboardUncheckedUpdateManyWithoutUserInput>
  }

  export type LeaderboardScalarWhereInput = {
    AND?: LeaderboardScalarWhereInput | LeaderboardScalarWhereInput[]
    OR?: LeaderboardScalarWhereInput[]
    NOT?: LeaderboardScalarWhereInput | LeaderboardScalarWhereInput[]
    id?: StringFilter<"Leaderboard"> | string
    userId?: StringFilter<"Leaderboard"> | string
    category?: StringFilter<"Leaderboard"> | string
    rank?: IntFilter<"Leaderboard"> | number
    score?: IntFilter<"Leaderboard"> | number
    period?: StringFilter<"Leaderboard"> | string
    periodStart?: DateTimeFilter<"Leaderboard"> | Date | string
    periodEnd?: DateTimeNullableFilter<"Leaderboard"> | Date | string | null
    createdAt?: DateTimeFilter<"Leaderboard"> | Date | string
  }

  export type WishlistUpsertWithWhereUniqueWithoutUserInput = {
    where: WishlistWhereUniqueInput
    update: XOR<WishlistUpdateWithoutUserInput, WishlistUncheckedUpdateWithoutUserInput>
    create: XOR<WishlistCreateWithoutUserInput, WishlistUncheckedCreateWithoutUserInput>
  }

  export type WishlistUpdateWithWhereUniqueWithoutUserInput = {
    where: WishlistWhereUniqueInput
    data: XOR<WishlistUpdateWithoutUserInput, WishlistUncheckedUpdateWithoutUserInput>
  }

  export type WishlistUpdateManyWithWhereWithoutUserInput = {
    where: WishlistScalarWhereInput
    data: XOR<WishlistUpdateManyMutationInput, WishlistUncheckedUpdateManyWithoutUserInput>
  }

  export type WishlistScalarWhereInput = {
    AND?: WishlistScalarWhereInput | WishlistScalarWhereInput[]
    OR?: WishlistScalarWhereInput[]
    NOT?: WishlistScalarWhereInput | WishlistScalarWhereInput[]
    id?: StringFilter<"Wishlist"> | string
    userId?: StringFilter<"Wishlist"> | string
    criteria?: JsonFilter<"Wishlist">
    isActive?: BoolFilter<"Wishlist"> | boolean
    createdAt?: DateTimeFilter<"Wishlist"> | Date | string
    updatedAt?: DateTimeFilter<"Wishlist"> | Date | string
  }

  export type ProfileExportUpsertWithWhereUniqueWithoutUserInput = {
    where: ProfileExportWhereUniqueInput
    update: XOR<ProfileExportUpdateWithoutUserInput, ProfileExportUncheckedUpdateWithoutUserInput>
    create: XOR<ProfileExportCreateWithoutUserInput, ProfileExportUncheckedCreateWithoutUserInput>
  }

  export type ProfileExportUpdateWithWhereUniqueWithoutUserInput = {
    where: ProfileExportWhereUniqueInput
    data: XOR<ProfileExportUpdateWithoutUserInput, ProfileExportUncheckedUpdateWithoutUserInput>
  }

  export type ProfileExportUpdateManyWithWhereWithoutUserInput = {
    where: ProfileExportScalarWhereInput
    data: XOR<ProfileExportUpdateManyMutationInput, ProfileExportUncheckedUpdateManyWithoutUserInput>
  }

  export type ProfileExportScalarWhereInput = {
    AND?: ProfileExportScalarWhereInput | ProfileExportScalarWhereInput[]
    OR?: ProfileExportScalarWhereInput[]
    NOT?: ProfileExportScalarWhereInput | ProfileExportScalarWhereInput[]
    id?: StringFilter<"ProfileExport"> | string
    userId?: StringFilter<"ProfileExport"> | string
    format?: StringFilter<"ProfileExport"> | string
    url?: StringFilter<"ProfileExport"> | string
    expiresAt?: DateTimeFilter<"ProfileExport"> | Date | string
    createdAt?: DateTimeFilter<"ProfileExport"> | Date | string
  }

  export type ServiceUpsertWithWhereUniqueWithoutUserInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutUserInput, ServiceUncheckedUpdateWithoutUserInput>
    create: XOR<ServiceCreateWithoutUserInput, ServiceUncheckedCreateWithoutUserInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutUserInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutUserInput, ServiceUncheckedUpdateWithoutUserInput>
  }

  export type ServiceUpdateManyWithWhereWithoutUserInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutUserInput>
  }

  export type ServiceScalarWhereInput = {
    AND?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    OR?: ServiceScalarWhereInput[]
    NOT?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    id?: StringFilter<"Service"> | string
    userId?: StringFilter<"Service"> | string
    type?: EnumServiceTypeFilter<"Service"> | $Enums.ServiceType
    status?: EnumServiceStatusFilter<"Service"> | $Enums.ServiceStatus
    paymentId?: StringNullableFilter<"Service"> | string | null
    amount?: IntFilter<"Service"> | number
    metadata?: JsonNullableFilter<"Service">
    scheduledAt?: DateTimeNullableFilter<"Service"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Service"> | Date | string | null
    notes?: StringNullableFilter<"Service"> | string | null
    rating?: IntNullableFilter<"Service"> | number | null
    review?: StringNullableFilter<"Service"> | string | null
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
  }

  export type ServiceBookingUpsertWithWhereUniqueWithoutUserInput = {
    where: ServiceBookingWhereUniqueInput
    update: XOR<ServiceBookingUpdateWithoutUserInput, ServiceBookingUncheckedUpdateWithoutUserInput>
    create: XOR<ServiceBookingCreateWithoutUserInput, ServiceBookingUncheckedCreateWithoutUserInput>
  }

  export type ServiceBookingUpdateWithWhereUniqueWithoutUserInput = {
    where: ServiceBookingWhereUniqueInput
    data: XOR<ServiceBookingUpdateWithoutUserInput, ServiceBookingUncheckedUpdateWithoutUserInput>
  }

  export type ServiceBookingUpdateManyWithWhereWithoutUserInput = {
    where: ServiceBookingScalarWhereInput
    data: XOR<ServiceBookingUpdateManyMutationInput, ServiceBookingUncheckedUpdateManyWithoutUserInput>
  }

  export type ServiceBookingScalarWhereInput = {
    AND?: ServiceBookingScalarWhereInput | ServiceBookingScalarWhereInput[]
    OR?: ServiceBookingScalarWhereInput[]
    NOT?: ServiceBookingScalarWhereInput | ServiceBookingScalarWhereInput[]
    id?: StringFilter<"ServiceBooking"> | string
    serviceId?: StringFilter<"ServiceBooking"> | string
    providerId?: StringNullableFilter<"ServiceBooking"> | string | null
    userId?: StringFilter<"ServiceBooking"> | string
    scheduledAt?: DateTimeNullableFilter<"ServiceBooking"> | Date | string | null
    duration?: IntNullableFilter<"ServiceBooking"> | number | null
    status?: EnumServiceStatusFilter<"ServiceBooking"> | $Enums.ServiceStatus
    meetingLink?: StringNullableFilter<"ServiceBooking"> | string | null
    notes?: StringNullableFilter<"ServiceBooking"> | string | null
    createdAt?: DateTimeFilter<"ServiceBooking"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceBooking"> | Date | string
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    interests?: InterestCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    chats2?: ChatCreateNestedManyWithoutUser2Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PhotoCreateWithoutProfileInput = {
    id?: string
    url: string
    cloudinaryId?: string | null
    isPrimary?: boolean
    isBlurred?: boolean
    isApproved?: boolean
    order?: number
    albumName?: string | null
    caption?: string | null
    createdAt?: Date | string
  }

  export type PhotoUncheckedCreateWithoutProfileInput = {
    id?: string
    url: string
    cloudinaryId?: string | null
    isPrimary?: boolean
    isBlurred?: boolean
    isApproved?: boolean
    order?: number
    albumName?: string | null
    caption?: string | null
    createdAt?: Date | string
  }

  export type PhotoCreateOrConnectWithoutProfileInput = {
    where: PhotoWhereUniqueInput
    create: XOR<PhotoCreateWithoutProfileInput, PhotoUncheckedCreateWithoutProfileInput>
  }

  export type PhotoCreateManyProfileInputEnvelope = {
    data: PhotoCreateManyProfileInput | PhotoCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type ProfileViewCreateWithoutProfileInput = {
    id?: string
    createdAt?: Date | string
    viewedBy: UserCreateNestedOneWithoutProfileViewsInput
  }

  export type ProfileViewUncheckedCreateWithoutProfileInput = {
    id?: string
    viewedById: string
    createdAt?: Date | string
  }

  export type ProfileViewCreateOrConnectWithoutProfileInput = {
    where: ProfileViewWhereUniqueInput
    create: XOR<ProfileViewCreateWithoutProfileInput, ProfileViewUncheckedCreateWithoutProfileInput>
  }

  export type ProfileViewCreateManyProfileInputEnvelope = {
    data: ProfileViewCreateManyProfileInput | ProfileViewCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type ShortlistCreateWithoutProfileInput = {
    id?: string
    folderName?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutShortlistsInput
  }

  export type ShortlistUncheckedCreateWithoutProfileInput = {
    id?: string
    userId: string
    folderName?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShortlistCreateOrConnectWithoutProfileInput = {
    where: ShortlistWhereUniqueInput
    create: XOR<ShortlistCreateWithoutProfileInput, ShortlistUncheckedCreateWithoutProfileInput>
  }

  export type ShortlistCreateManyProfileInputEnvelope = {
    data: ShortlistCreateManyProfileInput | ShortlistCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type HoroscopeCreateWithoutProfileInput = {
    id?: string
    horoscopeUrl?: string | null
    birthTime?: string | null
    birthPlace?: string | null
    rashi?: string | null
    nakshatra?: string | null
    mangalDosha?: boolean | null
    horoscopeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutHoroscopesInput
    matches1?: HoroscopeMatchCreateNestedManyWithoutHoroscope1Input
    matches2?: HoroscopeMatchCreateNestedManyWithoutHoroscope2Input
  }

  export type HoroscopeUncheckedCreateWithoutProfileInput = {
    id?: string
    userId: string
    horoscopeUrl?: string | null
    birthTime?: string | null
    birthPlace?: string | null
    rashi?: string | null
    nakshatra?: string | null
    mangalDosha?: boolean | null
    horoscopeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    matches1?: HoroscopeMatchUncheckedCreateNestedManyWithoutHoroscope1Input
    matches2?: HoroscopeMatchUncheckedCreateNestedManyWithoutHoroscope2Input
  }

  export type HoroscopeCreateOrConnectWithoutProfileInput = {
    where: HoroscopeWhereUniqueInput
    create: XOR<HoroscopeCreateWithoutProfileInput, HoroscopeUncheckedCreateWithoutProfileInput>
  }

  export type ProfileComparisonCreateWithoutProfileInput = {
    id?: string
    userId: string
    comparisonData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type ProfileComparisonUncheckedCreateWithoutProfileInput = {
    id?: string
    userId: string
    comparisonData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type ProfileComparisonCreateOrConnectWithoutProfileInput = {
    where: ProfileComparisonWhereUniqueInput
    create: XOR<ProfileComparisonCreateWithoutProfileInput, ProfileComparisonUncheckedCreateWithoutProfileInput>
  }

  export type ProfileComparisonCreateManyProfileInputEnvelope = {
    data: ProfileComparisonCreateManyProfileInput | ProfileComparisonCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type TestimonialCreateWithoutProfileInput = {
    id?: string
    authorName: string
    authorRelation?: string | null
    authorEmail?: string | null
    content: string
    rating?: number | null
    isApproved?: boolean
    createdAt?: Date | string
  }

  export type TestimonialUncheckedCreateWithoutProfileInput = {
    id?: string
    authorName: string
    authorRelation?: string | null
    authorEmail?: string | null
    content: string
    rating?: number | null
    isApproved?: boolean
    createdAt?: Date | string
  }

  export type TestimonialCreateOrConnectWithoutProfileInput = {
    where: TestimonialWhereUniqueInput
    create: XOR<TestimonialCreateWithoutProfileInput, TestimonialUncheckedCreateWithoutProfileInput>
  }

  export type TestimonialCreateManyProfileInputEnvelope = {
    data: TestimonialCreateManyProfileInput | TestimonialCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutProfileInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    interests?: InterestCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    chats2?: ChatCreateNestedManyWithoutUser2Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type PhotoUpsertWithWhereUniqueWithoutProfileInput = {
    where: PhotoWhereUniqueInput
    update: XOR<PhotoUpdateWithoutProfileInput, PhotoUncheckedUpdateWithoutProfileInput>
    create: XOR<PhotoCreateWithoutProfileInput, PhotoUncheckedCreateWithoutProfileInput>
  }

  export type PhotoUpdateWithWhereUniqueWithoutProfileInput = {
    where: PhotoWhereUniqueInput
    data: XOR<PhotoUpdateWithoutProfileInput, PhotoUncheckedUpdateWithoutProfileInput>
  }

  export type PhotoUpdateManyWithWhereWithoutProfileInput = {
    where: PhotoScalarWhereInput
    data: XOR<PhotoUpdateManyMutationInput, PhotoUncheckedUpdateManyWithoutProfileInput>
  }

  export type PhotoScalarWhereInput = {
    AND?: PhotoScalarWhereInput | PhotoScalarWhereInput[]
    OR?: PhotoScalarWhereInput[]
    NOT?: PhotoScalarWhereInput | PhotoScalarWhereInput[]
    id?: StringFilter<"Photo"> | string
    profileId?: StringFilter<"Photo"> | string
    url?: StringFilter<"Photo"> | string
    cloudinaryId?: StringNullableFilter<"Photo"> | string | null
    isPrimary?: BoolFilter<"Photo"> | boolean
    isBlurred?: BoolFilter<"Photo"> | boolean
    isApproved?: BoolFilter<"Photo"> | boolean
    order?: IntFilter<"Photo"> | number
    albumName?: StringNullableFilter<"Photo"> | string | null
    caption?: StringNullableFilter<"Photo"> | string | null
    createdAt?: DateTimeFilter<"Photo"> | Date | string
  }

  export type ProfileViewUpsertWithWhereUniqueWithoutProfileInput = {
    where: ProfileViewWhereUniqueInput
    update: XOR<ProfileViewUpdateWithoutProfileInput, ProfileViewUncheckedUpdateWithoutProfileInput>
    create: XOR<ProfileViewCreateWithoutProfileInput, ProfileViewUncheckedCreateWithoutProfileInput>
  }

  export type ProfileViewUpdateWithWhereUniqueWithoutProfileInput = {
    where: ProfileViewWhereUniqueInput
    data: XOR<ProfileViewUpdateWithoutProfileInput, ProfileViewUncheckedUpdateWithoutProfileInput>
  }

  export type ProfileViewUpdateManyWithWhereWithoutProfileInput = {
    where: ProfileViewScalarWhereInput
    data: XOR<ProfileViewUpdateManyMutationInput, ProfileViewUncheckedUpdateManyWithoutProfileInput>
  }

  export type ShortlistUpsertWithWhereUniqueWithoutProfileInput = {
    where: ShortlistWhereUniqueInput
    update: XOR<ShortlistUpdateWithoutProfileInput, ShortlistUncheckedUpdateWithoutProfileInput>
    create: XOR<ShortlistCreateWithoutProfileInput, ShortlistUncheckedCreateWithoutProfileInput>
  }

  export type ShortlistUpdateWithWhereUniqueWithoutProfileInput = {
    where: ShortlistWhereUniqueInput
    data: XOR<ShortlistUpdateWithoutProfileInput, ShortlistUncheckedUpdateWithoutProfileInput>
  }

  export type ShortlistUpdateManyWithWhereWithoutProfileInput = {
    where: ShortlistScalarWhereInput
    data: XOR<ShortlistUpdateManyMutationInput, ShortlistUncheckedUpdateManyWithoutProfileInput>
  }

  export type HoroscopeUpsertWithoutProfileInput = {
    update: XOR<HoroscopeUpdateWithoutProfileInput, HoroscopeUncheckedUpdateWithoutProfileInput>
    create: XOR<HoroscopeCreateWithoutProfileInput, HoroscopeUncheckedCreateWithoutProfileInput>
    where?: HoroscopeWhereInput
  }

  export type HoroscopeUpdateToOneWithWhereWithoutProfileInput = {
    where?: HoroscopeWhereInput
    data: XOR<HoroscopeUpdateWithoutProfileInput, HoroscopeUncheckedUpdateWithoutProfileInput>
  }

  export type HoroscopeUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    horoscopeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    birthTime?: NullableStringFieldUpdateOperationsInput | string | null
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    rashi?: NullableStringFieldUpdateOperationsInput | string | null
    nakshatra?: NullableStringFieldUpdateOperationsInput | string | null
    mangalDosha?: NullableBoolFieldUpdateOperationsInput | boolean | null
    horoscopeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHoroscopesNestedInput
    matches1?: HoroscopeMatchUpdateManyWithoutHoroscope1NestedInput
    matches2?: HoroscopeMatchUpdateManyWithoutHoroscope2NestedInput
  }

  export type HoroscopeUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    horoscopeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    birthTime?: NullableStringFieldUpdateOperationsInput | string | null
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    rashi?: NullableStringFieldUpdateOperationsInput | string | null
    nakshatra?: NullableStringFieldUpdateOperationsInput | string | null
    mangalDosha?: NullableBoolFieldUpdateOperationsInput | boolean | null
    horoscopeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matches1?: HoroscopeMatchUncheckedUpdateManyWithoutHoroscope1NestedInput
    matches2?: HoroscopeMatchUncheckedUpdateManyWithoutHoroscope2NestedInput
  }

  export type ProfileComparisonUpsertWithWhereUniqueWithoutProfileInput = {
    where: ProfileComparisonWhereUniqueInput
    update: XOR<ProfileComparisonUpdateWithoutProfileInput, ProfileComparisonUncheckedUpdateWithoutProfileInput>
    create: XOR<ProfileComparisonCreateWithoutProfileInput, ProfileComparisonUncheckedCreateWithoutProfileInput>
  }

  export type ProfileComparisonUpdateWithWhereUniqueWithoutProfileInput = {
    where: ProfileComparisonWhereUniqueInput
    data: XOR<ProfileComparisonUpdateWithoutProfileInput, ProfileComparisonUncheckedUpdateWithoutProfileInput>
  }

  export type ProfileComparisonUpdateManyWithWhereWithoutProfileInput = {
    where: ProfileComparisonScalarWhereInput
    data: XOR<ProfileComparisonUpdateManyMutationInput, ProfileComparisonUncheckedUpdateManyWithoutProfileInput>
  }

  export type ProfileComparisonScalarWhereInput = {
    AND?: ProfileComparisonScalarWhereInput | ProfileComparisonScalarWhereInput[]
    OR?: ProfileComparisonScalarWhereInput[]
    NOT?: ProfileComparisonScalarWhereInput | ProfileComparisonScalarWhereInput[]
    id?: StringFilter<"ProfileComparison"> | string
    userId?: StringFilter<"ProfileComparison"> | string
    profileId?: StringFilter<"ProfileComparison"> | string
    comparisonData?: JsonNullableFilter<"ProfileComparison">
    createdAt?: DateTimeFilter<"ProfileComparison"> | Date | string
    expiresAt?: DateTimeNullableFilter<"ProfileComparison"> | Date | string | null
  }

  export type TestimonialUpsertWithWhereUniqueWithoutProfileInput = {
    where: TestimonialWhereUniqueInput
    update: XOR<TestimonialUpdateWithoutProfileInput, TestimonialUncheckedUpdateWithoutProfileInput>
    create: XOR<TestimonialCreateWithoutProfileInput, TestimonialUncheckedCreateWithoutProfileInput>
  }

  export type TestimonialUpdateWithWhereUniqueWithoutProfileInput = {
    where: TestimonialWhereUniqueInput
    data: XOR<TestimonialUpdateWithoutProfileInput, TestimonialUncheckedUpdateWithoutProfileInput>
  }

  export type TestimonialUpdateManyWithWhereWithoutProfileInput = {
    where: TestimonialScalarWhereInput
    data: XOR<TestimonialUpdateManyMutationInput, TestimonialUncheckedUpdateManyWithoutProfileInput>
  }

  export type TestimonialScalarWhereInput = {
    AND?: TestimonialScalarWhereInput | TestimonialScalarWhereInput[]
    OR?: TestimonialScalarWhereInput[]
    NOT?: TestimonialScalarWhereInput | TestimonialScalarWhereInput[]
    id?: StringFilter<"Testimonial"> | string
    profileId?: StringFilter<"Testimonial"> | string
    authorName?: StringFilter<"Testimonial"> | string
    authorRelation?: StringNullableFilter<"Testimonial"> | string | null
    authorEmail?: StringNullableFilter<"Testimonial"> | string | null
    content?: StringFilter<"Testimonial"> | string
    rating?: IntNullableFilter<"Testimonial"> | number | null
    isApproved?: BoolFilter<"Testimonial"> | boolean
    createdAt?: DateTimeFilter<"Testimonial"> | Date | string
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProfileCreateWithoutPhotosInput = {
    id?: string
    status?: $Enums.ProfileStatus
    firstName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    dateOfBirth?: Date | string | null
    height?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    religion?: string | null
    caste?: string | null
    motherTongue?: string | null
    manglik?: boolean | null
    gothra?: string | null
    country?: string | null
    state?: string | null
    city?: string | null
    citizenship?: string | null
    education?: string | null
    college?: string | null
    occupation?: string | null
    income?: number | null
    incomeCurrency?: string | null
    fatherOccupation?: string | null
    motherOccupation?: string | null
    siblings?: number | null
    familyType?: $Enums.FamilyType | null
    diet?: $Enums.Diet | null
    smoking?: boolean | null
    drinking?: boolean | null
    hobbies?: string | null
    partnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    videoIntroUrl?: string | null
    biodataUrl?: string | null
    aboutMe?: string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    privacySettings?: NullableJsonNullValueInput | InputJsonValue
    isHiddenFromSearch?: boolean
    isAnonymousViewing?: boolean
    contactPrivacyLevel?: string | null
    photoPrivacyLevel?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    trustScore?: number
    completenessScore?: number
    isHighlighted?: boolean
    slug?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: ProfileViewCreateNestedManyWithoutProfileInput
    shortlistedBy?: ShortlistCreateNestedManyWithoutProfileInput
    horoscope?: HoroscopeCreateNestedOneWithoutProfileInput
    comparisons?: ProfileComparisonCreateNestedManyWithoutProfileInput
    testimonials?: TestimonialCreateNestedManyWithoutProfileInput
    user: UserCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutPhotosInput = {
    id?: string
    userId: string
    status?: $Enums.ProfileStatus
    firstName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    dateOfBirth?: Date | string | null
    height?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    religion?: string | null
    caste?: string | null
    motherTongue?: string | null
    manglik?: boolean | null
    gothra?: string | null
    country?: string | null
    state?: string | null
    city?: string | null
    citizenship?: string | null
    education?: string | null
    college?: string | null
    occupation?: string | null
    income?: number | null
    incomeCurrency?: string | null
    fatherOccupation?: string | null
    motherOccupation?: string | null
    siblings?: number | null
    familyType?: $Enums.FamilyType | null
    diet?: $Enums.Diet | null
    smoking?: boolean | null
    drinking?: boolean | null
    hobbies?: string | null
    partnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    videoIntroUrl?: string | null
    biodataUrl?: string | null
    aboutMe?: string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    privacySettings?: NullableJsonNullValueInput | InputJsonValue
    isHiddenFromSearch?: boolean
    isAnonymousViewing?: boolean
    contactPrivacyLevel?: string | null
    photoPrivacyLevel?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    trustScore?: number
    completenessScore?: number
    isHighlighted?: boolean
    slug?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutProfileInput
    shortlistedBy?: ShortlistUncheckedCreateNestedManyWithoutProfileInput
    horoscope?: HoroscopeUncheckedCreateNestedOneWithoutProfileInput
    comparisons?: ProfileComparisonUncheckedCreateNestedManyWithoutProfileInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutPhotosInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutPhotosInput, ProfileUncheckedCreateWithoutPhotosInput>
  }

  export type ProfileUpsertWithoutPhotosInput = {
    update: XOR<ProfileUpdateWithoutPhotosInput, ProfileUncheckedUpdateWithoutPhotosInput>
    create: XOR<ProfileCreateWithoutPhotosInput, ProfileUncheckedCreateWithoutPhotosInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutPhotosInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutPhotosInput, ProfileUncheckedUpdateWithoutPhotosInput>
  }

  export type ProfileUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    caste?: NullableStringFieldUpdateOperationsInput | string | null
    motherTongue?: NullableStringFieldUpdateOperationsInput | string | null
    manglik?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gothra?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableIntFieldUpdateOperationsInput | number | null
    incomeCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    fatherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    motherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    siblings?: NullableIntFieldUpdateOperationsInput | number | null
    familyType?: NullableEnumFamilyTypeFieldUpdateOperationsInput | $Enums.FamilyType | null
    diet?: NullableEnumDietFieldUpdateOperationsInput | $Enums.Diet | null
    smoking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    drinking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hobbies?: NullableStringFieldUpdateOperationsInput | string | null
    partnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    videoIntroUrl?: NullableStringFieldUpdateOperationsInput | string | null
    biodataUrl?: NullableStringFieldUpdateOperationsInput | string | null
    aboutMe?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    privacySettings?: NullableJsonNullValueInput | InputJsonValue
    isHiddenFromSearch?: BoolFieldUpdateOperationsInput | boolean
    isAnonymousViewing?: BoolFieldUpdateOperationsInput | boolean
    contactPrivacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    photoPrivacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    completenessScore?: IntFieldUpdateOperationsInput | number
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: ProfileViewUpdateManyWithoutProfileNestedInput
    shortlistedBy?: ShortlistUpdateManyWithoutProfileNestedInput
    horoscope?: HoroscopeUpdateOneWithoutProfileNestedInput
    comparisons?: ProfileComparisonUpdateManyWithoutProfileNestedInput
    testimonials?: TestimonialUpdateManyWithoutProfileNestedInput
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    caste?: NullableStringFieldUpdateOperationsInput | string | null
    motherTongue?: NullableStringFieldUpdateOperationsInput | string | null
    manglik?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gothra?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableIntFieldUpdateOperationsInput | number | null
    incomeCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    fatherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    motherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    siblings?: NullableIntFieldUpdateOperationsInput | number | null
    familyType?: NullableEnumFamilyTypeFieldUpdateOperationsInput | $Enums.FamilyType | null
    diet?: NullableEnumDietFieldUpdateOperationsInput | $Enums.Diet | null
    smoking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    drinking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hobbies?: NullableStringFieldUpdateOperationsInput | string | null
    partnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    videoIntroUrl?: NullableStringFieldUpdateOperationsInput | string | null
    biodataUrl?: NullableStringFieldUpdateOperationsInput | string | null
    aboutMe?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    privacySettings?: NullableJsonNullValueInput | InputJsonValue
    isHiddenFromSearch?: BoolFieldUpdateOperationsInput | boolean
    isAnonymousViewing?: BoolFieldUpdateOperationsInput | boolean
    contactPrivacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    photoPrivacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    completenessScore?: IntFieldUpdateOperationsInput | number
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: ProfileViewUncheckedUpdateManyWithoutProfileNestedInput
    shortlistedBy?: ShortlistUncheckedUpdateManyWithoutProfileNestedInput
    horoscope?: HoroscopeUncheckedUpdateOneWithoutProfileNestedInput
    comparisons?: ProfileComparisonUncheckedUpdateManyWithoutProfileNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type UserCreateWithoutInterestsInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    chats2?: ChatCreateNestedManyWithoutUser2Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInterestsInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInterestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInterestsInput, UserUncheckedCreateWithoutInterestsInput>
  }

  export type UserCreateWithoutReceivedInterestsInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    interests?: InterestCreateNestedManyWithoutFromUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    chats2?: ChatCreateNestedManyWithoutUser2Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReceivedInterestsInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReceivedInterestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedInterestsInput, UserUncheckedCreateWithoutReceivedInterestsInput>
  }

  export type UserUpsertWithoutInterestsInput = {
    update: XOR<UserUpdateWithoutInterestsInput, UserUncheckedUpdateWithoutInterestsInput>
    create: XOR<UserCreateWithoutInterestsInput, UserUncheckedCreateWithoutInterestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInterestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInterestsInput, UserUncheckedUpdateWithoutInterestsInput>
  }

  export type UserUpdateWithoutInterestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInterestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutReceivedInterestsInput = {
    update: XOR<UserUpdateWithoutReceivedInterestsInput, UserUncheckedUpdateWithoutReceivedInterestsInput>
    create: XOR<UserCreateWithoutReceivedInterestsInput, UserUncheckedCreateWithoutReceivedInterestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedInterestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedInterestsInput, UserUncheckedUpdateWithoutReceivedInterestsInput>
  }

  export type UserUpdateWithoutReceivedInterestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedInterestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutChatsInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    interests?: InterestCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats2?: ChatCreateNestedManyWithoutUser2Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChatsInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChatsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChatsInput, UserUncheckedCreateWithoutChatsInput>
  }

  export type UserCreateWithoutChats2Input = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    interests?: InterestCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChats2Input = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChats2Input = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChats2Input, UserUncheckedCreateWithoutChats2Input>
  }

  export type MessageCreateWithoutChatInput = {
    id?: string
    content?: string | null
    imageUrl?: string | null
    videoUrl?: string | null
    audioUrl?: string | null
    fileUrl?: string | null
    fileName?: string | null
    messageType?: string
    isRead?: boolean
    isDeleted?: boolean
    deletedBy?: MessageCreatedeletedByInput | string[]
    isReported?: boolean
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutChatInput = {
    id?: string
    senderId: string
    content?: string | null
    imageUrl?: string | null
    videoUrl?: string | null
    audioUrl?: string | null
    fileUrl?: string | null
    fileName?: string | null
    messageType?: string
    isRead?: boolean
    isDeleted?: boolean
    deletedBy?: MessageCreatedeletedByInput | string[]
    isReported?: boolean
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutChatInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput>
  }

  export type MessageCreateManyChatInputEnvelope = {
    data: MessageCreateManyChatInput | MessageCreateManyChatInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutChatsInput = {
    update: XOR<UserUpdateWithoutChatsInput, UserUncheckedUpdateWithoutChatsInput>
    create: XOR<UserCreateWithoutChatsInput, UserUncheckedCreateWithoutChatsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChatsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChatsInput, UserUncheckedUpdateWithoutChatsInput>
  }

  export type UserUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutChats2Input = {
    update: XOR<UserUpdateWithoutChats2Input, UserUncheckedUpdateWithoutChats2Input>
    create: XOR<UserCreateWithoutChats2Input, UserUncheckedCreateWithoutChats2Input>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChats2Input = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChats2Input, UserUncheckedUpdateWithoutChats2Input>
  }

  export type UserUpdateWithoutChats2Input = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChats2Input = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MessageUpsertWithWhereUniqueWithoutChatInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutChatInput, MessageUncheckedUpdateWithoutChatInput>
    create: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutChatInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutChatInput, MessageUncheckedUpdateWithoutChatInput>
  }

  export type MessageUpdateManyWithWhereWithoutChatInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutChatInput>
  }

  export type ChatCreateWithoutMessagesInput = {
    id?: string
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user1: UserCreateNestedOneWithoutChatsInput
    user2: UserCreateNestedOneWithoutChats2Input
  }

  export type ChatUncheckedCreateWithoutMessagesInput = {
    id?: string
    user1Id: string
    user2Id: string
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatCreateOrConnectWithoutMessagesInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutMessagesInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    interests?: InterestCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    chats2?: ChatCreateNestedManyWithoutUser2Input
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMessagesInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
  }

  export type ChatUpsertWithoutMessagesInput = {
    update: XOR<ChatUpdateWithoutMessagesInput, ChatUncheckedUpdateWithoutMessagesInput>
    create: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    where?: ChatWhereInput
  }

  export type ChatUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ChatWhereInput
    data: XOR<ChatUpdateWithoutMessagesInput, ChatUncheckedUpdateWithoutMessagesInput>
  }

  export type ChatUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user1?: UserUpdateOneRequiredWithoutChatsNestedInput
    user2?: UserUpdateOneRequiredWithoutChats2NestedInput
  }

  export type ChatUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user1Id?: StringFieldUpdateOperationsInput | string
    user2Id?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutMessagesInput = {
    update: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProfileCreateWithoutProfileViewsInput = {
    id?: string
    status?: $Enums.ProfileStatus
    firstName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    dateOfBirth?: Date | string | null
    height?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    religion?: string | null
    caste?: string | null
    motherTongue?: string | null
    manglik?: boolean | null
    gothra?: string | null
    country?: string | null
    state?: string | null
    city?: string | null
    citizenship?: string | null
    education?: string | null
    college?: string | null
    occupation?: string | null
    income?: number | null
    incomeCurrency?: string | null
    fatherOccupation?: string | null
    motherOccupation?: string | null
    siblings?: number | null
    familyType?: $Enums.FamilyType | null
    diet?: $Enums.Diet | null
    smoking?: boolean | null
    drinking?: boolean | null
    hobbies?: string | null
    partnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    videoIntroUrl?: string | null
    biodataUrl?: string | null
    aboutMe?: string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    privacySettings?: NullableJsonNullValueInput | InputJsonValue
    isHiddenFromSearch?: boolean
    isAnonymousViewing?: boolean
    contactPrivacyLevel?: string | null
    photoPrivacyLevel?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    trustScore?: number
    completenessScore?: number
    isHighlighted?: boolean
    slug?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: PhotoCreateNestedManyWithoutProfileInput
    shortlistedBy?: ShortlistCreateNestedManyWithoutProfileInput
    horoscope?: HoroscopeCreateNestedOneWithoutProfileInput
    comparisons?: ProfileComparisonCreateNestedManyWithoutProfileInput
    testimonials?: TestimonialCreateNestedManyWithoutProfileInput
    user: UserCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutProfileViewsInput = {
    id?: string
    userId: string
    status?: $Enums.ProfileStatus
    firstName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    dateOfBirth?: Date | string | null
    height?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    religion?: string | null
    caste?: string | null
    motherTongue?: string | null
    manglik?: boolean | null
    gothra?: string | null
    country?: string | null
    state?: string | null
    city?: string | null
    citizenship?: string | null
    education?: string | null
    college?: string | null
    occupation?: string | null
    income?: number | null
    incomeCurrency?: string | null
    fatherOccupation?: string | null
    motherOccupation?: string | null
    siblings?: number | null
    familyType?: $Enums.FamilyType | null
    diet?: $Enums.Diet | null
    smoking?: boolean | null
    drinking?: boolean | null
    hobbies?: string | null
    partnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    videoIntroUrl?: string | null
    biodataUrl?: string | null
    aboutMe?: string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    privacySettings?: NullableJsonNullValueInput | InputJsonValue
    isHiddenFromSearch?: boolean
    isAnonymousViewing?: boolean
    contactPrivacyLevel?: string | null
    photoPrivacyLevel?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    trustScore?: number
    completenessScore?: number
    isHighlighted?: boolean
    slug?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: PhotoUncheckedCreateNestedManyWithoutProfileInput
    shortlistedBy?: ShortlistUncheckedCreateNestedManyWithoutProfileInput
    horoscope?: HoroscopeUncheckedCreateNestedOneWithoutProfileInput
    comparisons?: ProfileComparisonUncheckedCreateNestedManyWithoutProfileInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutProfileViewsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutProfileViewsInput, ProfileUncheckedCreateWithoutProfileViewsInput>
  }

  export type UserCreateWithoutProfileViewsInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    interests?: InterestCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    chats2?: ChatCreateNestedManyWithoutUser2Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProfileViewsInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProfileViewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileViewsInput, UserUncheckedCreateWithoutProfileViewsInput>
  }

  export type ProfileUpsertWithoutProfileViewsInput = {
    update: XOR<ProfileUpdateWithoutProfileViewsInput, ProfileUncheckedUpdateWithoutProfileViewsInput>
    create: XOR<ProfileCreateWithoutProfileViewsInput, ProfileUncheckedCreateWithoutProfileViewsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutProfileViewsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutProfileViewsInput, ProfileUncheckedUpdateWithoutProfileViewsInput>
  }

  export type ProfileUpdateWithoutProfileViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    caste?: NullableStringFieldUpdateOperationsInput | string | null
    motherTongue?: NullableStringFieldUpdateOperationsInput | string | null
    manglik?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gothra?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableIntFieldUpdateOperationsInput | number | null
    incomeCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    fatherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    motherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    siblings?: NullableIntFieldUpdateOperationsInput | number | null
    familyType?: NullableEnumFamilyTypeFieldUpdateOperationsInput | $Enums.FamilyType | null
    diet?: NullableEnumDietFieldUpdateOperationsInput | $Enums.Diet | null
    smoking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    drinking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hobbies?: NullableStringFieldUpdateOperationsInput | string | null
    partnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    videoIntroUrl?: NullableStringFieldUpdateOperationsInput | string | null
    biodataUrl?: NullableStringFieldUpdateOperationsInput | string | null
    aboutMe?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    privacySettings?: NullableJsonNullValueInput | InputJsonValue
    isHiddenFromSearch?: BoolFieldUpdateOperationsInput | boolean
    isAnonymousViewing?: BoolFieldUpdateOperationsInput | boolean
    contactPrivacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    photoPrivacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    completenessScore?: IntFieldUpdateOperationsInput | number
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: PhotoUpdateManyWithoutProfileNestedInput
    shortlistedBy?: ShortlistUpdateManyWithoutProfileNestedInput
    horoscope?: HoroscopeUpdateOneWithoutProfileNestedInput
    comparisons?: ProfileComparisonUpdateManyWithoutProfileNestedInput
    testimonials?: TestimonialUpdateManyWithoutProfileNestedInput
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutProfileViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    caste?: NullableStringFieldUpdateOperationsInput | string | null
    motherTongue?: NullableStringFieldUpdateOperationsInput | string | null
    manglik?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gothra?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableIntFieldUpdateOperationsInput | number | null
    incomeCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    fatherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    motherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    siblings?: NullableIntFieldUpdateOperationsInput | number | null
    familyType?: NullableEnumFamilyTypeFieldUpdateOperationsInput | $Enums.FamilyType | null
    diet?: NullableEnumDietFieldUpdateOperationsInput | $Enums.Diet | null
    smoking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    drinking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hobbies?: NullableStringFieldUpdateOperationsInput | string | null
    partnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    videoIntroUrl?: NullableStringFieldUpdateOperationsInput | string | null
    biodataUrl?: NullableStringFieldUpdateOperationsInput | string | null
    aboutMe?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    privacySettings?: NullableJsonNullValueInput | InputJsonValue
    isHiddenFromSearch?: BoolFieldUpdateOperationsInput | boolean
    isAnonymousViewing?: BoolFieldUpdateOperationsInput | boolean
    contactPrivacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    photoPrivacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    completenessScore?: IntFieldUpdateOperationsInput | number
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: PhotoUncheckedUpdateManyWithoutProfileNestedInput
    shortlistedBy?: ShortlistUncheckedUpdateManyWithoutProfileNestedInput
    horoscope?: HoroscopeUncheckedUpdateOneWithoutProfileNestedInput
    comparisons?: ProfileComparisonUncheckedUpdateManyWithoutProfileNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type UserUpsertWithoutProfileViewsInput = {
    update: XOR<UserUpdateWithoutProfileViewsInput, UserUncheckedUpdateWithoutProfileViewsInput>
    create: XOR<UserCreateWithoutProfileViewsInput, UserUncheckedCreateWithoutProfileViewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfileViewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfileViewsInput, UserUncheckedUpdateWithoutProfileViewsInput>
  }

  export type UserUpdateWithoutProfileViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SubscriptionCreateWithoutContactViewsInput = {
    id?: string
    plan: $Enums.SubscriptionPlan
    razorpaySubscriptionId?: string | null
    razorpayPlanId?: string | null
    status?: string
    startDate: Date | string
    endDate: Date | string
    contactViewsUsed?: number
    contactViewsLimit?: number | null
    profileBoostCredits?: number
    verifiedBadgeIncluded?: boolean
    horoscopeReportsIncluded?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateWithoutContactViewsInput = {
    id?: string
    userId: string
    plan: $Enums.SubscriptionPlan
    razorpaySubscriptionId?: string | null
    razorpayPlanId?: string | null
    status?: string
    startDate: Date | string
    endDate: Date | string
    contactViewsUsed?: number
    contactViewsLimit?: number | null
    profileBoostCredits?: number
    verifiedBadgeIncluded?: boolean
    horoscopeReportsIncluded?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutContactViewsInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutContactViewsInput, SubscriptionUncheckedCreateWithoutContactViewsInput>
  }

  export type SubscriptionUpsertWithoutContactViewsInput = {
    update: XOR<SubscriptionUpdateWithoutContactViewsInput, SubscriptionUncheckedUpdateWithoutContactViewsInput>
    create: XOR<SubscriptionCreateWithoutContactViewsInput, SubscriptionUncheckedCreateWithoutContactViewsInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutContactViewsInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutContactViewsInput, SubscriptionUncheckedUpdateWithoutContactViewsInput>
  }

  export type SubscriptionUpdateWithoutContactViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    razorpaySubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contactViewsUsed?: IntFieldUpdateOperationsInput | number
    contactViewsLimit?: NullableIntFieldUpdateOperationsInput | number | null
    profileBoostCredits?: IntFieldUpdateOperationsInput | number
    verifiedBadgeIncluded?: BoolFieldUpdateOperationsInput | boolean
    horoscopeReportsIncluded?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutContactViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    razorpaySubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contactViewsUsed?: IntFieldUpdateOperationsInput | number
    contactViewsLimit?: NullableIntFieldUpdateOperationsInput | number | null
    profileBoostCredits?: IntFieldUpdateOperationsInput | number
    verifiedBadgeIncluded?: BoolFieldUpdateOperationsInput | boolean
    horoscopeReportsIncluded?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutSubscriptionsInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    interests?: InterestCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    chats2?: ChatCreateNestedManyWithoutUser2Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubscriptionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
  }

  export type ContactViewCreateWithoutSubscriptionInput = {
    id?: string
    profileId: string
    viewedById: string
    createdAt?: Date | string
  }

  export type ContactViewUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    profileId: string
    viewedById: string
    createdAt?: Date | string
  }

  export type ContactViewCreateOrConnectWithoutSubscriptionInput = {
    where: ContactViewWhereUniqueInput
    create: XOR<ContactViewCreateWithoutSubscriptionInput, ContactViewUncheckedCreateWithoutSubscriptionInput>
  }

  export type ContactViewCreateManySubscriptionInputEnvelope = {
    data: ContactViewCreateManySubscriptionInput | ContactViewCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSubscriptionsInput = {
    update: XOR<UserUpdateWithoutSubscriptionsInput, UserUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubscriptionsInput, UserUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type UserUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ContactViewUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: ContactViewWhereUniqueInput
    update: XOR<ContactViewUpdateWithoutSubscriptionInput, ContactViewUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<ContactViewCreateWithoutSubscriptionInput, ContactViewUncheckedCreateWithoutSubscriptionInput>
  }

  export type ContactViewUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: ContactViewWhereUniqueInput
    data: XOR<ContactViewUpdateWithoutSubscriptionInput, ContactViewUncheckedUpdateWithoutSubscriptionInput>
  }

  export type ContactViewUpdateManyWithWhereWithoutSubscriptionInput = {
    where: ContactViewScalarWhereInput
    data: XOR<ContactViewUpdateManyMutationInput, ContactViewUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type ContactViewScalarWhereInput = {
    AND?: ContactViewScalarWhereInput | ContactViewScalarWhereInput[]
    OR?: ContactViewScalarWhereInput[]
    NOT?: ContactViewScalarWhereInput | ContactViewScalarWhereInput[]
    id?: StringFilter<"ContactView"> | string
    subscriptionId?: StringFilter<"ContactView"> | string
    profileId?: StringFilter<"ContactView"> | string
    viewedById?: StringFilter<"ContactView"> | string
    createdAt?: DateTimeFilter<"ContactView"> | Date | string
  }

  export type UserCreateWithoutPaymentsInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    interests?: InterestCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    chats2?: ChatCreateNestedManyWithoutUser2Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPaymentsInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
  }

  export type AddOnCreateWithoutPaymentInput = {
    id?: string
    userId: string
    type: $Enums.AddOnType
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type AddOnUncheckedCreateWithoutPaymentInput = {
    id?: string
    userId: string
    type: $Enums.AddOnType
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type AddOnCreateOrConnectWithoutPaymentInput = {
    where: AddOnWhereUniqueInput
    create: XOR<AddOnCreateWithoutPaymentInput, AddOnUncheckedCreateWithoutPaymentInput>
  }

  export type AddOnCreateManyPaymentInputEnvelope = {
    data: AddOnCreateManyPaymentInput | AddOnCreateManyPaymentInput[]
    skipDuplicates?: boolean
  }

  export type ServiceCreateWithoutPaymentInput = {
    id?: string
    type: $Enums.ServiceType
    status?: $Enums.ServiceStatus
    amount: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    notes?: string | null
    rating?: number | null
    review?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutServicesInput
    bookings?: ServiceBookingCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutPaymentInput = {
    id?: string
    userId: string
    type: $Enums.ServiceType
    status?: $Enums.ServiceStatus
    amount: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    notes?: string | null
    rating?: number | null
    review?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: ServiceBookingUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutPaymentInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutPaymentInput, ServiceUncheckedCreateWithoutPaymentInput>
  }

  export type ServiceCreateManyPaymentInputEnvelope = {
    data: ServiceCreateManyPaymentInput | ServiceCreateManyPaymentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPaymentsInput = {
    update: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AddOnUpsertWithWhereUniqueWithoutPaymentInput = {
    where: AddOnWhereUniqueInput
    update: XOR<AddOnUpdateWithoutPaymentInput, AddOnUncheckedUpdateWithoutPaymentInput>
    create: XOR<AddOnCreateWithoutPaymentInput, AddOnUncheckedCreateWithoutPaymentInput>
  }

  export type AddOnUpdateWithWhereUniqueWithoutPaymentInput = {
    where: AddOnWhereUniqueInput
    data: XOR<AddOnUpdateWithoutPaymentInput, AddOnUncheckedUpdateWithoutPaymentInput>
  }

  export type AddOnUpdateManyWithWhereWithoutPaymentInput = {
    where: AddOnScalarWhereInput
    data: XOR<AddOnUpdateManyMutationInput, AddOnUncheckedUpdateManyWithoutPaymentInput>
  }

  export type AddOnScalarWhereInput = {
    AND?: AddOnScalarWhereInput | AddOnScalarWhereInput[]
    OR?: AddOnScalarWhereInput[]
    NOT?: AddOnScalarWhereInput | AddOnScalarWhereInput[]
    id?: StringFilter<"AddOn"> | string
    userId?: StringFilter<"AddOn"> | string
    type?: EnumAddOnTypeFilter<"AddOn"> | $Enums.AddOnType
    paymentId?: StringNullableFilter<"AddOn"> | string | null
    expiresAt?: DateTimeNullableFilter<"AddOn"> | Date | string | null
    isActive?: BoolFilter<"AddOn"> | boolean
    createdAt?: DateTimeFilter<"AddOn"> | Date | string
  }

  export type ServiceUpsertWithWhereUniqueWithoutPaymentInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutPaymentInput, ServiceUncheckedUpdateWithoutPaymentInput>
    create: XOR<ServiceCreateWithoutPaymentInput, ServiceUncheckedCreateWithoutPaymentInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutPaymentInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutPaymentInput, ServiceUncheckedUpdateWithoutPaymentInput>
  }

  export type ServiceUpdateManyWithWhereWithoutPaymentInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutPaymentInput>
  }

  export type PaymentCreateWithoutAddOnsInput = {
    id?: string
    razorpayOrderId?: string | null
    razorpayPaymentId?: string | null
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    type: string
    addOnType?: $Enums.AddOnType | null
    subscriptionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentsInput
    services?: ServiceCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutAddOnsInput = {
    id?: string
    userId: string
    razorpayOrderId?: string | null
    razorpayPaymentId?: string | null
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    type: string
    addOnType?: $Enums.AddOnType | null
    subscriptionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutAddOnsInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutAddOnsInput, PaymentUncheckedCreateWithoutAddOnsInput>
  }

  export type PaymentUpsertWithoutAddOnsInput = {
    update: XOR<PaymentUpdateWithoutAddOnsInput, PaymentUncheckedUpdateWithoutAddOnsInput>
    create: XOR<PaymentCreateWithoutAddOnsInput, PaymentUncheckedCreateWithoutAddOnsInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutAddOnsInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutAddOnsInput, PaymentUncheckedUpdateWithoutAddOnsInput>
  }

  export type PaymentUpdateWithoutAddOnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    type?: StringFieldUpdateOperationsInput | string
    addOnType?: NullableEnumAddOnTypeFieldUpdateOperationsInput | $Enums.AddOnType | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
    services?: ServiceUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutAddOnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    type?: StringFieldUpdateOperationsInput | string
    addOnType?: NullableEnumAddOnTypeFieldUpdateOperationsInput | $Enums.AddOnType | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type UserCreateWithoutServicesInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    interests?: InterestCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    chats2?: ChatCreateNestedManyWithoutUser2Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutServicesInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutServicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutServicesInput, UserUncheckedCreateWithoutServicesInput>
  }

  export type PaymentCreateWithoutServicesInput = {
    id?: string
    razorpayOrderId?: string | null
    razorpayPaymentId?: string | null
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    type: string
    addOnType?: $Enums.AddOnType | null
    subscriptionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentsInput
    addOns?: AddOnCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutServicesInput = {
    id?: string
    userId: string
    razorpayOrderId?: string | null
    razorpayPaymentId?: string | null
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    type: string
    addOnType?: $Enums.AddOnType | null
    subscriptionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    addOns?: AddOnUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutServicesInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutServicesInput, PaymentUncheckedCreateWithoutServicesInput>
  }

  export type ServiceBookingCreateWithoutServiceInput = {
    id?: string
    scheduledAt?: Date | string | null
    duration?: number | null
    status?: $Enums.ServiceStatus
    meetingLink?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    provider?: ServiceProviderCreateNestedOneWithoutBookingsInput
    user: UserCreateNestedOneWithoutServiceBookingsInput
  }

  export type ServiceBookingUncheckedCreateWithoutServiceInput = {
    id?: string
    providerId?: string | null
    userId: string
    scheduledAt?: Date | string | null
    duration?: number | null
    status?: $Enums.ServiceStatus
    meetingLink?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceBookingCreateOrConnectWithoutServiceInput = {
    where: ServiceBookingWhereUniqueInput
    create: XOR<ServiceBookingCreateWithoutServiceInput, ServiceBookingUncheckedCreateWithoutServiceInput>
  }

  export type ServiceBookingCreateManyServiceInputEnvelope = {
    data: ServiceBookingCreateManyServiceInput | ServiceBookingCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutServicesInput = {
    update: XOR<UserUpdateWithoutServicesInput, UserUncheckedUpdateWithoutServicesInput>
    create: XOR<UserCreateWithoutServicesInput, UserUncheckedCreateWithoutServicesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutServicesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutServicesInput, UserUncheckedUpdateWithoutServicesInput>
  }

  export type UserUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PaymentUpsertWithoutServicesInput = {
    update: XOR<PaymentUpdateWithoutServicesInput, PaymentUncheckedUpdateWithoutServicesInput>
    create: XOR<PaymentCreateWithoutServicesInput, PaymentUncheckedCreateWithoutServicesInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutServicesInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutServicesInput, PaymentUncheckedUpdateWithoutServicesInput>
  }

  export type PaymentUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    type?: StringFieldUpdateOperationsInput | string
    addOnType?: NullableEnumAddOnTypeFieldUpdateOperationsInput | $Enums.AddOnType | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
    addOns?: AddOnUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    type?: StringFieldUpdateOperationsInput | string
    addOnType?: NullableEnumAddOnTypeFieldUpdateOperationsInput | $Enums.AddOnType | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addOns?: AddOnUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type ServiceBookingUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServiceBookingWhereUniqueInput
    update: XOR<ServiceBookingUpdateWithoutServiceInput, ServiceBookingUncheckedUpdateWithoutServiceInput>
    create: XOR<ServiceBookingCreateWithoutServiceInput, ServiceBookingUncheckedCreateWithoutServiceInput>
  }

  export type ServiceBookingUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServiceBookingWhereUniqueInput
    data: XOR<ServiceBookingUpdateWithoutServiceInput, ServiceBookingUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceBookingUpdateManyWithWhereWithoutServiceInput = {
    where: ServiceBookingScalarWhereInput
    data: XOR<ServiceBookingUpdateManyMutationInput, ServiceBookingUncheckedUpdateManyWithoutServiceInput>
  }

  export type ServiceBookingCreateWithoutProviderInput = {
    id?: string
    scheduledAt?: Date | string | null
    duration?: number | null
    status?: $Enums.ServiceStatus
    meetingLink?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service: ServiceCreateNestedOneWithoutBookingsInput
    user: UserCreateNestedOneWithoutServiceBookingsInput
  }

  export type ServiceBookingUncheckedCreateWithoutProviderInput = {
    id?: string
    serviceId: string
    userId: string
    scheduledAt?: Date | string | null
    duration?: number | null
    status?: $Enums.ServiceStatus
    meetingLink?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceBookingCreateOrConnectWithoutProviderInput = {
    where: ServiceBookingWhereUniqueInput
    create: XOR<ServiceBookingCreateWithoutProviderInput, ServiceBookingUncheckedCreateWithoutProviderInput>
  }

  export type ServiceBookingCreateManyProviderInputEnvelope = {
    data: ServiceBookingCreateManyProviderInput | ServiceBookingCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type ServiceBookingUpsertWithWhereUniqueWithoutProviderInput = {
    where: ServiceBookingWhereUniqueInput
    update: XOR<ServiceBookingUpdateWithoutProviderInput, ServiceBookingUncheckedUpdateWithoutProviderInput>
    create: XOR<ServiceBookingCreateWithoutProviderInput, ServiceBookingUncheckedCreateWithoutProviderInput>
  }

  export type ServiceBookingUpdateWithWhereUniqueWithoutProviderInput = {
    where: ServiceBookingWhereUniqueInput
    data: XOR<ServiceBookingUpdateWithoutProviderInput, ServiceBookingUncheckedUpdateWithoutProviderInput>
  }

  export type ServiceBookingUpdateManyWithWhereWithoutProviderInput = {
    where: ServiceBookingScalarWhereInput
    data: XOR<ServiceBookingUpdateManyMutationInput, ServiceBookingUncheckedUpdateManyWithoutProviderInput>
  }

  export type ServiceCreateWithoutBookingsInput = {
    id?: string
    type: $Enums.ServiceType
    status?: $Enums.ServiceStatus
    amount: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    notes?: string | null
    rating?: number | null
    review?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutServicesInput
    payment?: PaymentCreateNestedOneWithoutServicesInput
  }

  export type ServiceUncheckedCreateWithoutBookingsInput = {
    id?: string
    userId: string
    type: $Enums.ServiceType
    status?: $Enums.ServiceStatus
    paymentId?: string | null
    amount: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    notes?: string | null
    rating?: number | null
    review?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceCreateOrConnectWithoutBookingsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutBookingsInput, ServiceUncheckedCreateWithoutBookingsInput>
  }

  export type ServiceProviderCreateWithoutBookingsInput = {
    id?: string
    name: string
    email: string
    mobile: string
    serviceType: $Enums.ServiceType
    expertise?: string | null
    rating?: number
    totalBookings?: number
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceProviderUncheckedCreateWithoutBookingsInput = {
    id?: string
    name: string
    email: string
    mobile: string
    serviceType: $Enums.ServiceType
    expertise?: string | null
    rating?: number
    totalBookings?: number
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceProviderCreateOrConnectWithoutBookingsInput = {
    where: ServiceProviderWhereUniqueInput
    create: XOR<ServiceProviderCreateWithoutBookingsInput, ServiceProviderUncheckedCreateWithoutBookingsInput>
  }

  export type UserCreateWithoutServiceBookingsInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    interests?: InterestCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    chats2?: ChatCreateNestedManyWithoutUser2Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutServiceBookingsInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutServiceBookingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutServiceBookingsInput, UserUncheckedCreateWithoutServiceBookingsInput>
  }

  export type ServiceUpsertWithoutBookingsInput = {
    update: XOR<ServiceUpdateWithoutBookingsInput, ServiceUncheckedUpdateWithoutBookingsInput>
    create: XOR<ServiceCreateWithoutBookingsInput, ServiceUncheckedCreateWithoutBookingsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutBookingsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutBookingsInput, ServiceUncheckedUpdateWithoutBookingsInput>
  }

  export type ServiceUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    amount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutServicesNestedInput
    payment?: PaymentUpdateOneWithoutServicesNestedInput
  }

  export type ServiceUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceProviderUpsertWithoutBookingsInput = {
    update: XOR<ServiceProviderUpdateWithoutBookingsInput, ServiceProviderUncheckedUpdateWithoutBookingsInput>
    create: XOR<ServiceProviderCreateWithoutBookingsInput, ServiceProviderUncheckedCreateWithoutBookingsInput>
    where?: ServiceProviderWhereInput
  }

  export type ServiceProviderUpdateToOneWithWhereWithoutBookingsInput = {
    where?: ServiceProviderWhereInput
    data: XOR<ServiceProviderUpdateWithoutBookingsInput, ServiceProviderUncheckedUpdateWithoutBookingsInput>
  }

  export type ServiceProviderUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    totalBookings?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceProviderUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    totalBookings?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutServiceBookingsInput = {
    update: XOR<UserUpdateWithoutServiceBookingsInput, UserUncheckedUpdateWithoutServiceBookingsInput>
    create: XOR<UserCreateWithoutServiceBookingsInput, UserUncheckedCreateWithoutServiceBookingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutServiceBookingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutServiceBookingsInput, UserUncheckedUpdateWithoutServiceBookingsInput>
  }

  export type UserUpdateWithoutServiceBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutServiceBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    interests?: InterestCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    chats2?: ChatCreateNestedManyWithoutUser2Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutShortlistsInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    interests?: InterestCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    chats2?: ChatCreateNestedManyWithoutUser2Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutShortlistsInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutShortlistsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutShortlistsInput, UserUncheckedCreateWithoutShortlistsInput>
  }

  export type ProfileCreateWithoutShortlistedByInput = {
    id?: string
    status?: $Enums.ProfileStatus
    firstName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    dateOfBirth?: Date | string | null
    height?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    religion?: string | null
    caste?: string | null
    motherTongue?: string | null
    manglik?: boolean | null
    gothra?: string | null
    country?: string | null
    state?: string | null
    city?: string | null
    citizenship?: string | null
    education?: string | null
    college?: string | null
    occupation?: string | null
    income?: number | null
    incomeCurrency?: string | null
    fatherOccupation?: string | null
    motherOccupation?: string | null
    siblings?: number | null
    familyType?: $Enums.FamilyType | null
    diet?: $Enums.Diet | null
    smoking?: boolean | null
    drinking?: boolean | null
    hobbies?: string | null
    partnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    videoIntroUrl?: string | null
    biodataUrl?: string | null
    aboutMe?: string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    privacySettings?: NullableJsonNullValueInput | InputJsonValue
    isHiddenFromSearch?: boolean
    isAnonymousViewing?: boolean
    contactPrivacyLevel?: string | null
    photoPrivacyLevel?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    trustScore?: number
    completenessScore?: number
    isHighlighted?: boolean
    slug?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: PhotoCreateNestedManyWithoutProfileInput
    profileViews?: ProfileViewCreateNestedManyWithoutProfileInput
    horoscope?: HoroscopeCreateNestedOneWithoutProfileInput
    comparisons?: ProfileComparisonCreateNestedManyWithoutProfileInput
    testimonials?: TestimonialCreateNestedManyWithoutProfileInput
    user: UserCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutShortlistedByInput = {
    id?: string
    userId: string
    status?: $Enums.ProfileStatus
    firstName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    dateOfBirth?: Date | string | null
    height?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    religion?: string | null
    caste?: string | null
    motherTongue?: string | null
    manglik?: boolean | null
    gothra?: string | null
    country?: string | null
    state?: string | null
    city?: string | null
    citizenship?: string | null
    education?: string | null
    college?: string | null
    occupation?: string | null
    income?: number | null
    incomeCurrency?: string | null
    fatherOccupation?: string | null
    motherOccupation?: string | null
    siblings?: number | null
    familyType?: $Enums.FamilyType | null
    diet?: $Enums.Diet | null
    smoking?: boolean | null
    drinking?: boolean | null
    hobbies?: string | null
    partnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    videoIntroUrl?: string | null
    biodataUrl?: string | null
    aboutMe?: string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    privacySettings?: NullableJsonNullValueInput | InputJsonValue
    isHiddenFromSearch?: boolean
    isAnonymousViewing?: boolean
    contactPrivacyLevel?: string | null
    photoPrivacyLevel?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    trustScore?: number
    completenessScore?: number
    isHighlighted?: boolean
    slug?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: PhotoUncheckedCreateNestedManyWithoutProfileInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutProfileInput
    horoscope?: HoroscopeUncheckedCreateNestedOneWithoutProfileInput
    comparisons?: ProfileComparisonUncheckedCreateNestedManyWithoutProfileInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutShortlistedByInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutShortlistedByInput, ProfileUncheckedCreateWithoutShortlistedByInput>
  }

  export type UserUpsertWithoutShortlistsInput = {
    update: XOR<UserUpdateWithoutShortlistsInput, UserUncheckedUpdateWithoutShortlistsInput>
    create: XOR<UserCreateWithoutShortlistsInput, UserUncheckedCreateWithoutShortlistsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutShortlistsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutShortlistsInput, UserUncheckedUpdateWithoutShortlistsInput>
  }

  export type UserUpdateWithoutShortlistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutShortlistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProfileUpsertWithoutShortlistedByInput = {
    update: XOR<ProfileUpdateWithoutShortlistedByInput, ProfileUncheckedUpdateWithoutShortlistedByInput>
    create: XOR<ProfileCreateWithoutShortlistedByInput, ProfileUncheckedCreateWithoutShortlistedByInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutShortlistedByInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutShortlistedByInput, ProfileUncheckedUpdateWithoutShortlistedByInput>
  }

  export type ProfileUpdateWithoutShortlistedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    caste?: NullableStringFieldUpdateOperationsInput | string | null
    motherTongue?: NullableStringFieldUpdateOperationsInput | string | null
    manglik?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gothra?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableIntFieldUpdateOperationsInput | number | null
    incomeCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    fatherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    motherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    siblings?: NullableIntFieldUpdateOperationsInput | number | null
    familyType?: NullableEnumFamilyTypeFieldUpdateOperationsInput | $Enums.FamilyType | null
    diet?: NullableEnumDietFieldUpdateOperationsInput | $Enums.Diet | null
    smoking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    drinking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hobbies?: NullableStringFieldUpdateOperationsInput | string | null
    partnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    videoIntroUrl?: NullableStringFieldUpdateOperationsInput | string | null
    biodataUrl?: NullableStringFieldUpdateOperationsInput | string | null
    aboutMe?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    privacySettings?: NullableJsonNullValueInput | InputJsonValue
    isHiddenFromSearch?: BoolFieldUpdateOperationsInput | boolean
    isAnonymousViewing?: BoolFieldUpdateOperationsInput | boolean
    contactPrivacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    photoPrivacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    completenessScore?: IntFieldUpdateOperationsInput | number
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: PhotoUpdateManyWithoutProfileNestedInput
    profileViews?: ProfileViewUpdateManyWithoutProfileNestedInput
    horoscope?: HoroscopeUpdateOneWithoutProfileNestedInput
    comparisons?: ProfileComparisonUpdateManyWithoutProfileNestedInput
    testimonials?: TestimonialUpdateManyWithoutProfileNestedInput
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutShortlistedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    caste?: NullableStringFieldUpdateOperationsInput | string | null
    motherTongue?: NullableStringFieldUpdateOperationsInput | string | null
    manglik?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gothra?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableIntFieldUpdateOperationsInput | number | null
    incomeCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    fatherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    motherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    siblings?: NullableIntFieldUpdateOperationsInput | number | null
    familyType?: NullableEnumFamilyTypeFieldUpdateOperationsInput | $Enums.FamilyType | null
    diet?: NullableEnumDietFieldUpdateOperationsInput | $Enums.Diet | null
    smoking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    drinking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hobbies?: NullableStringFieldUpdateOperationsInput | string | null
    partnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    videoIntroUrl?: NullableStringFieldUpdateOperationsInput | string | null
    biodataUrl?: NullableStringFieldUpdateOperationsInput | string | null
    aboutMe?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    privacySettings?: NullableJsonNullValueInput | InputJsonValue
    isHiddenFromSearch?: BoolFieldUpdateOperationsInput | boolean
    isAnonymousViewing?: BoolFieldUpdateOperationsInput | boolean
    contactPrivacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    photoPrivacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    completenessScore?: IntFieldUpdateOperationsInput | number
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: PhotoUncheckedUpdateManyWithoutProfileNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutProfileNestedInput
    horoscope?: HoroscopeUncheckedUpdateOneWithoutProfileNestedInput
    comparisons?: ProfileComparisonUncheckedUpdateManyWithoutProfileNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type UserCreateWithoutBlockedUsersInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    interests?: InterestCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    chats2?: ChatCreateNestedManyWithoutUser2Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBlockedUsersInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBlockedUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlockedUsersInput, UserUncheckedCreateWithoutBlockedUsersInput>
  }

  export type UserCreateWithoutBlockedByInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    interests?: InterestCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    chats2?: ChatCreateNestedManyWithoutUser2Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBlockedByInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBlockedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlockedByInput, UserUncheckedCreateWithoutBlockedByInput>
  }

  export type UserUpsertWithoutBlockedUsersInput = {
    update: XOR<UserUpdateWithoutBlockedUsersInput, UserUncheckedUpdateWithoutBlockedUsersInput>
    create: XOR<UserCreateWithoutBlockedUsersInput, UserUncheckedCreateWithoutBlockedUsersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlockedUsersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlockedUsersInput, UserUncheckedUpdateWithoutBlockedUsersInput>
  }

  export type UserUpdateWithoutBlockedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBlockedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutBlockedByInput = {
    update: XOR<UserUpdateWithoutBlockedByInput, UserUncheckedUpdateWithoutBlockedByInput>
    create: XOR<UserCreateWithoutBlockedByInput, UserUncheckedCreateWithoutBlockedByInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlockedByInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlockedByInput, UserUncheckedUpdateWithoutBlockedByInput>
  }

  export type UserUpdateWithoutBlockedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBlockedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutHoroscopesInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    interests?: InterestCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    chats2?: ChatCreateNestedManyWithoutUser2Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutHoroscopesInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutHoroscopesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHoroscopesInput, UserUncheckedCreateWithoutHoroscopesInput>
  }

  export type ProfileCreateWithoutHoroscopeInput = {
    id?: string
    status?: $Enums.ProfileStatus
    firstName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    dateOfBirth?: Date | string | null
    height?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    religion?: string | null
    caste?: string | null
    motherTongue?: string | null
    manglik?: boolean | null
    gothra?: string | null
    country?: string | null
    state?: string | null
    city?: string | null
    citizenship?: string | null
    education?: string | null
    college?: string | null
    occupation?: string | null
    income?: number | null
    incomeCurrency?: string | null
    fatherOccupation?: string | null
    motherOccupation?: string | null
    siblings?: number | null
    familyType?: $Enums.FamilyType | null
    diet?: $Enums.Diet | null
    smoking?: boolean | null
    drinking?: boolean | null
    hobbies?: string | null
    partnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    videoIntroUrl?: string | null
    biodataUrl?: string | null
    aboutMe?: string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    privacySettings?: NullableJsonNullValueInput | InputJsonValue
    isHiddenFromSearch?: boolean
    isAnonymousViewing?: boolean
    contactPrivacyLevel?: string | null
    photoPrivacyLevel?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    trustScore?: number
    completenessScore?: number
    isHighlighted?: boolean
    slug?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: PhotoCreateNestedManyWithoutProfileInput
    profileViews?: ProfileViewCreateNestedManyWithoutProfileInput
    shortlistedBy?: ShortlistCreateNestedManyWithoutProfileInput
    comparisons?: ProfileComparisonCreateNestedManyWithoutProfileInput
    testimonials?: TestimonialCreateNestedManyWithoutProfileInput
    user: UserCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutHoroscopeInput = {
    id?: string
    userId: string
    status?: $Enums.ProfileStatus
    firstName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    dateOfBirth?: Date | string | null
    height?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    religion?: string | null
    caste?: string | null
    motherTongue?: string | null
    manglik?: boolean | null
    gothra?: string | null
    country?: string | null
    state?: string | null
    city?: string | null
    citizenship?: string | null
    education?: string | null
    college?: string | null
    occupation?: string | null
    income?: number | null
    incomeCurrency?: string | null
    fatherOccupation?: string | null
    motherOccupation?: string | null
    siblings?: number | null
    familyType?: $Enums.FamilyType | null
    diet?: $Enums.Diet | null
    smoking?: boolean | null
    drinking?: boolean | null
    hobbies?: string | null
    partnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    videoIntroUrl?: string | null
    biodataUrl?: string | null
    aboutMe?: string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    privacySettings?: NullableJsonNullValueInput | InputJsonValue
    isHiddenFromSearch?: boolean
    isAnonymousViewing?: boolean
    contactPrivacyLevel?: string | null
    photoPrivacyLevel?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    trustScore?: number
    completenessScore?: number
    isHighlighted?: boolean
    slug?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: PhotoUncheckedCreateNestedManyWithoutProfileInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutProfileInput
    shortlistedBy?: ShortlistUncheckedCreateNestedManyWithoutProfileInput
    comparisons?: ProfileComparisonUncheckedCreateNestedManyWithoutProfileInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutHoroscopeInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutHoroscopeInput, ProfileUncheckedCreateWithoutHoroscopeInput>
  }

  export type HoroscopeMatchCreateWithoutHoroscope1Input = {
    id?: string
    user1Id: string
    user2Id: string
    ashtakootScore?: number | null
    mangalDoshaMatch?: boolean | null
    overallScore?: number | null
    matchDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    horoscope2: HoroscopeCreateNestedOneWithoutMatches2Input
  }

  export type HoroscopeMatchUncheckedCreateWithoutHoroscope1Input = {
    id?: string
    user1Id: string
    user2Id: string
    horoscope2Id: string
    ashtakootScore?: number | null
    mangalDoshaMatch?: boolean | null
    overallScore?: number | null
    matchDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type HoroscopeMatchCreateOrConnectWithoutHoroscope1Input = {
    where: HoroscopeMatchWhereUniqueInput
    create: XOR<HoroscopeMatchCreateWithoutHoroscope1Input, HoroscopeMatchUncheckedCreateWithoutHoroscope1Input>
  }

  export type HoroscopeMatchCreateManyHoroscope1InputEnvelope = {
    data: HoroscopeMatchCreateManyHoroscope1Input | HoroscopeMatchCreateManyHoroscope1Input[]
    skipDuplicates?: boolean
  }

  export type HoroscopeMatchCreateWithoutHoroscope2Input = {
    id?: string
    user1Id: string
    user2Id: string
    ashtakootScore?: number | null
    mangalDoshaMatch?: boolean | null
    overallScore?: number | null
    matchDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    horoscope1: HoroscopeCreateNestedOneWithoutMatches1Input
  }

  export type HoroscopeMatchUncheckedCreateWithoutHoroscope2Input = {
    id?: string
    user1Id: string
    user2Id: string
    horoscope1Id: string
    ashtakootScore?: number | null
    mangalDoshaMatch?: boolean | null
    overallScore?: number | null
    matchDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type HoroscopeMatchCreateOrConnectWithoutHoroscope2Input = {
    where: HoroscopeMatchWhereUniqueInput
    create: XOR<HoroscopeMatchCreateWithoutHoroscope2Input, HoroscopeMatchUncheckedCreateWithoutHoroscope2Input>
  }

  export type HoroscopeMatchCreateManyHoroscope2InputEnvelope = {
    data: HoroscopeMatchCreateManyHoroscope2Input | HoroscopeMatchCreateManyHoroscope2Input[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutHoroscopesInput = {
    update: XOR<UserUpdateWithoutHoroscopesInput, UserUncheckedUpdateWithoutHoroscopesInput>
    create: XOR<UserCreateWithoutHoroscopesInput, UserUncheckedCreateWithoutHoroscopesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHoroscopesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHoroscopesInput, UserUncheckedUpdateWithoutHoroscopesInput>
  }

  export type UserUpdateWithoutHoroscopesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutHoroscopesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProfileUpsertWithoutHoroscopeInput = {
    update: XOR<ProfileUpdateWithoutHoroscopeInput, ProfileUncheckedUpdateWithoutHoroscopeInput>
    create: XOR<ProfileCreateWithoutHoroscopeInput, ProfileUncheckedCreateWithoutHoroscopeInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutHoroscopeInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutHoroscopeInput, ProfileUncheckedUpdateWithoutHoroscopeInput>
  }

  export type ProfileUpdateWithoutHoroscopeInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    caste?: NullableStringFieldUpdateOperationsInput | string | null
    motherTongue?: NullableStringFieldUpdateOperationsInput | string | null
    manglik?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gothra?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableIntFieldUpdateOperationsInput | number | null
    incomeCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    fatherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    motherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    siblings?: NullableIntFieldUpdateOperationsInput | number | null
    familyType?: NullableEnumFamilyTypeFieldUpdateOperationsInput | $Enums.FamilyType | null
    diet?: NullableEnumDietFieldUpdateOperationsInput | $Enums.Diet | null
    smoking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    drinking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hobbies?: NullableStringFieldUpdateOperationsInput | string | null
    partnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    videoIntroUrl?: NullableStringFieldUpdateOperationsInput | string | null
    biodataUrl?: NullableStringFieldUpdateOperationsInput | string | null
    aboutMe?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    privacySettings?: NullableJsonNullValueInput | InputJsonValue
    isHiddenFromSearch?: BoolFieldUpdateOperationsInput | boolean
    isAnonymousViewing?: BoolFieldUpdateOperationsInput | boolean
    contactPrivacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    photoPrivacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    completenessScore?: IntFieldUpdateOperationsInput | number
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: PhotoUpdateManyWithoutProfileNestedInput
    profileViews?: ProfileViewUpdateManyWithoutProfileNestedInput
    shortlistedBy?: ShortlistUpdateManyWithoutProfileNestedInput
    comparisons?: ProfileComparisonUpdateManyWithoutProfileNestedInput
    testimonials?: TestimonialUpdateManyWithoutProfileNestedInput
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutHoroscopeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    caste?: NullableStringFieldUpdateOperationsInput | string | null
    motherTongue?: NullableStringFieldUpdateOperationsInput | string | null
    manglik?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gothra?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableIntFieldUpdateOperationsInput | number | null
    incomeCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    fatherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    motherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    siblings?: NullableIntFieldUpdateOperationsInput | number | null
    familyType?: NullableEnumFamilyTypeFieldUpdateOperationsInput | $Enums.FamilyType | null
    diet?: NullableEnumDietFieldUpdateOperationsInput | $Enums.Diet | null
    smoking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    drinking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hobbies?: NullableStringFieldUpdateOperationsInput | string | null
    partnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    videoIntroUrl?: NullableStringFieldUpdateOperationsInput | string | null
    biodataUrl?: NullableStringFieldUpdateOperationsInput | string | null
    aboutMe?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    privacySettings?: NullableJsonNullValueInput | InputJsonValue
    isHiddenFromSearch?: BoolFieldUpdateOperationsInput | boolean
    isAnonymousViewing?: BoolFieldUpdateOperationsInput | boolean
    contactPrivacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    photoPrivacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    completenessScore?: IntFieldUpdateOperationsInput | number
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: PhotoUncheckedUpdateManyWithoutProfileNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutProfileNestedInput
    shortlistedBy?: ShortlistUncheckedUpdateManyWithoutProfileNestedInput
    comparisons?: ProfileComparisonUncheckedUpdateManyWithoutProfileNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type HoroscopeMatchUpsertWithWhereUniqueWithoutHoroscope1Input = {
    where: HoroscopeMatchWhereUniqueInput
    update: XOR<HoroscopeMatchUpdateWithoutHoroscope1Input, HoroscopeMatchUncheckedUpdateWithoutHoroscope1Input>
    create: XOR<HoroscopeMatchCreateWithoutHoroscope1Input, HoroscopeMatchUncheckedCreateWithoutHoroscope1Input>
  }

  export type HoroscopeMatchUpdateWithWhereUniqueWithoutHoroscope1Input = {
    where: HoroscopeMatchWhereUniqueInput
    data: XOR<HoroscopeMatchUpdateWithoutHoroscope1Input, HoroscopeMatchUncheckedUpdateWithoutHoroscope1Input>
  }

  export type HoroscopeMatchUpdateManyWithWhereWithoutHoroscope1Input = {
    where: HoroscopeMatchScalarWhereInput
    data: XOR<HoroscopeMatchUpdateManyMutationInput, HoroscopeMatchUncheckedUpdateManyWithoutHoroscope1Input>
  }

  export type HoroscopeMatchScalarWhereInput = {
    AND?: HoroscopeMatchScalarWhereInput | HoroscopeMatchScalarWhereInput[]
    OR?: HoroscopeMatchScalarWhereInput[]
    NOT?: HoroscopeMatchScalarWhereInput | HoroscopeMatchScalarWhereInput[]
    id?: StringFilter<"HoroscopeMatch"> | string
    user1Id?: StringFilter<"HoroscopeMatch"> | string
    user2Id?: StringFilter<"HoroscopeMatch"> | string
    horoscope1Id?: StringFilter<"HoroscopeMatch"> | string
    horoscope2Id?: StringFilter<"HoroscopeMatch"> | string
    ashtakootScore?: IntNullableFilter<"HoroscopeMatch"> | number | null
    mangalDoshaMatch?: BoolNullableFilter<"HoroscopeMatch"> | boolean | null
    overallScore?: IntNullableFilter<"HoroscopeMatch"> | number | null
    matchDetails?: JsonNullableFilter<"HoroscopeMatch">
    createdAt?: DateTimeFilter<"HoroscopeMatch"> | Date | string
  }

  export type HoroscopeMatchUpsertWithWhereUniqueWithoutHoroscope2Input = {
    where: HoroscopeMatchWhereUniqueInput
    update: XOR<HoroscopeMatchUpdateWithoutHoroscope2Input, HoroscopeMatchUncheckedUpdateWithoutHoroscope2Input>
    create: XOR<HoroscopeMatchCreateWithoutHoroscope2Input, HoroscopeMatchUncheckedCreateWithoutHoroscope2Input>
  }

  export type HoroscopeMatchUpdateWithWhereUniqueWithoutHoroscope2Input = {
    where: HoroscopeMatchWhereUniqueInput
    data: XOR<HoroscopeMatchUpdateWithoutHoroscope2Input, HoroscopeMatchUncheckedUpdateWithoutHoroscope2Input>
  }

  export type HoroscopeMatchUpdateManyWithWhereWithoutHoroscope2Input = {
    where: HoroscopeMatchScalarWhereInput
    data: XOR<HoroscopeMatchUpdateManyMutationInput, HoroscopeMatchUncheckedUpdateManyWithoutHoroscope2Input>
  }

  export type HoroscopeCreateWithoutMatches1Input = {
    id?: string
    horoscopeUrl?: string | null
    birthTime?: string | null
    birthPlace?: string | null
    rashi?: string | null
    nakshatra?: string | null
    mangalDosha?: boolean | null
    horoscopeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutHoroscopesInput
    profile: ProfileCreateNestedOneWithoutHoroscopeInput
    matches2?: HoroscopeMatchCreateNestedManyWithoutHoroscope2Input
  }

  export type HoroscopeUncheckedCreateWithoutMatches1Input = {
    id?: string
    userId: string
    profileId: string
    horoscopeUrl?: string | null
    birthTime?: string | null
    birthPlace?: string | null
    rashi?: string | null
    nakshatra?: string | null
    mangalDosha?: boolean | null
    horoscopeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    matches2?: HoroscopeMatchUncheckedCreateNestedManyWithoutHoroscope2Input
  }

  export type HoroscopeCreateOrConnectWithoutMatches1Input = {
    where: HoroscopeWhereUniqueInput
    create: XOR<HoroscopeCreateWithoutMatches1Input, HoroscopeUncheckedCreateWithoutMatches1Input>
  }

  export type HoroscopeCreateWithoutMatches2Input = {
    id?: string
    horoscopeUrl?: string | null
    birthTime?: string | null
    birthPlace?: string | null
    rashi?: string | null
    nakshatra?: string | null
    mangalDosha?: boolean | null
    horoscopeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutHoroscopesInput
    profile: ProfileCreateNestedOneWithoutHoroscopeInput
    matches1?: HoroscopeMatchCreateNestedManyWithoutHoroscope1Input
  }

  export type HoroscopeUncheckedCreateWithoutMatches2Input = {
    id?: string
    userId: string
    profileId: string
    horoscopeUrl?: string | null
    birthTime?: string | null
    birthPlace?: string | null
    rashi?: string | null
    nakshatra?: string | null
    mangalDosha?: boolean | null
    horoscopeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    matches1?: HoroscopeMatchUncheckedCreateNestedManyWithoutHoroscope1Input
  }

  export type HoroscopeCreateOrConnectWithoutMatches2Input = {
    where: HoroscopeWhereUniqueInput
    create: XOR<HoroscopeCreateWithoutMatches2Input, HoroscopeUncheckedCreateWithoutMatches2Input>
  }

  export type HoroscopeUpsertWithoutMatches1Input = {
    update: XOR<HoroscopeUpdateWithoutMatches1Input, HoroscopeUncheckedUpdateWithoutMatches1Input>
    create: XOR<HoroscopeCreateWithoutMatches1Input, HoroscopeUncheckedCreateWithoutMatches1Input>
    where?: HoroscopeWhereInput
  }

  export type HoroscopeUpdateToOneWithWhereWithoutMatches1Input = {
    where?: HoroscopeWhereInput
    data: XOR<HoroscopeUpdateWithoutMatches1Input, HoroscopeUncheckedUpdateWithoutMatches1Input>
  }

  export type HoroscopeUpdateWithoutMatches1Input = {
    id?: StringFieldUpdateOperationsInput | string
    horoscopeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    birthTime?: NullableStringFieldUpdateOperationsInput | string | null
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    rashi?: NullableStringFieldUpdateOperationsInput | string | null
    nakshatra?: NullableStringFieldUpdateOperationsInput | string | null
    mangalDosha?: NullableBoolFieldUpdateOperationsInput | boolean | null
    horoscopeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHoroscopesNestedInput
    profile?: ProfileUpdateOneRequiredWithoutHoroscopeNestedInput
    matches2?: HoroscopeMatchUpdateManyWithoutHoroscope2NestedInput
  }

  export type HoroscopeUncheckedUpdateWithoutMatches1Input = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    horoscopeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    birthTime?: NullableStringFieldUpdateOperationsInput | string | null
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    rashi?: NullableStringFieldUpdateOperationsInput | string | null
    nakshatra?: NullableStringFieldUpdateOperationsInput | string | null
    mangalDosha?: NullableBoolFieldUpdateOperationsInput | boolean | null
    horoscopeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matches2?: HoroscopeMatchUncheckedUpdateManyWithoutHoroscope2NestedInput
  }

  export type HoroscopeUpsertWithoutMatches2Input = {
    update: XOR<HoroscopeUpdateWithoutMatches2Input, HoroscopeUncheckedUpdateWithoutMatches2Input>
    create: XOR<HoroscopeCreateWithoutMatches2Input, HoroscopeUncheckedCreateWithoutMatches2Input>
    where?: HoroscopeWhereInput
  }

  export type HoroscopeUpdateToOneWithWhereWithoutMatches2Input = {
    where?: HoroscopeWhereInput
    data: XOR<HoroscopeUpdateWithoutMatches2Input, HoroscopeUncheckedUpdateWithoutMatches2Input>
  }

  export type HoroscopeUpdateWithoutMatches2Input = {
    id?: StringFieldUpdateOperationsInput | string
    horoscopeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    birthTime?: NullableStringFieldUpdateOperationsInput | string | null
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    rashi?: NullableStringFieldUpdateOperationsInput | string | null
    nakshatra?: NullableStringFieldUpdateOperationsInput | string | null
    mangalDosha?: NullableBoolFieldUpdateOperationsInput | boolean | null
    horoscopeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHoroscopesNestedInput
    profile?: ProfileUpdateOneRequiredWithoutHoroscopeNestedInput
    matches1?: HoroscopeMatchUpdateManyWithoutHoroscope1NestedInput
  }

  export type HoroscopeUncheckedUpdateWithoutMatches2Input = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    horoscopeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    birthTime?: NullableStringFieldUpdateOperationsInput | string | null
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    rashi?: NullableStringFieldUpdateOperationsInput | string | null
    nakshatra?: NullableStringFieldUpdateOperationsInput | string | null
    mangalDosha?: NullableBoolFieldUpdateOperationsInput | boolean | null
    horoscopeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matches1?: HoroscopeMatchUncheckedUpdateManyWithoutHoroscope1NestedInput
  }

  export type UserCreateWithoutSuccessStoriesInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    interests?: InterestCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    chats2?: ChatCreateNestedManyWithoutUser2Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSuccessStoriesInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSuccessStoriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSuccessStoriesInput, UserUncheckedCreateWithoutSuccessStoriesInput>
  }

  export type UserUpsertWithoutSuccessStoriesInput = {
    update: XOR<UserUpdateWithoutSuccessStoriesInput, UserUncheckedUpdateWithoutSuccessStoriesInput>
    create: XOR<UserCreateWithoutSuccessStoriesInput, UserUncheckedCreateWithoutSuccessStoriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSuccessStoriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSuccessStoriesInput, UserUncheckedUpdateWithoutSuccessStoriesInput>
  }

  export type UserUpdateWithoutSuccessStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSuccessStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutFamilyMembersInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    interests?: InterestCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    chats2?: ChatCreateNestedManyWithoutUser2Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFamilyMembersInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFamilyMembersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFamilyMembersInput, UserUncheckedCreateWithoutFamilyMembersInput>
  }

  export type UserUpsertWithoutFamilyMembersInput = {
    update: XOR<UserUpdateWithoutFamilyMembersInput, UserUncheckedUpdateWithoutFamilyMembersInput>
    create: XOR<UserCreateWithoutFamilyMembersInput, UserUncheckedCreateWithoutFamilyMembersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFamilyMembersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFamilyMembersInput, UserUncheckedUpdateWithoutFamilyMembersInput>
  }

  export type UserUpdateWithoutFamilyMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFamilyMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutReferralsInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    interests?: InterestCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    chats2?: ChatCreateNestedManyWithoutUser2Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReferralsInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReferralsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
  }

  export type UserCreateWithoutReferredByRefInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    interests?: InterestCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    chats2?: ChatCreateNestedManyWithoutUser2Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReferredByRefInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReferredByRefInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferredByRefInput, UserUncheckedCreateWithoutReferredByRefInput>
  }

  export type UserUpsertWithoutReferralsInput = {
    update: XOR<UserUpdateWithoutReferralsInput, UserUncheckedUpdateWithoutReferralsInput>
    create: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReferralsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReferralsInput, UserUncheckedUpdateWithoutReferralsInput>
  }

  export type UserUpdateWithoutReferralsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReferralsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutReferredByRefInput = {
    update: XOR<UserUpdateWithoutReferredByRefInput, UserUncheckedUpdateWithoutReferredByRefInput>
    create: XOR<UserCreateWithoutReferredByRefInput, UserUncheckedCreateWithoutReferredByRefInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReferredByRefInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReferredByRefInput, UserUncheckedUpdateWithoutReferredByRefInput>
  }

  export type UserUpdateWithoutReferredByRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReferredByRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAchievementsInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    interests?: InterestCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    chats2?: ChatCreateNestedManyWithoutUser2Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAchievementsInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAchievementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
  }

  export type UserUpsertWithoutAchievementsInput = {
    update: XOR<UserUpdateWithoutAchievementsInput, UserUncheckedUpdateWithoutAchievementsInput>
    create: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAchievementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAchievementsInput, UserUncheckedUpdateWithoutAchievementsInput>
  }

  export type UserUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDocumentsInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    interests?: InterestCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    chats2?: ChatCreateNestedManyWithoutUser2Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDocumentsInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
  }

  export type UserUpsertWithoutDocumentsInput = {
    update: XOR<UserUpdateWithoutDocumentsInput, UserUncheckedUpdateWithoutDocumentsInput>
    create: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDocumentsInput, UserUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutVideoCallsAsCallerInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    interests?: InterestCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    chats2?: ChatCreateNestedManyWithoutUser2Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVideoCallsAsCallerInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVideoCallsAsCallerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVideoCallsAsCallerInput, UserUncheckedCreateWithoutVideoCallsAsCallerInput>
  }

  export type UserCreateWithoutVideoCallsAsParticipantInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    interests?: InterestCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    chats2?: ChatCreateNestedManyWithoutUser2Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVideoCallsAsParticipantInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVideoCallsAsParticipantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVideoCallsAsParticipantInput, UserUncheckedCreateWithoutVideoCallsAsParticipantInput>
  }

  export type UserUpsertWithoutVideoCallsAsCallerInput = {
    update: XOR<UserUpdateWithoutVideoCallsAsCallerInput, UserUncheckedUpdateWithoutVideoCallsAsCallerInput>
    create: XOR<UserCreateWithoutVideoCallsAsCallerInput, UserUncheckedCreateWithoutVideoCallsAsCallerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVideoCallsAsCallerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVideoCallsAsCallerInput, UserUncheckedUpdateWithoutVideoCallsAsCallerInput>
  }

  export type UserUpdateWithoutVideoCallsAsCallerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVideoCallsAsCallerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutVideoCallsAsParticipantInput = {
    update: XOR<UserUpdateWithoutVideoCallsAsParticipantInput, UserUncheckedUpdateWithoutVideoCallsAsParticipantInput>
    create: XOR<UserCreateWithoutVideoCallsAsParticipantInput, UserUncheckedCreateWithoutVideoCallsAsParticipantInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVideoCallsAsParticipantInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVideoCallsAsParticipantInput, UserUncheckedUpdateWithoutVideoCallsAsParticipantInput>
  }

  export type UserUpdateWithoutVideoCallsAsParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVideoCallsAsParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProfileCreateWithoutComparisonsInput = {
    id?: string
    status?: $Enums.ProfileStatus
    firstName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    dateOfBirth?: Date | string | null
    height?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    religion?: string | null
    caste?: string | null
    motherTongue?: string | null
    manglik?: boolean | null
    gothra?: string | null
    country?: string | null
    state?: string | null
    city?: string | null
    citizenship?: string | null
    education?: string | null
    college?: string | null
    occupation?: string | null
    income?: number | null
    incomeCurrency?: string | null
    fatherOccupation?: string | null
    motherOccupation?: string | null
    siblings?: number | null
    familyType?: $Enums.FamilyType | null
    diet?: $Enums.Diet | null
    smoking?: boolean | null
    drinking?: boolean | null
    hobbies?: string | null
    partnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    videoIntroUrl?: string | null
    biodataUrl?: string | null
    aboutMe?: string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    privacySettings?: NullableJsonNullValueInput | InputJsonValue
    isHiddenFromSearch?: boolean
    isAnonymousViewing?: boolean
    contactPrivacyLevel?: string | null
    photoPrivacyLevel?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    trustScore?: number
    completenessScore?: number
    isHighlighted?: boolean
    slug?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: PhotoCreateNestedManyWithoutProfileInput
    profileViews?: ProfileViewCreateNestedManyWithoutProfileInput
    shortlistedBy?: ShortlistCreateNestedManyWithoutProfileInput
    horoscope?: HoroscopeCreateNestedOneWithoutProfileInput
    testimonials?: TestimonialCreateNestedManyWithoutProfileInput
    user: UserCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutComparisonsInput = {
    id?: string
    userId: string
    status?: $Enums.ProfileStatus
    firstName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    dateOfBirth?: Date | string | null
    height?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    religion?: string | null
    caste?: string | null
    motherTongue?: string | null
    manglik?: boolean | null
    gothra?: string | null
    country?: string | null
    state?: string | null
    city?: string | null
    citizenship?: string | null
    education?: string | null
    college?: string | null
    occupation?: string | null
    income?: number | null
    incomeCurrency?: string | null
    fatherOccupation?: string | null
    motherOccupation?: string | null
    siblings?: number | null
    familyType?: $Enums.FamilyType | null
    diet?: $Enums.Diet | null
    smoking?: boolean | null
    drinking?: boolean | null
    hobbies?: string | null
    partnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    videoIntroUrl?: string | null
    biodataUrl?: string | null
    aboutMe?: string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    privacySettings?: NullableJsonNullValueInput | InputJsonValue
    isHiddenFromSearch?: boolean
    isAnonymousViewing?: boolean
    contactPrivacyLevel?: string | null
    photoPrivacyLevel?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    trustScore?: number
    completenessScore?: number
    isHighlighted?: boolean
    slug?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: PhotoUncheckedCreateNestedManyWithoutProfileInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutProfileInput
    shortlistedBy?: ShortlistUncheckedCreateNestedManyWithoutProfileInput
    horoscope?: HoroscopeUncheckedCreateNestedOneWithoutProfileInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutComparisonsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutComparisonsInput, ProfileUncheckedCreateWithoutComparisonsInput>
  }

  export type ProfileUpsertWithoutComparisonsInput = {
    update: XOR<ProfileUpdateWithoutComparisonsInput, ProfileUncheckedUpdateWithoutComparisonsInput>
    create: XOR<ProfileCreateWithoutComparisonsInput, ProfileUncheckedCreateWithoutComparisonsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutComparisonsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutComparisonsInput, ProfileUncheckedUpdateWithoutComparisonsInput>
  }

  export type ProfileUpdateWithoutComparisonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    caste?: NullableStringFieldUpdateOperationsInput | string | null
    motherTongue?: NullableStringFieldUpdateOperationsInput | string | null
    manglik?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gothra?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableIntFieldUpdateOperationsInput | number | null
    incomeCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    fatherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    motherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    siblings?: NullableIntFieldUpdateOperationsInput | number | null
    familyType?: NullableEnumFamilyTypeFieldUpdateOperationsInput | $Enums.FamilyType | null
    diet?: NullableEnumDietFieldUpdateOperationsInput | $Enums.Diet | null
    smoking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    drinking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hobbies?: NullableStringFieldUpdateOperationsInput | string | null
    partnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    videoIntroUrl?: NullableStringFieldUpdateOperationsInput | string | null
    biodataUrl?: NullableStringFieldUpdateOperationsInput | string | null
    aboutMe?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    privacySettings?: NullableJsonNullValueInput | InputJsonValue
    isHiddenFromSearch?: BoolFieldUpdateOperationsInput | boolean
    isAnonymousViewing?: BoolFieldUpdateOperationsInput | boolean
    contactPrivacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    photoPrivacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    completenessScore?: IntFieldUpdateOperationsInput | number
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: PhotoUpdateManyWithoutProfileNestedInput
    profileViews?: ProfileViewUpdateManyWithoutProfileNestedInput
    shortlistedBy?: ShortlistUpdateManyWithoutProfileNestedInput
    horoscope?: HoroscopeUpdateOneWithoutProfileNestedInput
    testimonials?: TestimonialUpdateManyWithoutProfileNestedInput
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutComparisonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    caste?: NullableStringFieldUpdateOperationsInput | string | null
    motherTongue?: NullableStringFieldUpdateOperationsInput | string | null
    manglik?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gothra?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableIntFieldUpdateOperationsInput | number | null
    incomeCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    fatherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    motherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    siblings?: NullableIntFieldUpdateOperationsInput | number | null
    familyType?: NullableEnumFamilyTypeFieldUpdateOperationsInput | $Enums.FamilyType | null
    diet?: NullableEnumDietFieldUpdateOperationsInput | $Enums.Diet | null
    smoking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    drinking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hobbies?: NullableStringFieldUpdateOperationsInput | string | null
    partnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    videoIntroUrl?: NullableStringFieldUpdateOperationsInput | string | null
    biodataUrl?: NullableStringFieldUpdateOperationsInput | string | null
    aboutMe?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    privacySettings?: NullableJsonNullValueInput | InputJsonValue
    isHiddenFromSearch?: BoolFieldUpdateOperationsInput | boolean
    isAnonymousViewing?: BoolFieldUpdateOperationsInput | boolean
    contactPrivacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    photoPrivacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    completenessScore?: IntFieldUpdateOperationsInput | number
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: PhotoUncheckedUpdateManyWithoutProfileNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutProfileNestedInput
    shortlistedBy?: ShortlistUncheckedUpdateManyWithoutProfileNestedInput
    horoscope?: HoroscopeUncheckedUpdateOneWithoutProfileNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type UserCreateWithoutForumPostsInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    interests?: InterestCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    chats2?: ChatCreateNestedManyWithoutUser2Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutForumPostsInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutForumPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutForumPostsInput, UserUncheckedCreateWithoutForumPostsInput>
  }

  export type ForumCommentCreateWithoutPostInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutForumCommentsInput
  }

  export type ForumCommentUncheckedCreateWithoutPostInput = {
    id?: string
    userId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumCommentCreateOrConnectWithoutPostInput = {
    where: ForumCommentWhereUniqueInput
    create: XOR<ForumCommentCreateWithoutPostInput, ForumCommentUncheckedCreateWithoutPostInput>
  }

  export type ForumCommentCreateManyPostInputEnvelope = {
    data: ForumCommentCreateManyPostInput | ForumCommentCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutForumPostsInput = {
    update: XOR<UserUpdateWithoutForumPostsInput, UserUncheckedUpdateWithoutForumPostsInput>
    create: XOR<UserCreateWithoutForumPostsInput, UserUncheckedCreateWithoutForumPostsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutForumPostsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutForumPostsInput, UserUncheckedUpdateWithoutForumPostsInput>
  }

  export type UserUpdateWithoutForumPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutForumPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ForumCommentUpsertWithWhereUniqueWithoutPostInput = {
    where: ForumCommentWhereUniqueInput
    update: XOR<ForumCommentUpdateWithoutPostInput, ForumCommentUncheckedUpdateWithoutPostInput>
    create: XOR<ForumCommentCreateWithoutPostInput, ForumCommentUncheckedCreateWithoutPostInput>
  }

  export type ForumCommentUpdateWithWhereUniqueWithoutPostInput = {
    where: ForumCommentWhereUniqueInput
    data: XOR<ForumCommentUpdateWithoutPostInput, ForumCommentUncheckedUpdateWithoutPostInput>
  }

  export type ForumCommentUpdateManyWithWhereWithoutPostInput = {
    where: ForumCommentScalarWhereInput
    data: XOR<ForumCommentUpdateManyMutationInput, ForumCommentUncheckedUpdateManyWithoutPostInput>
  }

  export type UserCreateWithoutForumCommentsInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    interests?: InterestCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    chats2?: ChatCreateNestedManyWithoutUser2Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutForumCommentsInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutForumCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutForumCommentsInput, UserUncheckedCreateWithoutForumCommentsInput>
  }

  export type ForumPostCreateWithoutCommentsInput = {
    id?: string
    title: string
    content: string
    category?: string | null
    tags?: ForumPostCreatetagsInput | string[]
    likes?: number
    views?: number
    isPinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutForumPostsInput
  }

  export type ForumPostUncheckedCreateWithoutCommentsInput = {
    id?: string
    userId: string
    title: string
    content: string
    category?: string | null
    tags?: ForumPostCreatetagsInput | string[]
    likes?: number
    views?: number
    isPinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumPostCreateOrConnectWithoutCommentsInput = {
    where: ForumPostWhereUniqueInput
    create: XOR<ForumPostCreateWithoutCommentsInput, ForumPostUncheckedCreateWithoutCommentsInput>
  }

  export type UserUpsertWithoutForumCommentsInput = {
    update: XOR<UserUpdateWithoutForumCommentsInput, UserUncheckedUpdateWithoutForumCommentsInput>
    create: XOR<UserCreateWithoutForumCommentsInput, UserUncheckedCreateWithoutForumCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutForumCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutForumCommentsInput, UserUncheckedUpdateWithoutForumCommentsInput>
  }

  export type UserUpdateWithoutForumCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutForumCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ForumPostUpsertWithoutCommentsInput = {
    update: XOR<ForumPostUpdateWithoutCommentsInput, ForumPostUncheckedUpdateWithoutCommentsInput>
    create: XOR<ForumPostCreateWithoutCommentsInput, ForumPostUncheckedCreateWithoutCommentsInput>
    where?: ForumPostWhereInput
  }

  export type ForumPostUpdateToOneWithWhereWithoutCommentsInput = {
    where?: ForumPostWhereInput
    data: XOR<ForumPostUpdateWithoutCommentsInput, ForumPostUncheckedUpdateWithoutCommentsInput>
  }

  export type ForumPostUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ForumPostUpdatetagsInput | string[]
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutForumPostsNestedInput
  }

  export type ForumPostUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ForumPostUpdatetagsInput | string[]
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberCreateWithoutGroupInput = {
    id?: string
    role?: string
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutGroupMembersInput
  }

  export type GroupMemberUncheckedCreateWithoutGroupInput = {
    id?: string
    userId: string
    role?: string
    joinedAt?: Date | string
  }

  export type GroupMemberCreateOrConnectWithoutGroupInput = {
    where: GroupMemberWhereUniqueInput
    create: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput>
  }

  export type GroupMemberCreateManyGroupInputEnvelope = {
    data: GroupMemberCreateManyGroupInput | GroupMemberCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type GroupMemberUpsertWithWhereUniqueWithoutGroupInput = {
    where: GroupMemberWhereUniqueInput
    update: XOR<GroupMemberUpdateWithoutGroupInput, GroupMemberUncheckedUpdateWithoutGroupInput>
    create: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput>
  }

  export type GroupMemberUpdateWithWhereUniqueWithoutGroupInput = {
    where: GroupMemberWhereUniqueInput
    data: XOR<GroupMemberUpdateWithoutGroupInput, GroupMemberUncheckedUpdateWithoutGroupInput>
  }

  export type GroupMemberUpdateManyWithWhereWithoutGroupInput = {
    where: GroupMemberScalarWhereInput
    data: XOR<GroupMemberUpdateManyMutationInput, GroupMemberUncheckedUpdateManyWithoutGroupInput>
  }

  export type CommunityGroupCreateWithoutMembersInput = {
    id?: string
    name: string
    description: string
    photoUrl?: string | null
    isPublic?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityGroupUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    description: string
    photoUrl?: string | null
    isPublic?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityGroupCreateOrConnectWithoutMembersInput = {
    where: CommunityGroupWhereUniqueInput
    create: XOR<CommunityGroupCreateWithoutMembersInput, CommunityGroupUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutGroupMembersInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    interests?: InterestCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    chats2?: ChatCreateNestedManyWithoutUser2Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGroupMembersInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGroupMembersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGroupMembersInput, UserUncheckedCreateWithoutGroupMembersInput>
  }

  export type CommunityGroupUpsertWithoutMembersInput = {
    update: XOR<CommunityGroupUpdateWithoutMembersInput, CommunityGroupUncheckedUpdateWithoutMembersInput>
    create: XOR<CommunityGroupCreateWithoutMembersInput, CommunityGroupUncheckedCreateWithoutMembersInput>
    where?: CommunityGroupWhereInput
  }

  export type CommunityGroupUpdateToOneWithWhereWithoutMembersInput = {
    where?: CommunityGroupWhereInput
    data: XOR<CommunityGroupUpdateWithoutMembersInput, CommunityGroupUncheckedUpdateWithoutMembersInput>
  }

  export type CommunityGroupUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityGroupUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutGroupMembersInput = {
    update: XOR<UserUpdateWithoutGroupMembersInput, UserUncheckedUpdateWithoutGroupMembersInput>
    create: XOR<UserCreateWithoutGroupMembersInput, UserUncheckedCreateWithoutGroupMembersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGroupMembersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGroupMembersInput, UserUncheckedUpdateWithoutGroupMembersInput>
  }

  export type UserUpdateWithoutGroupMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGroupMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EventParticipantCreateWithoutEventInput = {
    id?: string
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutEventParticipantsInput
  }

  export type EventParticipantUncheckedCreateWithoutEventInput = {
    id?: string
    userId: string
    joinedAt?: Date | string
  }

  export type EventParticipantCreateOrConnectWithoutEventInput = {
    where: EventParticipantWhereUniqueInput
    create: XOR<EventParticipantCreateWithoutEventInput, EventParticipantUncheckedCreateWithoutEventInput>
  }

  export type EventParticipantCreateManyEventInputEnvelope = {
    data: EventParticipantCreateManyEventInput | EventParticipantCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type EventParticipantUpsertWithWhereUniqueWithoutEventInput = {
    where: EventParticipantWhereUniqueInput
    update: XOR<EventParticipantUpdateWithoutEventInput, EventParticipantUncheckedUpdateWithoutEventInput>
    create: XOR<EventParticipantCreateWithoutEventInput, EventParticipantUncheckedCreateWithoutEventInput>
  }

  export type EventParticipantUpdateWithWhereUniqueWithoutEventInput = {
    where: EventParticipantWhereUniqueInput
    data: XOR<EventParticipantUpdateWithoutEventInput, EventParticipantUncheckedUpdateWithoutEventInput>
  }

  export type EventParticipantUpdateManyWithWhereWithoutEventInput = {
    where: EventParticipantScalarWhereInput
    data: XOR<EventParticipantUpdateManyMutationInput, EventParticipantUncheckedUpdateManyWithoutEventInput>
  }

  export type CommunityEventCreateWithoutParticipantsInput = {
    id?: string
    title: string
    description: string
    eventDate: Date | string
    location: string
    photoUrl?: string | null
    maxParticipants?: number | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityEventUncheckedCreateWithoutParticipantsInput = {
    id?: string
    title: string
    description: string
    eventDate: Date | string
    location: string
    photoUrl?: string | null
    maxParticipants?: number | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityEventCreateOrConnectWithoutParticipantsInput = {
    where: CommunityEventWhereUniqueInput
    create: XOR<CommunityEventCreateWithoutParticipantsInput, CommunityEventUncheckedCreateWithoutParticipantsInput>
  }

  export type UserCreateWithoutEventParticipantsInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    interests?: InterestCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    chats2?: ChatCreateNestedManyWithoutUser2Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEventParticipantsInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEventParticipantsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEventParticipantsInput, UserUncheckedCreateWithoutEventParticipantsInput>
  }

  export type CommunityEventUpsertWithoutParticipantsInput = {
    update: XOR<CommunityEventUpdateWithoutParticipantsInput, CommunityEventUncheckedUpdateWithoutParticipantsInput>
    create: XOR<CommunityEventCreateWithoutParticipantsInput, CommunityEventUncheckedCreateWithoutParticipantsInput>
    where?: CommunityEventWhereInput
  }

  export type CommunityEventUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: CommunityEventWhereInput
    data: XOR<CommunityEventUpdateWithoutParticipantsInput, CommunityEventUncheckedUpdateWithoutParticipantsInput>
  }

  export type CommunityEventUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityEventUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutEventParticipantsInput = {
    update: XOR<UserUpdateWithoutEventParticipantsInput, UserUncheckedUpdateWithoutEventParticipantsInput>
    create: XOR<UserCreateWithoutEventParticipantsInput, UserUncheckedCreateWithoutEventParticipantsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEventParticipantsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEventParticipantsInput, UserUncheckedUpdateWithoutEventParticipantsInput>
  }

  export type UserUpdateWithoutEventParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEventParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutBlogPostsInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    interests?: InterestCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    chats2?: ChatCreateNestedManyWithoutUser2Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBlogPostsInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBlogPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlogPostsInput, UserUncheckedCreateWithoutBlogPostsInput>
  }

  export type UserUpsertWithoutBlogPostsInput = {
    update: XOR<UserUpdateWithoutBlogPostsInput, UserUncheckedUpdateWithoutBlogPostsInput>
    create: XOR<UserCreateWithoutBlogPostsInput, UserUncheckedCreateWithoutBlogPostsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlogPostsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlogPostsInput, UserUncheckedUpdateWithoutBlogPostsInput>
  }

  export type UserUpdateWithoutBlogPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBlogPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutMatchScoresInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    interests?: InterestCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    chats2?: ChatCreateNestedManyWithoutUser2Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMatchScoresInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMatchScoresInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMatchScoresInput, UserUncheckedCreateWithoutMatchScoresInput>
  }

  export type UserCreateWithoutMatchedByInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    interests?: InterestCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    chats2?: ChatCreateNestedManyWithoutUser2Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMatchedByInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMatchedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMatchedByInput, UserUncheckedCreateWithoutMatchedByInput>
  }

  export type UserUpsertWithoutMatchScoresInput = {
    update: XOR<UserUpdateWithoutMatchScoresInput, UserUncheckedUpdateWithoutMatchScoresInput>
    create: XOR<UserCreateWithoutMatchScoresInput, UserUncheckedCreateWithoutMatchScoresInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMatchScoresInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMatchScoresInput, UserUncheckedUpdateWithoutMatchScoresInput>
  }

  export type UserUpdateWithoutMatchScoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMatchScoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutMatchedByInput = {
    update: XOR<UserUpdateWithoutMatchedByInput, UserUncheckedUpdateWithoutMatchedByInput>
    create: XOR<UserCreateWithoutMatchedByInput, UserUncheckedCreateWithoutMatchedByInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMatchedByInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMatchedByInput, UserUncheckedUpdateWithoutMatchedByInput>
  }

  export type UserUpdateWithoutMatchedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMatchedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSearchHistoryInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    interests?: InterestCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    chats2?: ChatCreateNestedManyWithoutUser2Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSearchHistoryInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSearchHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSearchHistoryInput, UserUncheckedCreateWithoutSearchHistoryInput>
  }

  export type UserUpsertWithoutSearchHistoryInput = {
    update: XOR<UserUpdateWithoutSearchHistoryInput, UserUncheckedUpdateWithoutSearchHistoryInput>
    create: XOR<UserCreateWithoutSearchHistoryInput, UserUncheckedCreateWithoutSearchHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSearchHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSearchHistoryInput, UserUncheckedUpdateWithoutSearchHistoryInput>
  }

  export type UserUpdateWithoutSearchHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSearchHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutMessageTemplatesInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    interests?: InterestCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    chats2?: ChatCreateNestedManyWithoutUser2Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMessageTemplatesInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMessageTemplatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessageTemplatesInput, UserUncheckedCreateWithoutMessageTemplatesInput>
  }

  export type UserUpsertWithoutMessageTemplatesInput = {
    update: XOR<UserUpdateWithoutMessageTemplatesInput, UserUncheckedUpdateWithoutMessageTemplatesInput>
    create: XOR<UserCreateWithoutMessageTemplatesInput, UserUncheckedCreateWithoutMessageTemplatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessageTemplatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessageTemplatesInput, UserUncheckedUpdateWithoutMessageTemplatesInput>
  }

  export type UserUpdateWithoutMessageTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMessageTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutIceBreakersInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    interests?: InterestCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    chats2?: ChatCreateNestedManyWithoutUser2Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutIceBreakersInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutIceBreakersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIceBreakersInput, UserUncheckedCreateWithoutIceBreakersInput>
  }

  export type UserUpsertWithoutIceBreakersInput = {
    update: XOR<UserUpdateWithoutIceBreakersInput, UserUncheckedUpdateWithoutIceBreakersInput>
    create: XOR<UserCreateWithoutIceBreakersInput, UserUncheckedCreateWithoutIceBreakersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIceBreakersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIceBreakersInput, UserUncheckedUpdateWithoutIceBreakersInput>
  }

  export type UserUpdateWithoutIceBreakersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutIceBreakersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProfileCreateWithoutTestimonialsInput = {
    id?: string
    status?: $Enums.ProfileStatus
    firstName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    dateOfBirth?: Date | string | null
    height?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    religion?: string | null
    caste?: string | null
    motherTongue?: string | null
    manglik?: boolean | null
    gothra?: string | null
    country?: string | null
    state?: string | null
    city?: string | null
    citizenship?: string | null
    education?: string | null
    college?: string | null
    occupation?: string | null
    income?: number | null
    incomeCurrency?: string | null
    fatherOccupation?: string | null
    motherOccupation?: string | null
    siblings?: number | null
    familyType?: $Enums.FamilyType | null
    diet?: $Enums.Diet | null
    smoking?: boolean | null
    drinking?: boolean | null
    hobbies?: string | null
    partnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    videoIntroUrl?: string | null
    biodataUrl?: string | null
    aboutMe?: string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    privacySettings?: NullableJsonNullValueInput | InputJsonValue
    isHiddenFromSearch?: boolean
    isAnonymousViewing?: boolean
    contactPrivacyLevel?: string | null
    photoPrivacyLevel?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    trustScore?: number
    completenessScore?: number
    isHighlighted?: boolean
    slug?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: PhotoCreateNestedManyWithoutProfileInput
    profileViews?: ProfileViewCreateNestedManyWithoutProfileInput
    shortlistedBy?: ShortlistCreateNestedManyWithoutProfileInput
    horoscope?: HoroscopeCreateNestedOneWithoutProfileInput
    comparisons?: ProfileComparisonCreateNestedManyWithoutProfileInput
    user: UserCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutTestimonialsInput = {
    id?: string
    userId: string
    status?: $Enums.ProfileStatus
    firstName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    dateOfBirth?: Date | string | null
    height?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    religion?: string | null
    caste?: string | null
    motherTongue?: string | null
    manglik?: boolean | null
    gothra?: string | null
    country?: string | null
    state?: string | null
    city?: string | null
    citizenship?: string | null
    education?: string | null
    college?: string | null
    occupation?: string | null
    income?: number | null
    incomeCurrency?: string | null
    fatherOccupation?: string | null
    motherOccupation?: string | null
    siblings?: number | null
    familyType?: $Enums.FamilyType | null
    diet?: $Enums.Diet | null
    smoking?: boolean | null
    drinking?: boolean | null
    hobbies?: string | null
    partnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    videoIntroUrl?: string | null
    biodataUrl?: string | null
    aboutMe?: string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    privacySettings?: NullableJsonNullValueInput | InputJsonValue
    isHiddenFromSearch?: boolean
    isAnonymousViewing?: boolean
    contactPrivacyLevel?: string | null
    photoPrivacyLevel?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    trustScore?: number
    completenessScore?: number
    isHighlighted?: boolean
    slug?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: PhotoUncheckedCreateNestedManyWithoutProfileInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutProfileInput
    shortlistedBy?: ShortlistUncheckedCreateNestedManyWithoutProfileInput
    horoscope?: HoroscopeUncheckedCreateNestedOneWithoutProfileInput
    comparisons?: ProfileComparisonUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutTestimonialsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutTestimonialsInput, ProfileUncheckedCreateWithoutTestimonialsInput>
  }

  export type ProfileUpsertWithoutTestimonialsInput = {
    update: XOR<ProfileUpdateWithoutTestimonialsInput, ProfileUncheckedUpdateWithoutTestimonialsInput>
    create: XOR<ProfileCreateWithoutTestimonialsInput, ProfileUncheckedCreateWithoutTestimonialsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutTestimonialsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutTestimonialsInput, ProfileUncheckedUpdateWithoutTestimonialsInput>
  }

  export type ProfileUpdateWithoutTestimonialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    caste?: NullableStringFieldUpdateOperationsInput | string | null
    motherTongue?: NullableStringFieldUpdateOperationsInput | string | null
    manglik?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gothra?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableIntFieldUpdateOperationsInput | number | null
    incomeCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    fatherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    motherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    siblings?: NullableIntFieldUpdateOperationsInput | number | null
    familyType?: NullableEnumFamilyTypeFieldUpdateOperationsInput | $Enums.FamilyType | null
    diet?: NullableEnumDietFieldUpdateOperationsInput | $Enums.Diet | null
    smoking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    drinking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hobbies?: NullableStringFieldUpdateOperationsInput | string | null
    partnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    videoIntroUrl?: NullableStringFieldUpdateOperationsInput | string | null
    biodataUrl?: NullableStringFieldUpdateOperationsInput | string | null
    aboutMe?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    privacySettings?: NullableJsonNullValueInput | InputJsonValue
    isHiddenFromSearch?: BoolFieldUpdateOperationsInput | boolean
    isAnonymousViewing?: BoolFieldUpdateOperationsInput | boolean
    contactPrivacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    photoPrivacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    completenessScore?: IntFieldUpdateOperationsInput | number
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: PhotoUpdateManyWithoutProfileNestedInput
    profileViews?: ProfileViewUpdateManyWithoutProfileNestedInput
    shortlistedBy?: ShortlistUpdateManyWithoutProfileNestedInput
    horoscope?: HoroscopeUpdateOneWithoutProfileNestedInput
    comparisons?: ProfileComparisonUpdateManyWithoutProfileNestedInput
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutTestimonialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    caste?: NullableStringFieldUpdateOperationsInput | string | null
    motherTongue?: NullableStringFieldUpdateOperationsInput | string | null
    manglik?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gothra?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableIntFieldUpdateOperationsInput | number | null
    incomeCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    fatherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    motherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    siblings?: NullableIntFieldUpdateOperationsInput | number | null
    familyType?: NullableEnumFamilyTypeFieldUpdateOperationsInput | $Enums.FamilyType | null
    diet?: NullableEnumDietFieldUpdateOperationsInput | $Enums.Diet | null
    smoking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    drinking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hobbies?: NullableStringFieldUpdateOperationsInput | string | null
    partnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    videoIntroUrl?: NullableStringFieldUpdateOperationsInput | string | null
    biodataUrl?: NullableStringFieldUpdateOperationsInput | string | null
    aboutMe?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    privacySettings?: NullableJsonNullValueInput | InputJsonValue
    isHiddenFromSearch?: BoolFieldUpdateOperationsInput | boolean
    isAnonymousViewing?: BoolFieldUpdateOperationsInput | boolean
    contactPrivacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    photoPrivacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    completenessScore?: IntFieldUpdateOperationsInput | number
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: PhotoUncheckedUpdateManyWithoutProfileNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutProfileNestedInput
    shortlistedBy?: ShortlistUncheckedUpdateManyWithoutProfileNestedInput
    horoscope?: HoroscopeUncheckedUpdateOneWithoutProfileNestedInput
    comparisons?: ProfileComparisonUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type UserCreateWithoutActivitiesInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    interests?: InterestCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    chats2?: ChatCreateNestedManyWithoutUser2Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutActivitiesInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutActivitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
  }

  export type UserUpsertWithoutActivitiesInput = {
    update: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type UserUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutLeaderboardInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    interests?: InterestCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    chats2?: ChatCreateNestedManyWithoutUser2Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLeaderboardInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLeaderboardInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLeaderboardInput, UserUncheckedCreateWithoutLeaderboardInput>
  }

  export type UserUpsertWithoutLeaderboardInput = {
    update: XOR<UserUpdateWithoutLeaderboardInput, UserUncheckedUpdateWithoutLeaderboardInput>
    create: XOR<UserCreateWithoutLeaderboardInput, UserUncheckedCreateWithoutLeaderboardInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLeaderboardInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLeaderboardInput, UserUncheckedUpdateWithoutLeaderboardInput>
  }

  export type UserUpdateWithoutLeaderboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLeaderboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutWishlistsInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    interests?: InterestCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    chats2?: ChatCreateNestedManyWithoutUser2Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWishlistsInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    profileExports?: ProfileExportUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWishlistsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWishlistsInput, UserUncheckedCreateWithoutWishlistsInput>
  }

  export type UserUpsertWithoutWishlistsInput = {
    update: XOR<UserUpdateWithoutWishlistsInput, UserUncheckedUpdateWithoutWishlistsInput>
    create: XOR<UserCreateWithoutWishlistsInput, UserUncheckedCreateWithoutWishlistsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWishlistsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWishlistsInput, UserUncheckedUpdateWithoutWishlistsInput>
  }

  export type UserUpdateWithoutWishlistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWishlistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutProfileExportsInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileCreateNestedOneWithoutUserInput
    interests?: InterestCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestCreateNestedManyWithoutToUserInput
    chats?: ChatCreateNestedManyWithoutUser1Input
    chats2?: ChatCreateNestedManyWithoutUser2Input
    messages?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewCreateNestedManyWithoutViewedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    shortlists?: ShortlistCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockedInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralCreateNestedManyWithoutReferredInput
    referrer?: UserCreateNestedOneWithoutReferredUsersInput
    referredUsers?: UserCreateNestedManyWithoutReferrerInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedManyWithoutUserInput
    wishlists?: WishlistCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProfileExportsInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    referredBy?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    interests?: InterestUncheckedCreateNestedManyWithoutFromUserInput
    receivedInterests?: InterestUncheckedCreateNestedManyWithoutToUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chats2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    profileViews?: ProfileViewUncheckedCreateNestedManyWithoutViewedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    shortlists?: ShortlistUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredByRef?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    referredUsers?: UserUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    horoscopes?: HoroscopeUncheckedCreateNestedManyWithoutUserInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserInput
    successStories?: SuccessStoryUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    videoCallsAsCaller?: VideoCallUncheckedCreateNestedManyWithoutCallerInput
    videoCallsAsParticipant?: VideoCallUncheckedCreateNestedManyWithoutParticipantInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    groupMembers?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    matchScores?: MatchScoreUncheckedCreateNestedManyWithoutUserInput
    matchedBy?: MatchScoreUncheckedCreateNestedManyWithoutMatchedUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutUserInput
    iceBreakers?: IceBreakerUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    serviceBookings?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProfileExportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileExportsInput, UserUncheckedCreateWithoutProfileExportsInput>
  }

  export type UserUpsertWithoutProfileExportsInput = {
    update: XOR<UserUpdateWithoutProfileExportsInput, UserUncheckedUpdateWithoutProfileExportsInput>
    create: XOR<UserCreateWithoutProfileExportsInput, UserUncheckedCreateWithoutProfileExportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfileExportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfileExportsInput, UserUncheckedUpdateWithoutProfileExportsInput>
  }

  export type UserUpdateWithoutProfileExportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referrer?: UserUpdateOneWithoutReferredUsersNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileExportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InterestCreateManyFromUserInput = {
    id?: string
    toUserId: string
    status?: $Enums.InterestStatus
    message?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterestCreateManyToUserInput = {
    id?: string
    fromUserId: string
    status?: $Enums.InterestStatus
    message?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatCreateManyUser1Input = {
    id?: string
    user2Id: string
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatCreateManyUser2Input = {
    id?: string
    user1Id: string
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateManySenderInput = {
    id?: string
    chatId: string
    content?: string | null
    imageUrl?: string | null
    videoUrl?: string | null
    audioUrl?: string | null
    fileUrl?: string | null
    fileName?: string | null
    messageType?: string
    isRead?: boolean
    isDeleted?: boolean
    deletedBy?: MessageCreatedeletedByInput | string[]
    isReported?: boolean
    createdAt?: Date | string
  }

  export type SubscriptionCreateManyUserInput = {
    id?: string
    plan: $Enums.SubscriptionPlan
    razorpaySubscriptionId?: string | null
    razorpayPlanId?: string | null
    status?: string
    startDate: Date | string
    endDate: Date | string
    contactViewsUsed?: number
    contactViewsLimit?: number | null
    profileBoostCredits?: number
    verifiedBadgeIncluded?: boolean
    horoscopeReportsIncluded?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyUserInput = {
    id?: string
    razorpayOrderId?: string | null
    razorpayPaymentId?: string | null
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    type: string
    addOnType?: $Enums.AddOnType | null
    subscriptionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileViewCreateManyViewedByInput = {
    id?: string
    profileId: string
    createdAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: string
    title: string
    message: string
    isRead?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ShortlistCreateManyUserInput = {
    id?: string
    profileId: string
    folderName?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlockedUserCreateManyBlockerInput = {
    id?: string
    blockedId: string
    reason?: string | null
    createdAt?: Date | string
  }

  export type BlockedUserCreateManyBlockedInput = {
    id?: string
    blockerId: string
    reason?: string | null
    createdAt?: Date | string
  }

  export type ReferralCreateManyReferrerInput = {
    id?: string
    referredId: string
    rewardAmount?: number | null
    status?: string
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ReferralCreateManyReferredInput = {
    id?: string
    referrerId: string
    rewardAmount?: number | null
    status?: string
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserCreateManyReferrerInput = {
    id?: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isMobileVerified?: boolean
    googleId?: string | null
    appleId?: string | null
    fcmToken?: string | null
    referralCode?: string | null
    points?: number
    lastActiveAt?: Date | string | null
    isOnline?: boolean
    lastLoginDate?: Date | string | null
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gdprConsent?: boolean
    gdprConsentAt?: Date | string | null
    deletedAt?: Date | string | null
    preferredLanguage?: string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AchievementCreateManyUserInput = {
    id?: string
    type: string
    title: string
    description?: string | null
    points?: number
    icon?: string | null
    unlockedAt?: Date | string
  }

  export type HoroscopeCreateManyUserInput = {
    id?: string
    profileId: string
    horoscopeUrl?: string | null
    birthTime?: string | null
    birthPlace?: string | null
    rashi?: string | null
    nakshatra?: string | null
    mangalDosha?: boolean | null
    horoscopeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FamilyMemberCreateManyUserInput = {
    id?: string
    name: string
    relation: string
    email?: string | null
    mobile?: string | null
    password?: string | null
    canViewMatches?: boolean
    canSendInterests?: boolean
    canChat?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SuccessStoryCreateManyUserInput = {
    id?: string
    partnerId: string
    title: string
    story: string
    weddingDate?: Date | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: boolean
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyUserInput = {
    id?: string
    type: string
    name: string
    url: string
    expiryDate?: Date | string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCallCreateManyCallerInput = {
    id?: string
    participantId: string
    status?: string
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    cancelledAt?: Date | string | null
    duration?: number | null
    roomId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCallCreateManyParticipantInput = {
    id?: string
    callerId: string
    status?: string
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    cancelledAt?: Date | string | null
    duration?: number | null
    roomId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumPostCreateManyUserInput = {
    id?: string
    title: string
    content: string
    category?: string | null
    tags?: ForumPostCreatetagsInput | string[]
    likes?: number
    views?: number
    isPinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumCommentCreateManyUserInput = {
    id?: string
    postId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupMemberCreateManyUserInput = {
    id?: string
    groupId: string
    role?: string
    joinedAt?: Date | string
  }

  export type EventParticipantCreateManyUserInput = {
    id?: string
    eventId: string
    joinedAt?: Date | string
  }

  export type BlogPostCreateManyUserInput = {
    id?: string
    title: string
    content: string
    excerpt?: string | null
    photoUrl?: string | null
    tags?: BlogPostCreatetagsInput | string[]
    isPublished?: boolean
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchScoreCreateManyUserInput = {
    id?: string
    matchedUserId: string
    overallScore: number
    religionScore?: number | null
    educationScore?: number | null
    lifestyleScore?: number | null
    locationScore?: number | null
    familyScore?: number | null
    matchReasons?: NullableJsonNullValueInput | InputJsonValue
    isReverseMatch?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchScoreCreateManyMatchedUserInput = {
    id?: string
    userId: string
    overallScore: number
    religionScore?: number | null
    educationScore?: number | null
    lifestyleScore?: number | null
    locationScore?: number | null
    familyScore?: number | null
    matchReasons?: NullableJsonNullValueInput | InputJsonValue
    isReverseMatch?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SearchHistoryCreateManyUserInput = {
    id?: string
    profileId?: string | null
    searchQuery?: string | null
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MessageTemplateCreateManyUserInput = {
    id?: string
    name: string
    content: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IceBreakerCreateManyUserInput = {
    id?: string
    profileId: string
    question: string
    answer?: string | null
    createdAt?: Date | string
  }

  export type ActivityCreateManyUserInput = {
    id?: string
    type: string
    title: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LeaderboardCreateManyUserInput = {
    id?: string
    category: string
    rank: number
    score: number
    period: string
    periodStart: Date | string
    periodEnd?: Date | string | null
    createdAt?: Date | string
  }

  export type WishlistCreateManyUserInput = {
    id?: string
    criteria: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileExportCreateManyUserInput = {
    id?: string
    format: string
    url: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type ServiceCreateManyUserInput = {
    id?: string
    type: $Enums.ServiceType
    status?: $Enums.ServiceStatus
    paymentId?: string | null
    amount: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    notes?: string | null
    rating?: number | null
    review?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceBookingCreateManyUserInput = {
    id?: string
    serviceId: string
    providerId?: string | null
    scheduledAt?: Date | string | null
    duration?: number | null
    status?: $Enums.ServiceStatus
    meetingLink?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterestUpdateWithoutFromUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInterestStatusFieldUpdateOperationsInput | $Enums.InterestStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    toUser?: UserUpdateOneRequiredWithoutReceivedInterestsNestedInput
  }

  export type InterestUncheckedUpdateWithoutFromUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    status?: EnumInterestStatusFieldUpdateOperationsInput | $Enums.InterestStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterestUncheckedUpdateManyWithoutFromUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    status?: EnumInterestStatusFieldUpdateOperationsInput | $Enums.InterestStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterestUpdateWithoutToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInterestStatusFieldUpdateOperationsInput | $Enums.InterestStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromUser?: UserUpdateOneRequiredWithoutInterestsNestedInput
  }

  export type InterestUncheckedUpdateWithoutToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromUserId?: StringFieldUpdateOperationsInput | string
    status?: EnumInterestStatusFieldUpdateOperationsInput | $Enums.InterestStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterestUncheckedUpdateManyWithoutToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromUserId?: StringFieldUpdateOperationsInput | string
    status?: EnumInterestStatusFieldUpdateOperationsInput | $Enums.InterestStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatUpdateWithoutUser1Input = {
    id?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user2?: UserUpdateOneRequiredWithoutChats2NestedInput
    messages?: MessageUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateWithoutUser1Input = {
    id?: StringFieldUpdateOperationsInput | string
    user2Id?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateManyWithoutUser1Input = {
    id?: StringFieldUpdateOperationsInput | string
    user2Id?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatUpdateWithoutUser2Input = {
    id?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user1?: UserUpdateOneRequiredWithoutChatsNestedInput
    messages?: MessageUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateWithoutUser2Input = {
    id?: StringFieldUpdateOperationsInput | string
    user1Id?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateManyWithoutUser2Input = {
    id?: StringFieldUpdateOperationsInput | string
    user1Id?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedBy?: MessageUpdatedeletedByInput | string[]
    isReported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chat?: ChatUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedBy?: MessageUpdatedeletedByInput | string[]
    isReported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedBy?: MessageUpdatedeletedByInput | string[]
    isReported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    razorpaySubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contactViewsUsed?: IntFieldUpdateOperationsInput | number
    contactViewsLimit?: NullableIntFieldUpdateOperationsInput | number | null
    profileBoostCredits?: IntFieldUpdateOperationsInput | number
    verifiedBadgeIncluded?: BoolFieldUpdateOperationsInput | boolean
    horoscopeReportsIncluded?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactViews?: ContactViewUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    razorpaySubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contactViewsUsed?: IntFieldUpdateOperationsInput | number
    contactViewsLimit?: NullableIntFieldUpdateOperationsInput | number | null
    profileBoostCredits?: IntFieldUpdateOperationsInput | number
    verifiedBadgeIncluded?: BoolFieldUpdateOperationsInput | boolean
    horoscopeReportsIncluded?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactViews?: ContactViewUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    razorpaySubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contactViewsUsed?: IntFieldUpdateOperationsInput | number
    contactViewsLimit?: NullableIntFieldUpdateOperationsInput | number | null
    profileBoostCredits?: IntFieldUpdateOperationsInput | number
    verifiedBadgeIncluded?: BoolFieldUpdateOperationsInput | boolean
    horoscopeReportsIncluded?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    type?: StringFieldUpdateOperationsInput | string
    addOnType?: NullableEnumAddOnTypeFieldUpdateOperationsInput | $Enums.AddOnType | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addOns?: AddOnUpdateManyWithoutPaymentNestedInput
    services?: ServiceUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    type?: StringFieldUpdateOperationsInput | string
    addOnType?: NullableEnumAddOnTypeFieldUpdateOperationsInput | $Enums.AddOnType | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addOns?: AddOnUncheckedUpdateManyWithoutPaymentNestedInput
    services?: ServiceUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    type?: StringFieldUpdateOperationsInput | string
    addOnType?: NullableEnumAddOnTypeFieldUpdateOperationsInput | $Enums.AddOnType | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileViewUpdateWithoutViewedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutProfileViewsNestedInput
  }

  export type ProfileViewUncheckedUpdateWithoutViewedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileViewUncheckedUpdateManyWithoutViewedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShortlistUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    folderName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutShortlistedByNestedInput
  }

  export type ShortlistUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    folderName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShortlistUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    folderName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockedUserUpdateWithoutBlockerInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocked?: UserUpdateOneRequiredWithoutBlockedByNestedInput
  }

  export type BlockedUserUncheckedUpdateWithoutBlockerInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockedId?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockedUserUncheckedUpdateManyWithoutBlockerInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockedId?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockedUserUpdateWithoutBlockedInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocker?: UserUpdateOneRequiredWithoutBlockedUsersNestedInput
  }

  export type BlockedUserUncheckedUpdateWithoutBlockedInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockerId?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockedUserUncheckedUpdateManyWithoutBlockedInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockerId?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUpdateWithoutReferrerInput = {
    id?: StringFieldUpdateOperationsInput | string
    rewardAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referred?: UserUpdateOneRequiredWithoutReferredByRefNestedInput
  }

  export type ReferralUncheckedUpdateWithoutReferrerInput = {
    id?: StringFieldUpdateOperationsInput | string
    referredId?: StringFieldUpdateOperationsInput | string
    rewardAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUncheckedUpdateManyWithoutReferrerInput = {
    id?: StringFieldUpdateOperationsInput | string
    referredId?: StringFieldUpdateOperationsInput | string
    rewardAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUpdateWithoutReferredInput = {
    id?: StringFieldUpdateOperationsInput | string
    rewardAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referrer?: UserUpdateOneRequiredWithoutReferralsNestedInput
  }

  export type ReferralUncheckedUpdateWithoutReferredInput = {
    id?: StringFieldUpdateOperationsInput | string
    referrerId?: StringFieldUpdateOperationsInput | string
    rewardAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUncheckedUpdateManyWithoutReferredInput = {
    id?: StringFieldUpdateOperationsInput | string
    referrerId?: StringFieldUpdateOperationsInput | string
    rewardAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutReferrerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUpdateOneWithoutUserNestedInput
    interests?: InterestUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUpdateManyWithoutToUserNestedInput
    chats?: ChatUpdateManyWithoutUser1NestedInput
    chats2?: ChatUpdateManyWithoutUser2NestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReferrerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    interests?: InterestUncheckedUpdateManyWithoutFromUserNestedInput
    receivedInterests?: InterestUncheckedUpdateManyWithoutToUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chats2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    profileViews?: ProfileViewUncheckedUpdateManyWithoutViewedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    shortlists?: ShortlistUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredByRef?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    referredUsers?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    horoscopes?: HoroscopeUncheckedUpdateManyWithoutUserNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserNestedInput
    successStories?: SuccessStoryUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    videoCallsAsCaller?: VideoCallUncheckedUpdateManyWithoutCallerNestedInput
    videoCallsAsParticipant?: VideoCallUncheckedUpdateManyWithoutParticipantNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    groupMembers?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    matchScores?: MatchScoreUncheckedUpdateManyWithoutUserNestedInput
    matchedBy?: MatchScoreUncheckedUpdateManyWithoutMatchedUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutUserNestedInput
    iceBreakers?: IceBreakerUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    profileExports?: ProfileExportUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    serviceBookings?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutReferrerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isMobileVerified?: BoolFieldUpdateOperationsInput | boolean
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gdprConsent?: BoolFieldUpdateOperationsInput | boolean
    gdprConsentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AchievementUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HoroscopeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    horoscopeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    birthTime?: NullableStringFieldUpdateOperationsInput | string | null
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    rashi?: NullableStringFieldUpdateOperationsInput | string | null
    nakshatra?: NullableStringFieldUpdateOperationsInput | string | null
    mangalDosha?: NullableBoolFieldUpdateOperationsInput | boolean | null
    horoscopeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutHoroscopeNestedInput
    matches1?: HoroscopeMatchUpdateManyWithoutHoroscope1NestedInput
    matches2?: HoroscopeMatchUpdateManyWithoutHoroscope2NestedInput
  }

  export type HoroscopeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    horoscopeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    birthTime?: NullableStringFieldUpdateOperationsInput | string | null
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    rashi?: NullableStringFieldUpdateOperationsInput | string | null
    nakshatra?: NullableStringFieldUpdateOperationsInput | string | null
    mangalDosha?: NullableBoolFieldUpdateOperationsInput | boolean | null
    horoscopeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matches1?: HoroscopeMatchUncheckedUpdateManyWithoutHoroscope1NestedInput
    matches2?: HoroscopeMatchUncheckedUpdateManyWithoutHoroscope2NestedInput
  }

  export type HoroscopeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    horoscopeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    birthTime?: NullableStringFieldUpdateOperationsInput | string | null
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    rashi?: NullableStringFieldUpdateOperationsInput | string | null
    nakshatra?: NullableStringFieldUpdateOperationsInput | string | null
    mangalDosha?: NullableBoolFieldUpdateOperationsInput | boolean | null
    horoscopeData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    canViewMatches?: BoolFieldUpdateOperationsInput | boolean
    canSendInterests?: BoolFieldUpdateOperationsInput | boolean
    canChat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    canViewMatches?: BoolFieldUpdateOperationsInput | boolean
    canSendInterests?: BoolFieldUpdateOperationsInput | boolean
    canChat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    canViewMatches?: BoolFieldUpdateOperationsInput | boolean
    canSendInterests?: BoolFieldUpdateOperationsInput | boolean
    canChat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuccessStoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    story?: StringFieldUpdateOperationsInput | string
    weddingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuccessStoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    story?: StringFieldUpdateOperationsInput | string
    weddingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuccessStoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    story?: StringFieldUpdateOperationsInput | string
    weddingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photos?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCallUpdateWithoutCallerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participant?: UserUpdateOneRequiredWithoutVideoCallsAsParticipantNestedInput
  }

  export type VideoCallUncheckedUpdateWithoutCallerInput = {
    id?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCallUncheckedUpdateManyWithoutCallerInput = {
    id?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCallUpdateWithoutParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    caller?: UserUpdateOneRequiredWithoutVideoCallsAsCallerNestedInput
  }

  export type VideoCallUncheckedUpdateWithoutParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    callerId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCallUncheckedUpdateManyWithoutParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    callerId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumPostUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ForumPostUpdatetagsInput | string[]
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ForumCommentUpdateManyWithoutPostNestedInput
  }

  export type ForumPostUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ForumPostUpdatetagsInput | string[]
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ForumCommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type ForumPostUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ForumPostUpdatetagsInput | string[]
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumCommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: ForumPostUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type ForumCommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumCommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: CommunityGroupUpdateOneRequiredWithoutMembersNestedInput
  }

  export type GroupMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventParticipantUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: CommunityEventUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type EventParticipantUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventParticipantUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BlogPostUpdatetagsInput | string[]
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BlogPostUpdatetagsInput | string[]
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BlogPostUpdatetagsInput | string[]
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchScoreUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    religionScore?: NullableIntFieldUpdateOperationsInput | number | null
    educationScore?: NullableIntFieldUpdateOperationsInput | number | null
    lifestyleScore?: NullableIntFieldUpdateOperationsInput | number | null
    locationScore?: NullableIntFieldUpdateOperationsInput | number | null
    familyScore?: NullableIntFieldUpdateOperationsInput | number | null
    matchReasons?: NullableJsonNullValueInput | InputJsonValue
    isReverseMatch?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchedUser?: UserUpdateOneRequiredWithoutMatchedByNestedInput
  }

  export type MatchScoreUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchedUserId?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    religionScore?: NullableIntFieldUpdateOperationsInput | number | null
    educationScore?: NullableIntFieldUpdateOperationsInput | number | null
    lifestyleScore?: NullableIntFieldUpdateOperationsInput | number | null
    locationScore?: NullableIntFieldUpdateOperationsInput | number | null
    familyScore?: NullableIntFieldUpdateOperationsInput | number | null
    matchReasons?: NullableJsonNullValueInput | InputJsonValue
    isReverseMatch?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchScoreUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchedUserId?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    religionScore?: NullableIntFieldUpdateOperationsInput | number | null
    educationScore?: NullableIntFieldUpdateOperationsInput | number | null
    lifestyleScore?: NullableIntFieldUpdateOperationsInput | number | null
    locationScore?: NullableIntFieldUpdateOperationsInput | number | null
    familyScore?: NullableIntFieldUpdateOperationsInput | number | null
    matchReasons?: NullableJsonNullValueInput | InputJsonValue
    isReverseMatch?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchScoreUpdateWithoutMatchedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    religionScore?: NullableIntFieldUpdateOperationsInput | number | null
    educationScore?: NullableIntFieldUpdateOperationsInput | number | null
    lifestyleScore?: NullableIntFieldUpdateOperationsInput | number | null
    locationScore?: NullableIntFieldUpdateOperationsInput | number | null
    familyScore?: NullableIntFieldUpdateOperationsInput | number | null
    matchReasons?: NullableJsonNullValueInput | InputJsonValue
    isReverseMatch?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMatchScoresNestedInput
  }

  export type MatchScoreUncheckedUpdateWithoutMatchedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    religionScore?: NullableIntFieldUpdateOperationsInput | number | null
    educationScore?: NullableIntFieldUpdateOperationsInput | number | null
    lifestyleScore?: NullableIntFieldUpdateOperationsInput | number | null
    locationScore?: NullableIntFieldUpdateOperationsInput | number | null
    familyScore?: NullableIntFieldUpdateOperationsInput | number | null
    matchReasons?: NullableJsonNullValueInput | InputJsonValue
    isReverseMatch?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchScoreUncheckedUpdateManyWithoutMatchedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    religionScore?: NullableIntFieldUpdateOperationsInput | number | null
    educationScore?: NullableIntFieldUpdateOperationsInput | number | null
    lifestyleScore?: NullableIntFieldUpdateOperationsInput | number | null
    locationScore?: NullableIntFieldUpdateOperationsInput | number | null
    familyScore?: NullableIntFieldUpdateOperationsInput | number | null
    matchReasons?: NullableJsonNullValueInput | InputJsonValue
    isReverseMatch?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchHistoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    searchQuery?: NullableStringFieldUpdateOperationsInput | string | null
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchHistoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    searchQuery?: NullableStringFieldUpdateOperationsInput | string | null
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    searchQuery?: NullableStringFieldUpdateOperationsInput | string | null
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageTemplateUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageTemplateUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageTemplateUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IceBreakerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IceBreakerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IceBreakerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    criteria?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    criteria?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    criteria?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileExportUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileExportUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileExportUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    amount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUpdateOneWithoutServicesNestedInput
    bookings?: ServiceBookingUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: ServiceBookingUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceBookingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutBookingsNestedInput
    provider?: ServiceProviderUpdateOneWithoutBookingsNestedInput
  }

  export type ServiceBookingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceBookingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhotoCreateManyProfileInput = {
    id?: string
    url: string
    cloudinaryId?: string | null
    isPrimary?: boolean
    isBlurred?: boolean
    isApproved?: boolean
    order?: number
    albumName?: string | null
    caption?: string | null
    createdAt?: Date | string
  }

  export type ProfileViewCreateManyProfileInput = {
    id?: string
    viewedById: string
    createdAt?: Date | string
  }

  export type ShortlistCreateManyProfileInput = {
    id?: string
    userId: string
    folderName?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileComparisonCreateManyProfileInput = {
    id?: string
    userId: string
    comparisonData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type TestimonialCreateManyProfileInput = {
    id?: string
    authorName: string
    authorRelation?: string | null
    authorEmail?: string | null
    content: string
    rating?: number | null
    isApproved?: boolean
    createdAt?: Date | string
  }

  export type PhotoUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    cloudinaryId?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    isBlurred?: BoolFieldUpdateOperationsInput | boolean
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    albumName?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhotoUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    cloudinaryId?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    isBlurred?: BoolFieldUpdateOperationsInput | boolean
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    albumName?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhotoUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    cloudinaryId?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    isBlurred?: BoolFieldUpdateOperationsInput | boolean
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    albumName?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileViewUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewedBy?: UserUpdateOneRequiredWithoutProfileViewsNestedInput
  }

  export type ProfileViewUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileViewUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShortlistUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    folderName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutShortlistsNestedInput
  }

  export type ShortlistUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    folderName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShortlistUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    folderName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileComparisonUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    comparisonData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProfileComparisonUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    comparisonData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProfileComparisonUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    comparisonData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TestimonialUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorRelation?: NullableStringFieldUpdateOperationsInput | string | null
    authorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestimonialUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorRelation?: NullableStringFieldUpdateOperationsInput | string | null
    authorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestimonialUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorRelation?: NullableStringFieldUpdateOperationsInput | string | null
    authorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyChatInput = {
    id?: string
    senderId: string
    content?: string | null
    imageUrl?: string | null
    videoUrl?: string | null
    audioUrl?: string | null
    fileUrl?: string | null
    fileName?: string | null
    messageType?: string
    isRead?: boolean
    isDeleted?: boolean
    deletedBy?: MessageCreatedeletedByInput | string[]
    isReported?: boolean
    createdAt?: Date | string
  }

  export type MessageUpdateWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedBy?: MessageUpdatedeletedByInput | string[]
    isReported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedBy?: MessageUpdatedeletedByInput | string[]
    isReported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedBy?: MessageUpdatedeletedByInput | string[]
    isReported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactViewCreateManySubscriptionInput = {
    id?: string
    profileId: string
    viewedById: string
    createdAt?: Date | string
  }

  export type ContactViewUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    viewedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactViewUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    viewedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactViewUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    viewedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddOnCreateManyPaymentInput = {
    id?: string
    userId: string
    type: $Enums.AddOnType
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ServiceCreateManyPaymentInput = {
    id?: string
    userId: string
    type: $Enums.ServiceType
    status?: $Enums.ServiceStatus
    amount: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    notes?: string | null
    rating?: number | null
    review?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddOnUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumAddOnTypeFieldUpdateOperationsInput | $Enums.AddOnType
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddOnUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumAddOnTypeFieldUpdateOperationsInput | $Enums.AddOnType
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddOnUncheckedUpdateManyWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumAddOnTypeFieldUpdateOperationsInput | $Enums.AddOnType
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    amount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutServicesNestedInput
    bookings?: ServiceBookingUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    amount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: ServiceBookingUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    amount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceBookingCreateManyServiceInput = {
    id?: string
    providerId?: string | null
    userId: string
    scheduledAt?: Date | string | null
    duration?: number | null
    status?: $Enums.ServiceStatus
    meetingLink?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceBookingUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: ServiceProviderUpdateOneWithoutBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutServiceBookingsNestedInput
  }

  export type ServiceBookingUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceBookingUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceBookingCreateManyProviderInput = {
    id?: string
    serviceId: string
    userId: string
    scheduledAt?: Date | string | null
    duration?: number | null
    status?: $Enums.ServiceStatus
    meetingLink?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceBookingUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutServiceBookingsNestedInput
  }

  export type ServiceBookingUncheckedUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceBookingUncheckedUpdateManyWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HoroscopeMatchCreateManyHoroscope1Input = {
    id?: string
    user1Id: string
    user2Id: string
    horoscope2Id: string
    ashtakootScore?: number | null
    mangalDoshaMatch?: boolean | null
    overallScore?: number | null
    matchDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type HoroscopeMatchCreateManyHoroscope2Input = {
    id?: string
    user1Id: string
    user2Id: string
    horoscope1Id: string
    ashtakootScore?: number | null
    mangalDoshaMatch?: boolean | null
    overallScore?: number | null
    matchDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type HoroscopeMatchUpdateWithoutHoroscope1Input = {
    id?: StringFieldUpdateOperationsInput | string
    user1Id?: StringFieldUpdateOperationsInput | string
    user2Id?: StringFieldUpdateOperationsInput | string
    ashtakootScore?: NullableIntFieldUpdateOperationsInput | number | null
    mangalDoshaMatch?: NullableBoolFieldUpdateOperationsInput | boolean | null
    overallScore?: NullableIntFieldUpdateOperationsInput | number | null
    matchDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    horoscope2?: HoroscopeUpdateOneRequiredWithoutMatches2NestedInput
  }

  export type HoroscopeMatchUncheckedUpdateWithoutHoroscope1Input = {
    id?: StringFieldUpdateOperationsInput | string
    user1Id?: StringFieldUpdateOperationsInput | string
    user2Id?: StringFieldUpdateOperationsInput | string
    horoscope2Id?: StringFieldUpdateOperationsInput | string
    ashtakootScore?: NullableIntFieldUpdateOperationsInput | number | null
    mangalDoshaMatch?: NullableBoolFieldUpdateOperationsInput | boolean | null
    overallScore?: NullableIntFieldUpdateOperationsInput | number | null
    matchDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HoroscopeMatchUncheckedUpdateManyWithoutHoroscope1Input = {
    id?: StringFieldUpdateOperationsInput | string
    user1Id?: StringFieldUpdateOperationsInput | string
    user2Id?: StringFieldUpdateOperationsInput | string
    horoscope2Id?: StringFieldUpdateOperationsInput | string
    ashtakootScore?: NullableIntFieldUpdateOperationsInput | number | null
    mangalDoshaMatch?: NullableBoolFieldUpdateOperationsInput | boolean | null
    overallScore?: NullableIntFieldUpdateOperationsInput | number | null
    matchDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HoroscopeMatchUpdateWithoutHoroscope2Input = {
    id?: StringFieldUpdateOperationsInput | string
    user1Id?: StringFieldUpdateOperationsInput | string
    user2Id?: StringFieldUpdateOperationsInput | string
    ashtakootScore?: NullableIntFieldUpdateOperationsInput | number | null
    mangalDoshaMatch?: NullableBoolFieldUpdateOperationsInput | boolean | null
    overallScore?: NullableIntFieldUpdateOperationsInput | number | null
    matchDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    horoscope1?: HoroscopeUpdateOneRequiredWithoutMatches1NestedInput
  }

  export type HoroscopeMatchUncheckedUpdateWithoutHoroscope2Input = {
    id?: StringFieldUpdateOperationsInput | string
    user1Id?: StringFieldUpdateOperationsInput | string
    user2Id?: StringFieldUpdateOperationsInput | string
    horoscope1Id?: StringFieldUpdateOperationsInput | string
    ashtakootScore?: NullableIntFieldUpdateOperationsInput | number | null
    mangalDoshaMatch?: NullableBoolFieldUpdateOperationsInput | boolean | null
    overallScore?: NullableIntFieldUpdateOperationsInput | number | null
    matchDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HoroscopeMatchUncheckedUpdateManyWithoutHoroscope2Input = {
    id?: StringFieldUpdateOperationsInput | string
    user1Id?: StringFieldUpdateOperationsInput | string
    user2Id?: StringFieldUpdateOperationsInput | string
    horoscope1Id?: StringFieldUpdateOperationsInput | string
    ashtakootScore?: NullableIntFieldUpdateOperationsInput | number | null
    mangalDoshaMatch?: NullableBoolFieldUpdateOperationsInput | boolean | null
    overallScore?: NullableIntFieldUpdateOperationsInput | number | null
    matchDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumCommentCreateManyPostInput = {
    id?: string
    userId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumCommentUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutForumCommentsNestedInput
  }

  export type ForumCommentUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumCommentUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberCreateManyGroupInput = {
    id?: string
    userId: string
    role?: string
    joinedAt?: Date | string
  }

  export type GroupMemberUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGroupMembersNestedInput
  }

  export type GroupMemberUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventParticipantCreateManyEventInput = {
    id?: string
    userId: string
    joinedAt?: Date | string
  }

  export type EventParticipantUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEventParticipantsNestedInput
  }

  export type EventParticipantUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventParticipantUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileCountOutputTypeDefaultArgs instead
     */
    export type ProfileCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChatCountOutputTypeDefaultArgs instead
     */
    export type ChatCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChatCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionCountOutputTypeDefaultArgs instead
     */
    export type SubscriptionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentCountOutputTypeDefaultArgs instead
     */
    export type PaymentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceCountOutputTypeDefaultArgs instead
     */
    export type ServiceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceProviderCountOutputTypeDefaultArgs instead
     */
    export type ServiceProviderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceProviderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HoroscopeCountOutputTypeDefaultArgs instead
     */
    export type HoroscopeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HoroscopeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ForumPostCountOutputTypeDefaultArgs instead
     */
    export type ForumPostCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ForumPostCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommunityGroupCountOutputTypeDefaultArgs instead
     */
    export type CommunityGroupCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommunityGroupCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommunityEventCountOutputTypeDefaultArgs instead
     */
    export type CommunityEventCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommunityEventCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileDefaultArgs instead
     */
    export type ProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PhotoDefaultArgs instead
     */
    export type PhotoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PhotoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VerificationDefaultArgs instead
     */
    export type VerificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VerificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InterestDefaultArgs instead
     */
    export type InterestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InterestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChatDefaultArgs instead
     */
    export type ChatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChatDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageDefaultArgs instead
     */
    export type MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileViewDefaultArgs instead
     */
    export type ProfileViewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileViewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContactViewDefaultArgs instead
     */
    export type ContactViewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContactViewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionDefaultArgs instead
     */
    export type SubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentDefaultArgs instead
     */
    export type PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AddOnDefaultArgs instead
     */
    export type AddOnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AddOnDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceDefaultArgs instead
     */
    export type ServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceProviderDefaultArgs instead
     */
    export type ServiceProviderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceProviderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceBookingDefaultArgs instead
     */
    export type ServiceBookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceBookingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SavedSearchDefaultArgs instead
     */
    export type SavedSearchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SavedSearchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OTPDefaultArgs instead
     */
    export type OTPArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OTPDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminDefaultArgs instead
     */
    export type AdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportDefaultArgs instead
     */
    export type ReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShortlistDefaultArgs instead
     */
    export type ShortlistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShortlistDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlockedUserDefaultArgs instead
     */
    export type BlockedUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlockedUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HoroscopeDefaultArgs instead
     */
    export type HoroscopeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HoroscopeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HoroscopeMatchDefaultArgs instead
     */
    export type HoroscopeMatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HoroscopeMatchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SuccessStoryDefaultArgs instead
     */
    export type SuccessStoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SuccessStoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FamilyMemberDefaultArgs instead
     */
    export type FamilyMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FamilyMemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReferralDefaultArgs instead
     */
    export type ReferralArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReferralDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AchievementDefaultArgs instead
     */
    export type AchievementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AchievementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentDefaultArgs instead
     */
    export type DocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VideoCallDefaultArgs instead
     */
    export type VideoCallArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VideoCallDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileComparisonDefaultArgs instead
     */
    export type ProfileComparisonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileComparisonDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ForumPostDefaultArgs instead
     */
    export type ForumPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ForumPostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ForumCommentDefaultArgs instead
     */
    export type ForumCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ForumCommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommunityGroupDefaultArgs instead
     */
    export type CommunityGroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommunityGroupDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GroupMemberDefaultArgs instead
     */
    export type GroupMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GroupMemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommunityEventDefaultArgs instead
     */
    export type CommunityEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommunityEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventParticipantDefaultArgs instead
     */
    export type EventParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventParticipantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlogPostDefaultArgs instead
     */
    export type BlogPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlogPostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MatchScoreDefaultArgs instead
     */
    export type MatchScoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MatchScoreDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SearchHistoryDefaultArgs instead
     */
    export type SearchHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SearchHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageTemplateDefaultArgs instead
     */
    export type MessageTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IceBreakerDefaultArgs instead
     */
    export type IceBreakerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IceBreakerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TestimonialDefaultArgs instead
     */
    export type TestimonialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TestimonialDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActivityDefaultArgs instead
     */
    export type ActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActivityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeaderboardDefaultArgs instead
     */
    export type LeaderboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeaderboardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WishlistDefaultArgs instead
     */
    export type WishlistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WishlistDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileExportDefaultArgs instead
     */
    export type ProfileExportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileExportDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}